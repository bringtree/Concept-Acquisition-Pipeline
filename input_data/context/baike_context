在数据通信中，一个物理网络节点可以是数据电路端接设备（DCE），如调制解调器、集线器、桥接器或交换机；也可以是一个数据终端设备（DTE），如数字手机，打印机或主机（例如路由器、工作站或服务器）。
如果所讨论的网络是一个LAN或WAN，每一个LAN或WAN节点（至少应该是数据链路层设备）必须拥有MAC地址，一般每个网卡拥有一个。例如计算机、包交换机、xDSL调制解调器（带有乙太接口）以及无线LAN接入点。注意，集线器构成一个物理网络节点，但是并不构成LAN网络节点。这是因为一个使用集线器连接的网络逻辑上来说是一个总线网络。类似的，中继器或PSTN调制解调器（带有串行接口）是一个物理网络节点而不是一个LAN节点。
如果所讨论的网络是Internet或一个Intranet，许多物理网络节点是主机（即通过IP地址来标识的Internet节点）。所有的主机都是物理网络节点。但是，一些数据链路层设备，如交换机、桥接器和WLAN接入点不拥有IP主机地址（除了有时用于管理目的），这些设备不认为是Internet节点或主机，但它们是物理网络节点和LAN节点。
[1]
在固定电话网络中，一个节点可能是公开或私有的电话交换局、远程集线器或计算机，提供了一些智能网络服务。在蜂窝通信中，交换点和数据库，如基站控制器、归属位置寄存器、网关GPRS支持节点（GGSN）和GPRS服务支持节点（SGSN）都是节点的例子。蜂窝网络基站在此上下文中不被认为是节点。
在有线电视系统（CATV）中，这个术语有较广的语境，通常与光纤节点相关。这可以被定义为由一个公共光纤接收器提供服务的特定地理范围内的家庭或办公地点。一个光纤节点通常使用特定光纤节点所服务的"家园通过"数来描述。
[2]
网络拓扑，指构成网络的成员间特定的排列方式。分为物理的，即真实的、或者逻辑的，即虚拟的两种。如果两个网络的连接结构相同，我们就说它们的网络拓扑相同，尽管它们各自内部的物理接线、节点间距离可能会有不同。
[3]
结束系统
主机
网络硬件
终端
排序问题的输出的是原序列的一个重排<a1*,a2*,a3*,...,an*>；，使得a1*<=a2*<=a3*<=...<=an*。排序算法有很多，包括插入排序，冒泡排序，堆排序，归并排序，选择排序，计数排序，基数排序，桶排序，快速排序等。插入排序，堆排序，选择排序，归并排序和快速排序，冒泡排序都是比较排序，它们通过对数组中的元素进行比较来实现排序，其他排序算法则是利用非比较的其他方法来获得有关输入数组的排序信息。
[2]
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
[1]
①初始状态：无序区为R[0..n-1]（共n个元素），有序区为空。
[1]
②第1趟排序
设置一个变量i，让i从0至n-2循环的同时，在对比数组中元素i跟元素i+1的大小，如果R[i+1]比R[i]小，则用一个变量k来记住他的位置（即k=i+1）。等到循环结束的时候，我们应该找到了R中最小的那个数的位置了。然后进行判断，如果这个最小元素的不是R的第一个元素，就让第一个元素跟他交换一下值，使R[0..0]和R[1..n-1]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。
[1]
……
③第i趟排序
第i趟排序开始时，当前有序区和无序区分别为R[0..i-1]和R[i..n-1]。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[0..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。
[1]
选择排序时间复杂度
选择排序的交换操作介于 0 和 (n - 1） 次之间。选择排序的比较操作为 n (n - 1） / 2 次之间。选择排序的赋值操作介于 0 和 3 (n - 1） 次之间。比较次数O(n^2），比较次数与关键字的初始状态无关，总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2。交换次数O(n），最好情况是，已经有序，交换0次；最坏情况交换n-1次，逆序交换n/2次。交换次数比冒泡排序少多了，由于交换所需CPU时间比比较所需的CPU时间多，n值较小时，选择排序比冒泡排序快。
[1]
选择排序稳定性
选择排序是给每个位置选择当前元素最小的，比如给第一个位置选择最小的，在剩余元素里面给第二个元素选择第二小的，依次类推，直到第n-1个元素，第n个元素不用选择了，因为只剩下它一个最大的元素了。那么，在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。比较拗口，举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。
[1]
选择排序输入输出
输入输出与基本选择排序相同。
[3]
选择排序思想
利用满二叉树的性质，将输入的数据存放到满二叉树的叶节点，通过比较树中剩余可用节点（从底层的叶节点开始）的大小，每次选择最小的数值（比较复制到二叉树的顶端），并且把最小数值赋给排序数组的前端，把最小数值原来叶节点的位置设置为不可用；依次循环直至最后一个可用叶节点。
[3]
template 
class TreeNode{ 
public: 
    T data; 
    int index; 
    int active; 
    TreeNode & operator=(TreeNode & treenode) 
    { 
        this->data=treenode.data; 
        this->index=treenode.index; 
        this->active=treenode.active; 
        return *this; 
    } 
}; 

树节点数据结构包括了data数值，index用来存放该数值在叶节点存放的位置（所有数据开始都是存放在叶节点），active表示激活没有，最后如果该数据移植树根部，则将active字段置0无效。
选择排序C#
C#实现选择排序：
[2]
static void sort(int[]group)
{
    int temp;
    int pos=0;
    for(int i=0;i< group.Length-1;i++)
    {
        pos=i;
        for(intj=i+1;j<group.Length;j++)
        {
            if(group[j]<group[pos])
            {
                pos=j;
            }
        }//第i个数与最小的数group[pos]交换
        temp=group[i];
        group[i]=group[pos];
        group[pos]=temp;
    }
}
选择排序C
C实现选择排序：
[1]
void select_sort(int*a,int n)

{

    register int i,j,min,t;

    for(i=0;i<n-1;i++)

    {

        min=i;//查找最小值

        for(j=i+1;j<n;j++)

            if(a[min]>a[j])

                min=j;//交换

        if(min!=i)

        {

            t=a[min];

            a[min]=a[i];

            a[i]=t;

        }

    }

}
选择排序C++
C++实现选择排序：
[2]
#include<iostream>
#include<time.h>
#include<iomanip>
using namespace std;
const int N=10;
int main()
{
    int a[N],i,j,temp,b;
    srand(time(NULL));
    for(i=0;i<N;i++)
        a[i]=rand()%100;
    for(i=0;i<N;i++)
        cout<<setw(3)<<a[i];
    cout<<endl;
    for(i=0;i<N-1;i++)
    {
        temp=i;
        for(j=i+1;j<N;j++)
        {
            if(a[temp]>a[j])
                temp=j;
        }
        if(i!=temp)
        {
            b=a[temp];
            a[temp]=a[i];
            a[i]=b;
        }
    }
    for(i=0;i<N;i++)
        cout<<setw(3)<<a[i];
    cout<<endl;
}
选择排序Java
Java实现选择排序：
[2]
public static void selectionSort(int[] arr){
       
       for (int i = 0; i < arr.length - 1; i++) {    
            int  min = i;
            for (int j = i + 1; j < arr.length; j++) {
                  if (arr[min] > arr[j]) {
                       min = j;
                  }
            }
            if (min != i) {
               int tmp = arr[min];
               arr[min] = arr[i];
               arr[i] = tmp;
            }             
      }

}
选择排序Swift
Swift实现选择排序：
[2]
func selectionSort(_ nums: inout [Int]) {
    guard false == nums.isEmpty else { return }
    
    let count = nums.count
    for i in 0..<count {
        var minIndex = i
        for j in (i + 1)..<count {
            if nums[minIndex] > nums[j] {
                minIndex = j
            }
        }
        if i != minIndex {
            (nums[minIndex], nums[i]) = (nums[i], nums[minIndex])
        }
    }
}
选择排序JavaScript
Javascript实现选择排序：
[2]
var arr = new Array(1, 3, 2, 8, 9, 1, 5);
function SelectionSort(arr) {
    if (arr == null || arr.length < 2) {
         return arr;
    }
    for (var i = 0; i < (arr.length - 1); i++) {
        let minIndex = i;
        for (let j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        let temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
console.log(arr);
SelectionSort(arr);
console.log(arr);
选择排序Golang
Golang实现选择排序：
[2]
func SelectionSort(nums []int32) {
    length := len(nums)
    for i := 0; i < length; i++ {
        min := i
        for j := i + 1; j < length; j++ {
            if nums[j] < nums[min] {
                min = j
            }
        }
        temp := nums[i]
        nums[i] = nums[min]
        nums[min] = temp
    }
    fmt.Println(nums)
}
选择排序Python
Python实现选择排序：
[2]
def selection_sort(list2):
  for i in range(0, len (list2)-1):
    min_ = i
    for j in range(i + 1, len(list2)):
      if list2[j] < list2[min_]:
        min_ = j
    list2[i], list2[min_] = list2[min_], list2[i]  # swap
选择排序Pascal
Pascal实现选择排序：
[2]
var num,temp,k,loop1,loop2:longint;
a:array[1..1000] of longint;
begin
readln(num);//读入数据个数
for loop1:=1to num do
read(a[loop1]);//读入进行排序的数据
for loop1:=1to num-1 do
begin
k:= loop1;
for loop2:=loop1+1to num do
ifa[k]>a[loop2]then
k:=loop2;//比较得出最小数
ifk<>loop1then//优化节省时间
begin
temp:=a[k];
a[k]:=a[loop1];
a[loop1]:=temp;//进行数据交换
end;
end;
forloop1:=1to num do
write(a[loop1],'');//输出排序后的数据
readln;
readln;
end.
选择排序Perl
PERL实现选择排序：
[2]
#!/usr/bin/perl
subselect_sort{
    my(*array)=@_;
    $length=@array;
    for($i=0;$i<$length-1;$i++)
    {
        $min=$i;
        for($j=$i+1;$j<$length;$j++)
        {
            if($array[$j]<$array[$min])
            {
                $min=$j;
            }
            if($min!=$i)
            {
                $temp=$array[$i];
                $array[$i]=$array[$min];
                $array[$min]=$temp;
            }
        }
        return@array;
    }
选择排序PHP
PHP实现选择排序：
[2]
function selection_sort($array){
    $count=count($array);
    for($i=0;$i<$count-1;$i++){
        /*findtheminest*/
        $min=$i;
        echo'$min-->'.$array[$min].'-->';
        for($j=$i+1;$j<$count;$j++){
            //由小到大排列
            if($array[$min]>$array[$j]){
                //表明当前最小的还比当前的元素大
                $min=$j;
                //赋值新的最小的
            }
        }
        echo$array[$min].'coco<br/>';
        /*swap$array[$i]and$array[$min]即将当前内循环的最小元素放在$i位置上*/
        if($min!=$i){
            $temp=$array[$min];
            $array[$min]=$array[$i];
            $array[$i]=$temp;
        }
    }
    return$array;
}
$old_array=array(3,4,5,6,8,2,12);
$new_array=selection_sort($old_array);
print_r($new_array);
选择排序Ruby
Ruby实现选择排序：
[2]
def selection_sort(array)  
  result = []  
  array.size.times { result << array.delete_at(array.index(array.min)) } 
  result
end
选择排序vb
vb实现选择排序：
[2]
Private Sub xzPaiXu(a()AsDouble,shengAsBoolean)
'a为需要排序的数组，sheng为True则为升序排列，为False，则为降序排列。
Dim i AsInteger,j As Integer
Dim temp As Double
Dimm As Integer
For i = LBound(a) To UBound(a)-1
'进行数组大小-1轮比较m=i'在第i轮比较时，假定第'i个元素为最值元素
For j = i+1 To UBound(a)
'在剩下的元素中找出最'值元素的下标并记录在m中
If sheng Then
'若为升序，则m记录最小元素'下标,否则记录最大元素下标
If a(j)<a(m) Then
m=j
Else If a(j) > a(m) Then
m=j
End If
Next j
'将最值元素与第i个元素交换
temp=a(i)
a(i)=a(m)
a(m)=temp
Next i
End Sub
无向图



的极大连通子图称为



的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。
[1]
连通分量路径
①无向图的路径：在无向图



中，若存在一个顶点序列



 使得



 均属于



 ，则称顶点



 到



 存在一条路径(Path)。
②有向图的路径：在有向图



中，路径也是有向的，它由



 中的有向边



 组成。
③路径长度：路径长度定义为该路径上边的数目。
[1]
连通分量顶点间的连通性
在无向图



中，若从顶点



 到顶点



 有路径（当然从



 到



 也一定有路径），则称



 和



 是连通的。
连通分量连通图
若



中任意两个不同的顶点



 和



 都连通（即有路径），则称



为连通图(Connected Graph)。例如，图



2是连通图。
连通分量强连通图
有向图



中，若对于



中任意两个不同的顶点



 和



 ，都存在从



 到



 以及从



 到



 的路径，则称



是强连通图。
连通分量强连通分量
有向图的极大强连通子图称为



的强连通分量，强连通图只有一个强连通分量，即是其自身。非强连通的有向图有多个强连通分量。
[1]
作为遍历图的应用举例，下面我们来讨论如何求图的连通分量。无向图中的极大连通子图称为连通分量。求图的连通分量的目的，是为了确定从图中的一个顶点是否能到达图中的另一个顶点，也就是说，图中任意两个顶点之间是否有路径可达。这个问题从图上可以直观地看出答案，然而，一旦把图存入计算机中，答案就不大清楚了。
对于连通图，从图中任一顶点出发遍历图，可以访问到图的所有顶点，即连通图中任意两顶点间都是有路径可达的。
对于非连通图，从图中某个顶点



 出发遍历图，只能访问到包含顶点



 的那个连通分量中的所有顶点，而访问不到别的连通分量中的顶点。这就是说，在连通分量中的任意一对顶点之间都有路径，但是如果



 和



 分别处于图的不同连通分量之中，则图中就没有从



 到



 的路径，即从



 不可达



 。因此，只要求出图的所有连通分量，就可以知道图中任意两顶点之间是否有路径可达。
[2]
前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。
若二叉树为空则结束返回，否则：
（1）访问根结点。
（2）前序遍历左子树。
（3）前序遍历右子树 。




前序遍历
需要注意的是：遍历左右子树时仍然采用前序遍历方法。
如右图所示二叉树
前序遍历结果：ABDECF
已知后序遍历和中序遍历，就能确定前序遍历。
当对一棵数学表达式树进行中序，前序和后序遍历时，就分别得到表达式的中缀、前缀和后缀形式。
在后缀（postfix）表达式中，每个操作符跟在操作数之后，操作数按从左到右的顺序出现。在前缀（prefix）表达式中，操作符位于操作数之前。在前缀和后缀表达式中不会存在歧义。
因此，在前缀和后缀表达式中都不必采用括号或优先级。从左到右或从右到左扫描表达式并采用操作数栈，可以很容易确定操作数和操作符的关系。若在扫描中遇到一个操作数，把它压入堆栈，若遇到一个操作符，则将其与栈顶的操作数相匹配。把这些操作数推出栈，由操作符执行相应的计算，并将所得结果作为操作数压入堆栈。
[1]

设二叉树中元素数目为n。这四种遍历算法的空间复杂性均为O (n)，时间复杂性为O(n)。
当t 的高度为n时(右斜二叉树的情况)，通过观察其前序、中序和后序遍历时所使用的递归栈空间即可得到上述结论。
[1]
前序遍历C语言
树节点结构和算法：
typedef struct TreeNode
{
    int data;
    TreeNode * left;
    TreeNode * right;
    TreeNode * parent;
}TreeNode;

void pre_order(TreeNode * Node)
{
    if(Node != NULL)
    {
        printf("%d ", Node->data);
        pre_order(Node->left);
        pre_order(Node->right);
    }
}
调用时：
pre_order(Root); //Root为树的根
前序遍历Pascal版本
核心代码：
procedure first(i:longint);
begin
write(a[i]);
if a[i*2]<>0 then first(i*2）；
if a[i*2+1]<>0 then first(i*2+1）；
end;
前序遍历Java版本
二叉树定义
publicclassTreeNode{
    intval;
    TreeNodeleft;
    TreeNoderight;
    TreeNode(intx){
        val=x;
    }
}
递归实现
publicvoidpreOrder(TreeNodebiTree){
    System.out.printf(biTree.val+"");
    TreeNodeleftTree=biTree.left;
    if(leftTree!=null){
        preOrder(leftTree);
    }
    TreeNoderightTree=biTree.right;
    if(rightTree!=null){
        preOrder(rightTree);
    }
}
非递归实现
publicvoidpreOrder(TreeNodebiTree){
    Stack<TreeNode>stack=newStack<TreeNode>();
    while(biTree!=null||!stack.isEmpty()){
        while(node!=null){
            System.out.print(biTree.value+",");
            stack.push(biTree);
            biTree=biTree.left;
        }
        if(!stack.isEmpty()){
            biTree=stack.pop();
            biTree=biTree.right;
        }
    }
}
哈希表中元素是由哈希函数确定的。将数据元素的关键字K作为自变量，通过一定的函数关系（称为哈希函数），计算出的值，即为该元素的存储地址。表示为：
Addr = H（key）
为此在建立一个哈希表之前需要解决两个主要问题：
⑴构造一个合适的哈希函数
均匀性 H（key）的值均匀分布在哈希表中；
简单　以提高地址计算的速度
⑵冲突的处理
冲突：在哈希表中，不同的关键字值对应到同一个存储位置的现象。即关键字K1≠K2，但H（K1）= H（K2）。均匀的哈希函数可以减少冲突，但不能避免冲突。发生冲突后，必须解决；也即必须寻找下一个可用地址。
解决冲突的方法：
[1]
⑴链接法（拉链法）。将具有同一散列地址的记录存储在一条线性链表中。例，除留余数法中，设关键字为 （18,14,01,68,27,55,79），除数为13。散列地址为 （5,1,1,3,1,3,1），哈希散列表如图。
⑵开放定址法。如果h(k）已经被占用，按如下序列探查：(h(k)+p⑴）%TSize,(h(k)+p⑵）%TSize，…，（h(k)+p(i))%TSize，…
其中，h(k)为哈希函数，TSize为哈希表长，p(i）为探查函数。在 h(k)+p(i-1)）%TSize的基础上，若发现冲突，则使用增量 p(i) 进行新的探测，直至无冲突出现为止。其中，根据探查函数p(i）的不同，开放定址法又分为线性探查法（p(i) = i : 1,2,3，…），二次探查法（p(i)=(-1)^(i-1)*((i+1)/2)^2，探查序列依次为：1, -1,4, -4, 9 …），随机探查法（p(i): 随机数），双散列函数法（双散列函数h(key) ，hp (key）若h(key）出现冲突，则再使用hp (key）求取散列地址。探查序列为：h(k),h(k)+ hp(k），…，h(k)+ i*hp(k））。
⑶桶定址法。桶：一片足够大的存储空间。桶定址：为表中的每个地址关联一个桶。如果桶已经满了，可以使用开放定址法来处理。例如，插入A5,A2,A3,B5,A9,B2,B9,C2，采用线性探查法解决冲突。如图。

哈希函数直接定址法
例如：有一个从1到100岁的人口数字统计表，其中，年龄作为关键字，哈希函数取关键字自身。
哈希函数数字分析法
有学生的生日数据如下：
年.月.日
75.10.03
75.11.23
76.03.02
76.07.12
75.04.21
76.02.15
...
经分析，第一位，第二位，第三位重复的可能性大，取这三位造成冲突的机会增加，所以尽量不取前三位，取后三位比较好。
哈希函数平方取中法
取关键字平方后的中间几位为哈希地址。
哈希函数折叠法
将关键字分割成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍去进位）作为哈希地址，这方法称为折叠法。
例如：每一种西文图书都有一个国际标准图书编号，它是一个10位的十进制数字，若要以它作关键字建立一个哈希表，当馆藏书种类不到10,000时，可采用此法构造一个四位数的哈希函数。
哈希函数除留余数法
取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。
H(key)=key MOD p (p<=m)
哈希函数随机数法
选择一个随机函数，取关键字的随机函数值为它的哈希地址，即
H(key)=random(key），其中random为随机函数。通常用于关键字长度不等时采用此法。
若已知哈希函数及冲突处理方法，哈希表的建立步骤如下：
Step1.　取出一个数据元素的关键字key，计算其在哈希表中的存储地址D=H(key）。若存储地址为D的存储空间还没有被占用，则将该数据元素存入；否则发生冲突，执行Step2。
Step2.　根据规定的冲突处理方法，计算关键字为key的数据元素之下一个存储地址。若该存储地址的存储空间没有被占用，则存入；否则继续执行Step2，直到找出一个存储空间没有被占用的存储地址为止。
无论哈希函数设计有多么精细，都会产生冲突现象，也就是2个关键字处理函数的结果映射在了同一位置上，因此，有一些方法可以避免冲突。
哈希函数拉链法
拉出一个动态链表代替静态顺序存储结构，可以避免哈希函数的冲突，不过缺点就是链表的设计过于麻烦，增加了编程复杂度。此法可以完全避免哈希函数的冲突。
哈希函数多哈希法
设计二种甚至多种哈希函数，可以避免冲突，但是冲突几率还是有的，函数设计的越好或越多都可以将几率降到最低（除非人品太差，否则几乎不可能冲突）。
哈希函数开放地址法
开放地址法有一个公式：Hi=(H(key)+di) MOD m i=1,2,...,k(k<=m-1）
其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,...m-1，称线性探测再散列。
如果di取1，则每次冲突之后，向后移动1个位置.如果di取值可能为1,-1,4,-4,9,-9,16,-16,...k*k,-k*k(k<=m/2）
称二次探测再散列。如果di取值可能为伪随机数列。称伪随机探测再散列。
哈希函数建域法
假设哈希函数的值域为[0,m-1]，则设向量HashTable[0..m-1]为基本表，另外设立存储空间向量OverTable[0..v]用以存储发生冲突的记录。
B树
[1]


1970年，R.Bayer和E.mccreight提出了一种适用于外查找的树，它是一种平衡的多叉树，称为B树（或B-树、B_树）。
一棵m阶B树(balanced tree of order m)是一棵平衡的m路搜索树。它或者是空树，或者是满足下列性质的树：
1、根结点至少有两个子女；
2、每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；
3、除根结点以外的所有结点（不包括叶子结点）的度数正好是关键字总数加1，故内部子树个数 k 满足：┌m/2┐ <= k <= m ；
4、所有的叶子结点都位于同一层。
在B-树中，每个结点中关键字从小到大排列，并且当该结点的孩子是非叶子结点时，该k-1个关键字正好是k个孩子包含的关键字的值域的分划。
因为叶子结点不包含关键字，所以可以把叶子结点看成在树里实际上并不存在外部结点，指向这些外部结点的指针为空，叶子结点的数目正好等于树中所包含的关键字总个数加1。
B-树中的一个包含n个关键字，n+1个指针的结点的一般形式为： （n,P0,K1,P1,K2,P2,…,Kn,Pn）
其中，Ki为关键字，K1<K2<…<Kn, Pi 是指向包括Ki到Ki+1之间的关键字的子树的指针。
设B-树包含N个关键字，因此有N+1个叶子结点，叶子都在第I层。因为根至少有两个孩子，因此第二层至少有两个结点。除根和叶子外，其它结点至少有┌m/2┐个孩子，因此在第三层至少有2*┌m/2┐个结点，在第四层至少有2*(┌m/2┐^2)个结点，．．．，在第I层至少有2*(┌m/2┐^(l-2) )个结点，于是有：
N+1 ≥ 2*┌m/2┐I-2
考虑第L层的结点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个
即： I≤ log┌m/2┐((N+1)/2 )+2
所以，当B-树包含N个关键关键字时，B-树的最大高度为l-1（因为计算B-树高度时，叶结点所在层不计算在内）
即：log┌m/2┐((N+1)/2 )+1。
这个公式保证了B-树的查找效率是相当高的。
当在叶子结点处于第L+1层的B树中插入关键字时，被插入的关键字总是进入第L层的结点。
若在一个包含j<m-1个关键字的结点中插入一个新的关键字，则把新的关键字直接插入该结点即可；但若把一个新的关键字插入到包含m-1（m为B-树的阶）个关键字的结点中，则将引起结点的分裂。在这种情况下，要把这个结点分裂为两个，并把中间的一个关键字（中间的关键字满足：左边的小于该关键字；右边的大于该关键字；故正好可以作为双亲）拿出来插到该结点的双亲结点中去，双亲结点也可能是满的，就需要再分裂、再往上插，从而可能导致B-树可能朝着根的方向生长。
插入算法演示：插入之前如图1：
插入之前的B树

插入之后如图2：
插入之后的B树

4. B-树的删除:
当从B-树中删除一个关键字Ki时，总的分为以下两种情况：
如果该关键字所在的结点不是最下层的非叶子结点，则先需要把此关键字与它在B-树中后继对换位置，即以指针Pi所指子树中的最小关键字Y代替Ki，然后在相应的结点中删除Y。
如果该关键字所在的结点正好是最下层的非叶子结点，这种情况下，会有以下两种可能：
① 若该关键字Ki所在结点中的关键字个数不小于┌m/2┐，则可以直接从该结点中删除该关键字和相应指针即可。
② 若该关键字Ki所在结点中的关键字个数小于┌m/2┐，则直接从结点中删除关键字会导致此结点中所含关键字个数小于┌m/2┐-1 。这种情况下，需考察该结点在B树中的左或右兄弟结点，从兄弟结点中移若干个关键字到该结点中来（这也涉及它们的双亲结点中的一个关键字要作相应变化），使两个结点中所含关键字个数基本相同；但如果其兄弟结点的关键字个数也很少，刚好等于┌m/2┐-1 ，这种移动则不能进行，这种情形下，需要把删除了关键字Ki的结点、它的兄弟结点及它们双亲结点中的一个关键字合并为一个结点。
递归调用定义
递归调用就是在当前的函数中调用当前的函数并传给相应的参数，这是一个动作，这一动作是层层进行的，直到满足一般情况的的时候，才停止递归调用，开始从最后一个递归调用返回。
递归调用英文
recursive invocation
递归调用函数模型
fun(形参){
fun(参数值1) //第一次递归调用
fun(参数值2) //第二次递归调用
C语言中的递归
计算阶乘的代码
long fact(long n)
{
if(n==0||n==1) return 1L;
else return n*fact(n-1);
}
这个函数叫做fact，它自己调用自己，这个就是一个典型的递归调用，调用过程类似一个栈。
注: 主调函数又是被调函数。执行递归函数将反复调用其自身。 每调用一次就进入新的一层。
int f (int x)
{
int y;
z=f(y);
return z;
} 这个函数是一个递归函数。 但是运行该函数将无休止地调用其自身，这当然是不正确的。为了防止递归调用无终止地进行， 必须在函数内有终止递归调用的手段。常用的办法是加条件判断， 满足某种条件后就不再作递归调用，然后逐层返回。 下面举例说明递归调用的执行过程。
注:链表在某种程度上就是递归的调用.
Pascal中的递归
const
z=10000;
var
a:array[0..z+1]of integer;
n,j,i,k:longint;
begin
readln(n);write(n,'!=');
begin
a[1]:=1;
for i:=1 to n do
begin
for j:=1 to z do
a[j]:=a[j]*i;
for k:=1 to z do
begin
a[k+1]:=a[k+1]+a[k]div 10;
a[k]:=a[k]mod 10;
end;
end;
i:=z;k:=0;
repeat
if a[i]<>0 then k:=1;
i:=i-1;
until k=1;
k:=0;
for j:=i+1 downto 1 do
write(a[j]);
end;
writeln;
end.
c++语言中的递归
#include<iostream>
using namespace std;
int fac(int n)
{
int s=1;
for (int i=n;i>0;i--)
{
if (s<=s*i) s=s*i;
else
{
cout<<"over int area"<<endl;
return 0;
};
}
return s;
}
void main()
JAVA写的递归调用
public class TestDg {
public static void main(String[] args) {
System.out.println(method(5));
}
public static int method(int n) {
if (n == 1)
return 1;
else
return n * method(n - 1);
}
}
汉诺塔------软件递归调用里面最经典的一个案例
#include<stdio.h>
int c=0; /* 全局变量，搬动次数 */
void move(char x,int n,char z)
{ /* 第n个圆盘从塔座x搬到塔座z */
printf("第%i步: 将%i号盘从%c移到%c\n",++c,n,x,z);
}
void hanoi(int n,char x,char y,char z)
{ /* 将塔座x上按直径由小到大且自上而下编号为1至n的n个圆盘 */
/* 按规则搬到塔座z上。y可用作辅助塔座 */
if(n==1)
move(x,1,z); /* 将编号为1的圆盘从x移到z */
else
{
hanoi(n-1,x,z,y); /* 将x上编号为1至n-1的圆盘移到y，z作辅助塔 */
move(x,n,z); /* 将编号为n的圆盘从x移到z */
hanoi(n-1,y,x,z); /* 将y上编号为1至n-1的圆盘移到z，x作辅助塔 */
}
}
void main()
{
int n;
printf("3个塔座为a、b、c，圆盘最初在a座，借助b座移到c座。请输入圆盘数：");
scanf("%d",&n);
hanoi(n,'a','b','c');
}
递归调用调用前
一个函数的运行期间调用另一个函数时，在运行被调用函数之前，系统需要完成3件事情：
（1）将所有的实参、返回地址等信息传递给被调用函数保存；
（2）为被调用函数的局部变量分配存储区；
（3）将控制转移到被调函数的入口。
递归调用调用中
而从被调用函数返回调用函数之前，系统也应完成3件工作：
（1）保存被调函数的计算结果；
（2）释放被调函数的数据区；
（3）依照被调函数保存的返回地址将控制转移到调用函数。当有多个函数构成嵌套调用时，按照后调用先返回的原则。
递归调用递归函数特点
所有递归函数的结构都是类似的。
（1）函数要直接或间接调用自身。
（2）要有递归终止条件检查，即递归终止的条件被满足后，则不再调用自身函数。
（3）如果不满足递归终止的条件，则调用涉及递归调用的表达式。在调用函数自身时，有关终止条件的参数要发生变化，而且需向递归终止的方向变化。
递归调用总结
函数的调用原则和数据结构栈的实现是相一致。也说明函数调用是通过栈实现的。
大约公元前13世纪，腓尼基人创造了人类历史上第一批字母文字，共22个字母（无元音）。这是腓尼基人对人类文化的伟大贡献。腓尼基字母是世界字母文字的开端。在西方，它派生出古希腊字母，后者又发展为拉丁字母和斯拉夫字母。而希腊字母和拉丁字母是所有西方国家字母的基础。在东方，它派生出阿拉美亚字母，由此又演化出印度、阿拉伯、希伯来、波斯等民族字母。中国的维吾尔、蒙古、满文字母也是由此演化而来。
腓尼基字母是腓尼基人用以书写他们的腓尼基语。腓尼基语（Phoenician）是一种闪米特人语言。腓尼基铭文曾在考古遗址中发现，包括一些腓尼基城市及地中海周边的殖民地，例如比布鲁斯(在现今的黎巴嫩) 和迦太亚(在现今的突尼斯)。原本的原始西奈字母是象形文字，然而到腓尼基字母时代，有些字的意思已改变了。由于字母本来是刻在石上，所以多数字母都是直线和方形的，就像古日耳曼字母一样。虽然之后有多一些较曲线的版本，成了罗马时代的北非新迦太基字母。 腓尼基语通常由右到左写，而有些文字使用了左右往复书写法(boustrophedon, 又称耕地写法)。 部分字母有另一种书写表达方法， 例如 taw 可以写成似一个 '+' 号而不用 'x' 号， heth 可以有两条横线穿过。拉丁字母 X 来自希腊字母 Χ 的发音，而不是直接由 Ξ (samekh-inspired 字母) 。但是，希腊字母 Χ 可能来自腓尼基字母 samekh 的二次变种。
据考证，腓尼基字母主要是依据古埃及的图画文字制定的。在古埃及，“A”是表示“牛头”的图画；“B”是表示“家”或“院子”的图画；“C”和“G”是表示“曲尺”的图画；“D”是表示“门扇”的图画；“E”是表示一个“举起双手叫喊的人”的图画；“F”、“V”、“Y”是表示“棍棒”或“支棒”的图画；“H”是表示“一节麻丝卷”的图画；“I”是表示“展开的手”的图画；“K”是表示“手掌”的图画；“M”是表示“水”的图画；“N”是表示“蛇”的图画；“O”是表示“眼睛”的图画；“P”是表示“嘴巴”的图画；“Q”是表示“绳圈”的图画；“R”是表示“人头”的图画；“S”和“X”是表示“丘陵地”或“鱼”的图画；“T”是表示“竖十字型”的图画；“Z”是表示“撬”或“箭”的图画。公元前2世纪时，拉丁字母已包括了这23个字母。后来，为了雕刻和手写的方便，并为了使元音的“V”和辅音的“V”相区别，便把原来的“V”的下方改成圆形而定为元音“U”；又把两个“V”连起来变出了一个做辅音用的“W”，这个“W”的出现已是11世纪的事了。后来人们又把“I”稍稍变化而另创出一个辅音字母“J”。这样，原来的23个字母再加上“U”、“W”、“J”三个字母，就构成了26个字母的字母表了。中世纪时，拉丁字母基本定型，后世西方文字（当然也包括英文）都是由它演变而来。
1. A a
2. B b
3. C c
4. D d
5. E e
6. F f
7. G g
8. H h
9. I i
10. J j
11. K k
12. L l
13. M m
14. N n
15. O o
16. P p
17. Q q
18. R r
19. S s
20. T t
21. U u
22. V v
23. W w
24. X x
25. Y y
26. Z z
字母表声母表
b p m f d t n l g k h j q x
玻 坡 摸 佛 得 特 呢 勒 哥 科 喝 基 欺 希
zh ch sh r z c s y w
知 蚩 诗 日 资 雌 思 一 屋
字母表韵母表
a o e i u ü（单韵母）
啊 哦 鹅 衣 乌 迂
ai ei ui ao ou iu ie üe er（复韵母）
挨 诶 危 凹 欧 优 耶 约 而
an en in un ün（前鼻韵母）
安 恩 因 温 晕
ang eng ing ong（后鼻韵母）
肮 鞥 英 轰的韵母
字母表声母
b p m f d t n l
g k h j q x
zh ch sh r z c s
y w
字母表韵母
单韵母：a o e i u ü
复韵母：ai ei ui ao ou iu ie üe er
前鼻韵母：an en in un ün
后鼻韵母：ang eng ing ong
整体认读音节：zhi chi shi ri zi ci si yi wu yu ye yue yuan yin yun ying
字母表五声表
第一声{阴平}
第二声{阳平}
第三声{上声}
第四声{去声}
第五声{轻声}
计算机编译原理中定义，“字母表”是指元素的非空有限集合,由于字母表中的元素称为符号,因此也叫做符号集,不同的语言可以有不同的字母表。
国家:柬埔寨字母个数:74
那么世界上最少字母的语言是哪一种？
答案是所罗门群岛的本土语言Rotokas，只有11个字母，是最短的字母表。
中国的汉字没有字母，但汉字个数有5000以上
[1] 
。
顺序存储是指用一段地址连续的存储单元存储相邻数据元素，或把逻辑上相邻的结点存储在物理位置上相邻的存储单元中，结点之间的逻辑关系由存储单元的邻接关系来体现（逻辑与物理统一），要求内存中可用的存储单元的地址必须是连续的。优点：存储密度大，存储空间利用概率高。缺点：插入或删除元素时不方便。与顺序存储相对应是链接存储。这种方法主要用于线性的数据结构。对非线性结构也可以采用局部线性化的方法实现顺序存储。例如，在树形结构中可以把结点按某种规则排成序列，用顺序存储方法把结点内部的信息稠密地存放在一起，而对结点之间的关系采用其他的存放方法。
顺序存储主要使用数组，采用顺序存储的优点：可以随机访问数组中的元素，即通过下标去访问数组的元素；其缺点主要有二：其一，由于C语言中，数组一旦被声明，其长度即该结构占用的存储空间是固定的，申请的空间过大，造成空间的浪费同时也为维护该结构造成困难，申请过小，在程序运行过程中，有可能会造成结构空间不足，导致程序故障；其二，在插入，删除数据时，通常会导致大量数据的移动，在等概率的前提下，平均需要移动整个结构中一半的元素，如果元素个体比较复杂问题将更为明显
[2] 
。
数据元素之间的关系有两种不同的表示方法：顺序映象和非顺序映象，并由此得到两种不同的存储结构：顺序存储结构和链式存储结构。数据的存储结构，也称为数据的物理结构，是数据的逻辑结构在计算机中的实现。
链接存储方法它不要求逻辑上相邻的结点在物理位置上亦相邻，结点间的逻辑关系是由附加的指针字段表示的。由此得到的存储表示称为链式存储结构，链式存储结构通常借助于程序设计语言中的指针类型来实现。数据的链式存储结构可用链接表来表示。
其中data表示值域，用来存储节点的数值部分。P1, P2, …Pn(n≥1)均为指针域，每个指针域为其对应的后继元素或前驱元素所在结点（以后简称为后继结点或前驱结点）的存储位置。通过结点的指针域(又称为链域)可以访问到对应的后继结点或前驱结点，若一个结点中的某个指针域不需要指向其他结点，则令它的值为空（NULL）。在数据的顺序存储中，由于每个元素的存储位置都可以通过简单计算得到，所以访问元素的时间都相同；而在数据的链接存储中，由于每个元素的存储位置保存在它的前驱或后继结点中，所以只有当访问到其前驱结点或后继结点后才能够按指针访问到，访问任一元素的时间与该元素结点在链式存储结构中的位置有关。
顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中
[3] 
。
/* 线性表的动态分配顺序存储结构 */
#define LIST_INIT_SIZE 10 /* 线性表存储空间的初始分配量 */
#define LIST_INCREMENT 2 /* 线性表存储空间的分配增量 */
typedef struct
{
  ElemType *elem; /* 存储空间基址 */
  int length; /* 当前长度 */
  int listsize; /* 当前分配的存储容量(以sizeof(ElemType)为单位) */
}SqList;

/* 顺序表示的线性表的基本操作(12个) */
void InitList(SqList *L) /* 算法2.3 */
{ /* 操作结果：构造一个空的顺序线性表L */
  L->elem=malloc(LIST_INIT_SIZE*sizeof(ElemType));
  if(!L->elem)
    exit(OVERFLOW); /* 存储分配失败 */
  L->length=0; /* 空表长度为0 */
  L->listsize=LIST_INIT_SIZE; /* 初始存储容量 */
}

void DestroyList(SqList *L)
{ /* 初始条件：顺序线性表L已存在。操作结果：销毁顺序线性表L */
  free(L->elem);
  L->elem=NULL;
  L->length=0;
  L->listsize=0;
}

void ClearList(SqList *L)
{ /* 初始条件：顺序线性表L已存在。操作结果：将L重置为空表 */
  L->length=0;
}

Status ListEmpty(SqList L)
{ /* 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE */
  if(L.length==0)
    return TRUE;
  else
    return FALSE;
}

int ListLength(SqList L)
{ /* 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数 */
  return L.length;
}

Status GetElem(SqList L,int i,ElemType *e)
{ /* 初始条件：顺序线性表L已存在,1≤i≤ListLength(L)。操作结果：用e返回L中第i个数据元素的值 */
  if(i<1||i>L.length)
    return ERROR;
  *e=*(L.elem+i-1);
  return OK;
}

int LocateElem(SqList L,ElemType e,Status(*compare)(ElemType,ElemType))
{ /* 初始条件：顺序线性表L已存在，compare()是数据元素判定函数(满足为1，否则为0) */
  /* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。 */
  /*           若这样的数据元素不存在，则返回值为0。 */
  ElemType *p;
  int i=1; /* i的初值为第1个元素的位序 */
  p=L.elem; /* p的初值为第1个元素的存储位置 */
  while(i<=L.length&&!compare(*p++,e))
    ++i;
  if(i<=L.length)
    return i;
  else
    return 0;
}

Status PriorElem(SqList L,ElemType cur_e,ElemType *pre_e)
{ /* 初始条件：顺序线性表L已存在 */
  /* 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， */
  /*           否则操作失败，pre_e无定义 */
  int i=2;
  ElemType *p=L.elem+1;
  while(i<=L.length&&*p!=cur_e)
  {
    p++;
    i++;
  }
  if(i>L.length)
    return INFEASIBLE; /* 操作失败 */
  else
  {
    *pre_e=*--p;
    return OK;
  }
}

Status NextElem(SqList L,ElemType cur_e,ElemType *next_e)
{ /* 初始条件：顺序线性表L已存在 */
  /* 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继， */
  /*           否则操作失败，next_e无定义 */
  int i=1;
  ElemType *p=L.elem;
  while(i<L.length&&*p!=cur_e)
  {
    i++;
    p++;
  }
  if(i==L.length)
    return INFEASIBLE; /* 操作失败 */
  else
  {
    *next_e=*++p;
    return OK;
  }
}

Status ListInsert(SqList *L,int i,ElemType e) 
{ /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)+1 */
  /* 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1 */
  ElemType *newbase,*q,*p;
  if(i<1||i>L->length+1) /* i值不合法 */
    return ERROR;
  if(L->length>=L->listsize) /* 当前存储空间已满,增加分配 */
  {
    newbase=realloc(L->elem,(L->listsize+LIST_INCREMENT)*sizeof(ElemType));
    if(!newbase)
      exit(OVERFLOW); /* 存储分配失败 */
    L->elem=newbase; /* 新基址 */
    L->listsize+=LIST_INCREMENT; /* 增加存储容量 */
  }
  q=L->elem+i-1; /* q为插入位置 */
  for(p=L->elem+L->length-1;p>=q;--p) /* 插入位置及之后的元素右移 */
    *(p+1)=*p;
  *q=e; /* 插入e */
  ++L->length; /* 表长增1 */
  return OK;
}

Status ListDelete(SqList *L,int i,ElemType *e) 
{ /* 初始条件：顺序线性表L已存在，1≤i≤ListLength(L) */
  /* 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1 */
  ElemType *p,*q;
  if(i<1||i>L->length) /* i值不合法 */
    return ERROR;
  p=L->elem+i-1; /* p为被删除元素的位置 */
  *e=*p; /* 被删除元素的值赋给e */
  q=L->elem+L->length-1; /* 表尾元素的位置 */
  for(++p;p<=q;++p) /* 被删除元素之后的元素左移 */
    *(p-1)=*p;
  L->length--; /* 表长减1 */
  return OK;
}

void ListTraverse(SqList L,void(*vi)(ElemType*))
{ /* 初始条件：顺序线性表L已存在 */
  /* 操作结果：依次对L的每个数据元素调用函数vi() */
  /*           vi()的形参加'&'，表明可通过调用vi()改变元素的值 */
  ElemType *p;
  int i;
  p=L.elem;
  for(i=1;i<=L.length;i++)
    vi(p++);
  printf("\n");
}
在计算机数据处理中，哈夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。
例如，在英文中，e的出现机率最高，而z的出现概率则最低。当利用哈夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。
哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和，记为WPL=（W1*L1+W2*L2+W3*L3+...+Wn*Ln），N个权值Wi（i=1,2,...n）构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li（i=1,2,...n）。可以证明哈夫曼树的WPL是最小的。
1951年，哈夫曼在麻省理工学院（MIT）攻读博士学位，他和修读信息论课程的同学得选择是完成学期报告还是期末考试。导师罗伯特·法诺（Robert Fano）出的学期报告题目是：查找最有效的二进制编码。由于无法证明哪个已有编码是最有效的，哈夫曼放弃对已有编码的研究，转向新的探索，最终发现了基于有序频率二叉树编码的想法，并很快证明了这个方法是最有效的。哈夫曼使用自底向上的方法构建二叉树，避免了次优算法香农-范诺编码（Shannon–Fano coding）的最大弊端──自顶向下构建树。
1952年，于论文《一种构建极小多余编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）中发表了这个编码方法。
1、哈夫曼编码
在数据通信中，需要将传送的文字转换成二进制的字符串，用0，1码的不同排列来表示字符。例如，需传送的报文为“AFTER DATA EAR ARE ART AREA”，这里用到的字符集为“A，E，R，T，F，D”，各字母出现的次数为{8，4，5，3，1，1}。现要求为这些字母设计编码。要区别6个字母，最简单的二进制编码方式是等长编码，固定采用3位二进制，可分别用000、001、010、011、100、101对“A，E，R，T，F，D”进行编码发送，当对方接收报文时再按照三位一分进行译码。显然编码的长度取决报文中不同字符的个数。若报文中可能出现26个不同字符，则固定编码长度为5。然而，传送报文时总是希望总长度尽可能短。在实际应用中，各个字符的出现频度或使用次数是不相同的，如A、B、C的使用频率远远高于X、Y、Z，自然会想到设计编码时，让使用频率高的用短码，使用频率低的用长码，以优化整个报文编码。
为使不等长编码为前缀编码(即要求一个字符的编码不能是另一个字符编码的前缀)，可用字符集中的每个字符作为叶子结点生成一棵编码二叉树，为了获得传送报文的最短长度，可将每个字符的出现频率作为字符结点的权值赋予该结点上，显然字使用频率越小权值越小，权值越小叶子就越靠下，于是频率小编码长，频率高编码短，这样就保证了此树的最小带权路径长度效果上就是传送报文的最短长度。因此，求传送报文的最短长度问题转化为求由字符集中的所有字符作为叶子结点，由字符出现频率作为其权值所产生的哈夫曼树的问题。利用哈夫曼树来设计二进制的前缀编码，既满足前缀编码的条件，又保证报文编码总长最短。




哈夫曼树(4张)
哈夫曼静态编码：它对需要编码的数据进行两遍扫描：第一遍统计原数据中各字符出现的频率，利用得到的频率值创建哈夫曼树，并必须把树的信息保存起来，即把字符0-255(2^8=256)的频率值以2-4BYTES的长度顺序存储起来，（用4Bytes的长度存储频率值，频率值的表示范围为0--2^32-1，这已足够表示大文件中字符出现的频率了）以便解压时创建同样的哈夫曼树进行解压；第二遍则根据第一遍扫描得到的哈夫曼树进行编码，并把编码后得到的码字存储起来。
哈夫曼动态编码：动态哈夫曼编码使用一棵动态变化的哈夫曼树，对第t+1个字符的编码是根据原始数据中前t个字符得到的哈夫曼树来进行的，编码和解码使用相同的初始哈夫曼树，每处理完一个字符，编码和解码使用相同的方法修改哈夫曼树，所以没有必要为解码而保存哈夫曼树的信息。编码和解码一个字符所需的时间与该字符的编码长度成正比，所以动态哈夫曼编码可实时进行。
2、哈夫曼译码
在通信中，若将字符用哈夫曼编码形式发送出去，对方接收到编码后，将编码还原成字符的过程，称为哈夫曼译码。
哈夫曼树又称为最优树.
1、路径和路径长度
在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。
2、结点的权及带权路径长度
若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。




哈夫曼树(3张)
3、树的带权路径长度
树的带权路径长度规定为所有叶子结点的带权路径长度之和，记为WPL。
哈夫曼树的构造

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：
(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；
(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；
(3)从森林中删除选取的两棵树，并将新树加入森林；
(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。
哈夫曼树也可以是k叉的，只是在构造k叉哈夫曼树时需要先进行一些调整。构造哈夫曼树的思想是每次选k个权重最小的元素来合成一个新的元素，该元素权重为k个元素权重之和。但是当k大于2时，按照这




哈夫曼树(2张)



个步骤做下去可能到最后剩下的元素少于k个。解决这个问题的办法是假设已经有了一棵哈夫曼树(且为一棵满k叉树)，则可以计算出其叶节点数目为(k-1)nk+1,式子中的nk表示子节点数目为k的节点数目。于是对给定的n个权值构造k叉哈夫曼树时,可以先考虑增加一些权值为0的叶子节点，使得叶子节点总数为(k-1)nk+1这种形式,然后再按照哈夫曼树的方法进行构造即可。
哈夫曼树数据压缩
实现哈夫曼编码的方式主要是创建一个二叉树和其节点。这些树的节点可以存储在数组里，数组的大小为符号（symbols）数的大小n，而节点分别是终端节点（叶节点）与非终端节点（内部节点）。
一开始，所有的节点都是终端节点，节点内有三个字段：
1.符号（Symbol）
2.权重（Weight、Probabilities、Frequency）
3.指向父节点的链接（Link to its parent node）
而非终端节点内有四个字段：
1.权重（Weight、Probabilities、Frequency）
2.指向两个子节点的链接（Links to two child node）
3.指向父节点的链接（Link to its parent node）
基本上，我们用'0'与'1'分别代表指向左子节点与右子节点，最后为完成的二叉树共有n个终端节点与n-1个非终端节点，去除了不必要的符号并产生最佳的编码长度。
过程中，每个终端节点都包含着一个权重（Weight、Probabilities、Frequency），两两终端节点结合会产生一个新节点，新节点的权重是由两个权重最小的终端节点权重之总和，并持续进行此过程直到只剩下一个节点为止。
实现哈夫曼树的方式有很多种，可以使用优先队列（Priority Queue）简单达成这个过程，给与权重较低的符号较高的优先级（Priority），算法如下：
⒈把n个终端节点加入优先队列，则n个节点都有一个优先权Pi，1 ≤ i ≤ n
⒉如果队列内的节点数>1，则：
⑴从队列中移除两个最小的Pi节点，即连续做两次remove（min（Pi）, Priority_Queue)
⑵产生一个新节点，此节点为（1）之移除节点之父节点，而此节点的权重值为（1）两节点之权重和
⑶把（2）产生之节点加入优先队列中
⒊最后在优先队列里的点为树的根节点（root）
而此算法的时间复杂度（Time Complexity）为O（n log n）；因为有n个终端节点，所以树总共有2n-1个节点，使用优先队列每个循环须O（log n）。
此外，有一个更快的方式使时间复杂度降至线性时间（Linear Time）O（n），就是使用两个队列（Queue）创件哈夫曼树。第一个队列用来存储n个符号（即n个终端节点）的权重，第二个队列用来存储两两权重的合（即非终端节点）。此法可保证第二个队列的前端（Front）权重永远都是最小值，且方法如下：
⒈把n个终端节点加入第一个队列（依照权重大小排列，最小在前端）
⒉如果队列内的节点数>1，则：
⑴从队列前端移除两个最低权重的节点
⑵将（1）中移除的两个节点权重相加合成一个新节点
⑶加入第二个队列
⒊最后在第一个队列的节点为根节点
虽然使用此方法比使用优先队列的时间复杂度还低，但是注意此法的第1项，节点必须依照权重大小加入队列中，如果节点加入顺序不按大小，则需要经过排序，则至少花了O（n log n）的时间复杂度计算。
但是在不同的状况考量下，时间复杂度并非是最重要的，如果我们考虑英文字母的出现频率，变量n就是英文字母的26个字母，则使用哪一种算法时间复杂度都不会影响很大，因为n不是一笔庞大的数字。
哈夫曼树数据解压缩
简单来说，哈夫曼码树的解压缩就是将得到的前置码（Prefix Huffman code）转换回符号，通常借由树的追踪（Traversal），将接收到的比特串（Bits stream）一步一步还原。但是要追踪树之前，必须要先重建哈夫曼树；某些情况下，如果每个符号的权重可以被事先预测，那么哈夫曼树就可以预先重建，并且存储并重复使用，否则，发送端必须预先发送哈夫曼树的相关信息给接收端
[1] 
。
最简单的方式，就是预先统计各符号的权重并加入至压缩之比特串，但是此法的运算量花费相当大，并不适合实际的应用。若是使用Canonical encoding，则可精准得知树重建的数据量只占B2^B比特（其中B为每个符号的比特数（bits））。如果简单将接收到的比特串一个比特一个比特的重建，例如：'0'表示父节点，'1'表示终端节点，若每次读取到1时，下8个比特则会被解读是终端节点（假设数据为8-bit字母），则哈夫曼树则可被重建，以此方法，数据量的大小可能为2~320字节不等。虽然还有很多方法可以重建哈夫曼树，但因为压缩的数据串包含"traling bits"，所以还原时一定要考虑何时停止，不要还原到错误的值，如在数据压缩时时加上每笔数据的长度等。
当有100个位子，有白色占60%、咖啡色占20%，蓝色和红色各占10%，则该如何分配才能最优化此座位?
(a)direct: 　　假设结果为：白色为00、咖啡色01，蓝色10和红色11个bits则结果为:100*2 = 200bits　　(b)huffman code: (must be satisfy the following conditions，if not change the node)　　(1) 所有码皆在Coding Tree的端点，再下去没有分枝(满足一致解码跟瞬间解码)　　(2) 机率越大，code length越短；机率越小，code length越长　　(3) 假设



是第L层的node，



是第L+1层的node
则



必须满足
假设结果为：白色占0、咖啡色10，蓝色110和红色111个bits　　则结果为:60*1+20*2+20*3=160bits
相互比较两个结果huffman code 整整少了40bits的存储空间。
【词目】查找
【拼音】cházhǎo
【英译】[search for;scour]
【释义】彻底考查或搜寻
【示例】查找文件。
[1]
在计算机科学中定义为：在一些（有序的/无序的）数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程叫做查找。也就是根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素。
Windows 日记本的一个功能，可用于搜索便笺文件。




计算机中的查找(21张)
英文词组：look up
网页和文件中使用ctrl+f弹出查找框 输入要查找的文字即可找到查找项
查找顺序查找
⒈顺序查找的思想是：
将查找值顺序逐个与结点值进行比较，相等即为查找成功，否则查找失败.
程序（Pascal）如下：
program sxcz;
const n=7;
type
arr=array[1..n] of integer;
var x1,i:integer;
a:arr;
b:boolean;
place:integer;
procedure search(r:arr;m,x:integer; var found:boolean;var p:integer);
begin
p:=1;found:=false;
while(p<=m) and not found do
if r[p]=x then found:=true else p:=p+1;
end;
begin
write('Enter array:');
for i:=1 to n do read(a[i]);
writeln;
write('Enter search data:');
read(x1）；
search(a,n,x1,b,place);
if b then begin writeln('yes');writeln('Place of',x1:5,'is:',place); end
else writeln('no');
end.
查找二分查找
⒈二分查找的基本思想：首先将结点按关键字排序，其次将查找值与中间位置的值比较，相等，查找成功；不等，则中间数据大于或小于查找值，无论怎样查找将在一半的数据中查找。
⒉例：输入序列数据查找指定值.
程序（Pascal）：
program sxcz;
const n=7;
type
arr=array[1..n] of integer;
var x1,i:integer;
a:arr;
place:integer;
procedure paixv(var r:arr;m:integer);
var k,j,i,t:integer;
begin
k:=m;
while k>0 do
begin
j:=k-1;k:=0;
for i:=1 to j do
if r[i]>r[i+1] then
begin t:=r[i];a[i]:=r[i+1];r[i+1]:=t;k:=i;end;
end;
end;
procedure search(r:arr;m,x:integer; var p:integer);
var low,high,mid:integer;
begin
p:=0;low:=1;high:=m;
while low<=high do
begin
mid:=(low+high) div 2;
if x>r[mid] then low:=mid+1 else
if x<r[mid] then high:=mid-1 else
begin p:=mid;exit;end;
end;
end;
begin
write('Enter array:');
for i:=1 to n do read(a[i]);
writeln;
write('Enter search data:');
read(x1）；
paixv(a,n);
search(a,n,x1,place);
if place<>0 then writeln('yes') else writeln('no');
end.
查找二叉排序树查找
因为二叉排序树的左子树若不为空则左子树的所有结点的值均小于它的根结点的值，而右子树若不为空，则右子树的所有结点的值均不小大于它的根结点的值，根据这个性质查找算法如下（Pascal）：
program pxtree;
const
a:array[1..8] of integer=（10,18,3,8,12,2,7,3）；
type point=^nod;
nod=record
w:integer;
right,left:point ;
end;
var root,first:point;k:boolean;i,x:integer;
procedure maketr(d:integer;var p:point);
begin
if p=nil then
begin
new(p);
with p^ do begin w:=d;right:=nil;left:=nil end;
if k then begin root:=p; k:=false end;
end
else with p^ do if d>=w then maketr(d,right) else maketr(d,left);
end;
function searchtr(x:integer;p:point):boolean;
begin
if p=nil then searchtr:=false
else if x=p^.w then searchtr:=true
else if x<p^.w then searchtr:=searchtr(x,p^.left)
else searchtr:=searchtr(x,p^.right);
end;
begin
first:=nil;k:=true;
for i:=1 to 8 do maketr(a[i],first);
write('want find data x:');read(x);
if searchtr(x,first) then writeln('yes') else writeln('No');
end.
查找哈希（Hash）表
以上讲的查找方法基于比较的，查找效率依赖比较次数，其实理想的查找希望不经比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系f，这样查找k时，只要根据这个对应关系f找到给定值k的像f(k）。这种对应关系f叫哈希（hash）函数。按这种思想建立的表叫哈希表（也叫散列表）。哈希表存取方便但存储时容易冲突（collision）：即不同的关键字可以对应同一哈希地址。如何确定哈希函数和解决冲突是关键。
⒈哈希函数的构造方法
直接定址法：H(k)=k 或H(k)=a*k+b（线形函数）
如：人口数字统计表
地址
1
2
3
...
100
年龄
1
2
3
...
100
人数
67
3533
244
...
4
数字分析法：取关键字的若干数位组成哈希地址
如：关键字如下：若哈希表长为100则可取中间两位10进制数作为哈希地址。
81346532
81372242
81387422
81301367
81322817
81338967
81354157
81368537
平方取中法：关键字平方后取中间几位数组成哈希地址
折叠法：将关键数字分割成位数相同的几部分（最后一部分的位数可以不同）然后取几部分的叠加和（舍去进位）作为哈希地址。
除留余数法：取关键字被某个不大于表长m的数p除后所得的余数为哈希地址。
H(k)=k mod p p<=m
随机数法：H(k)=rondom(k）。
⒉处理冲突的方法
假设地址集为0..n-1，由关键字得到的哈希地址为j(0<=j<=n-1）的位置已存有记录，处理冲突就是为该关键字的记录找到另一个"空"的哈希地址。在处理中可能得到一个地址序列Hi i=1，2，...k
0<=Hi<=n-1），即在处理冲突时若得到的另一个哈希地址H1仍发生冲突，再求下一地址H2，若仍冲突，再求H3...。怎样得到Hi呢？
开放定址法：Hi=(H(k)+di) mod m （H(k）为哈希函数；m为哈希表长；di为增量序列）
当di=1，2，3，... m-1 时叫线性探测再散列。
当di=1，-1，2，-2，3，-3，...,k,-k时叫二次探测再散列。
当di=random（m）时叫伪随机探测序列。
例：长度为11的哈希表关键字分别为17，60，29，哈希函数为H(k)=k mod 11，第四个记录的关键字为38，分别按上述方法添入哈希表的地址为8，4，3（随机数=9）。
再哈希法：Hi=RHi(key) i=1,2,...,k，其中RHi均为不同的哈希函数。
链地址法：这种方法很象基数排序，相同的地址的关键字值均链入对应的链表中。
建立公益区法：另设一个溢出表，不管得到的哈希地址如何，一旦发生冲突，都填入溢出表。
⒊哈希表的查找
例：如下一组关键字按哈希函数H(k)=k mod 13和线性探测处理冲突所得的哈希表a[0..15]:
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
14
01
68
27
55
19
20
84
79
23
11
10
当给定值k=84，则首先和a[6]比在依次和a[7],a[8]比结果a[8]=84查找成功。
当给定值k=38，则首先和a[12]比，再和a[13]比，由于a[13]没有，查找不成功，表中不存在关键字等于38的记录。
查找查找第k小元素
查找第k小元素即在n个元素中（未排序）找到第k小的元素。方法同快速排序，采用递归方式。
程序如下（Pascal）：
program kspv;
const n=7;
type
arr=array[1..n] of integer;
var
b:arr;
i,k:integer;
function p(s,t:integer):integer;
var i,j,t1,x:integer;
begin
i:=s;j:=t;x:=b[i];
repeat
while (b[j]>=x) and (j>i) do j:=j-1;
if j>i then begin t1:=b[i]; b[i]:=b[j];b[j]:=t1;end;
while (b[i]<=x) and (i<j) do i:=i+1;
if i<j then begin t1:=b[j];b[j]:=b[i];b[i]:=t1; end
until i=j;
b[i]:=x;
p:=i;
end;
function find(s,t,k:integer):integer;
var p1,q:integer;
begin
if s=t then find:=b[s] else
begin
p1:=p(s,t);
q:=p1-s+1;
if k<=q then find:=find(s,p1,k) else find:=find(p1+1,t,k-q);
end;
end;
begin
write('input data:');
for i:=1 to n do read(b[i]);readln;
write('input k:');read(k);
write('output data:');
writeln('kthsmall:=',find（1,n,k));
end.
articulation point;articulare;
在某图中，若删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。一个没有关节点的连通图称为重连通图。
在重连通图中，任意一对顶点之间至少存在两条路径，则再删去某个顶点即相关各边后也不破坏图的连通性。若在图的连通图上删去k个节点才能破坏图的连通性，则称K为此图的连通度。
他们常常在通信网络的图或航空网中应用，K越大，系统越稳定，反之，战争中若要摧毁敌方的运输线，只须破坏其运输网中的关节点即可。
利用深度优先搜索便可以求的图的关节点，本由此可判别图是否重连通。
从任一点出发深度优先遍历得到优先生成树，对于树中任一顶点V而言，其孩子节点为邻接点。由深度优先生成树可得出两类关节点的特性：
（1）若生成树的根有两棵或两棵以上的子树，则此根顶点必为关节点。因为图中不存在连接不同子树顶点的边，若删除此节点，则树便成为森林。
（2）若生成树中某个非叶子节点V，其某棵子树与V的祖先节点无连接，则V为关节点。因为删去v，则其子树和图的其它部分被分割开来
关节点定义
low[v] 设对连通图G=（V,E）进行先深搜索的先深编号为dfn[v]，产生的先深生成树为S=（V,T），B是回退边之集。对每个顶点v，low[v]定义如下
low[v]=Min{dfn[v],Min{low[w]|w是v的一个子女}，Min{dfn[x]|（v，x）是一条回边}}//dfn数组记录顶点的深度优先数
算法： 求无向图的双连通分量
输入：连通的无向图G=( V, E )。L[v]表示关于v的邻接表
输出：G的所有双连通分量，每个连通分量由一序列的边组成。
关节点算法要点
1.计算先深编号：对图进行先深搜索，计算每个结点v的先深编号dnf[v]，形成先深生成树S=（V,T）。
2.计算low[v]：在先深生成树上按后根顺序进行计算每个顶点v的 low[v]， low[v]取下述三个结点中的最小者：
(1) dfn[v]；
(2) dfn[w]，凡是有回退边（v,w）的任何结点w；
(3) low[y]，对v的任何儿子y。
3.求关节点：
(1)树根是关节点，当且仅当它有两个或两个以上的儿子（第一类关节点）；
(2)非树根结点v是关节点当且仅当v有某个儿子y，使low[y]≥dnf[v]（第二类关节点）。
求双连通分量的算法――同先深搜索算法（略）
矩阵乘法算法的演进。
施特拉森算法在1969年由Volker Strassen提出来，是第一个时间复杂度低于{\displaystyle O(n^{3})}的矩阵乘法算法。由于算法简单理解，且为第一个被提出来的特性，常被算法教材拿来当作主定理（英语：Master theorem）计算时间复杂度的例子。
另外，因为施特拉森算法证明了矩阵乘法存在时间复杂度低于{\displaystyle O(n^{3})}的算法，使得更多学者投入研究，寻找更快的算法。
[1]
施特拉森算法定义
设A、B为域F上的方矩阵。求两者的积{\displaystyle C}。一般矩阵可以填0的方法计算令它成为



矩阵。

施特拉森算法计算
将A,B,C分成相等大小的方块矩阵：

即

于是




引入新矩阵







可得：




其中



的计算也是使用施特拉森算法求得。
一般矩阵乘法的时间复杂度为



，施特拉森算法因为只有每次的分治法（英语：Divide and conquer algorithm）只有七个矩阵乘法运算，所以依照主定理（英语：Master theorem）可以得出时间复杂度为



。但Strassen算法的数值稳定性较差。
现时时间复杂度最低的矩阵乘法算法是Coppersmith-Winograd方法的一种扩展方法，其算法复杂度为



)。
[1]
并行算法是并行计算中非常重要的问题。并法研究应该确立一个“理论－设计－实现－应用”的系统方法，形成一个完善的 “架构—算法—编程” 方法论，这样才能保证并行算法不断发展并变得更加实用。
简单的说，算法就是求解问题的方法和步骤。并行算法，就是在并行机上用很多个处理器联合求解问题的方法和步骤。实际上，在自然界中并行是客观存在的普遍现象，关键问题在于能不能很好的利用。由于人们的思维能力以及思考问题的方法对并行不太习惯，且并行算法理论不成熟，所以总是出现了需求再来研究算法，不具有导向性，同时实现并行算法的并行程序性能较差，往往满足不了人们的需求。并行算法的研究历史可简单归纳为：上世纪70到80年代，并行算法研究处于高潮；到上世纪90年代跌入低谷；目前，又处于研究的热点阶段。现在，人们已经可以自己搭建PC cluster，利用学习到的理论知识来解决实际问题，不再是纸上谈兵，这也为我们提供了新的机遇和挑战
[1] 
。
相对于串行计算，并行计算可以划分成时间并行和空间并行。时间并行即流水线技术，空间并行使用多个处理器执行并发计算，当前研究的主要是空间的并行问题。以程序和算法设计人员的角度看，并行计算又可分为数据并行和任务并行。数据并行把大的任务化解成若干个相同的子任务，处理起来比任务并行简单。
空间上的并行导致两类并行机的产生，按照麦克·弗莱因（Michael Flynn）的说法分为单指令流多数据流（SIMD）和多指令流多数据流（MIMD），而常用的串行机也称为单指令流单数据流（SISD）。MIMD类的机器又可分为常见的五类：并行向量处理机（PVP）、对称多处理机（SMP）、大规模并行处理机（MPP）、工作站机群（COW）、分布式共享存储处理机（DSM）。
并行计算机有以下五种访存模型：均匀访存模型（UMA）、非均匀访存模型（NUMA）、全高速缓存访存模型（COMA）、一致性高速缓存非均匀存储访问模型（CC-NUMA）和非远程存储访问模型（NORMA）。
不像串行计算机那样，全世界基本上都在使用冯·诺伊曼的计算模型；并行计算机没有一个统一的计算模型。不过，人们已经提出了几种有价值的参考模型：PRAM模型，BSP模型，LogP模型，C^3模型等
[2] 
。
（1）并行计算模型 并行算法作为一门学科，首先研究的是并行计算模型。并行计算模型是算法设计者与体系结构研究者之间的一个桥梁，是并行算法设计和分析的基础。它屏蔽了并行机之间的差异，从并行机中抽取若干个能反映计算特性的可计算或可测量的参数，并按照模型所定义的计算行为构造成本函数，以此进行算法的复杂度分析。
并行计算模型的第一代是共享存储模型，如SIMD-SM和MIMD-SM的一些计算模型，模型参数主要是CPU的单位计算时间，这样科学家可以忽略一些细节，集中精力设计算法。第二代是分布存储模型。在这个阶段，人们逐渐意识到对并行计算机性能带来影响的不仅仅是CPU，还有通信。因此如何把不同的通信性能抽象成模型参数，是这个阶段的研究重点。第三代是分布共享存储模型，也是我们目前研究所处的阶段。随着网络技术的发展，通信延迟固然还有影响，但对并行带来的影响不再像当年那样重要，注重计算系统的多层次存储特性的影响。
（2）设计技术并行算法研究的第二部分是并行算法的设计技术。虽然并行算法研究还不是太成熟，但并行算法的设计依然是有章可循的，例如划分法、分治法、平衡树法、倍增法/指针跳跃法、流水线法等都是常用的设计并行算法的方法。另外人们还可以根据问题的特性来选择适合的设计方法。
（3）并行算法分为多机并行和多线程并行。多机并行，如MPI技术；多线程并行，如OpenMP技术。
以上是并行算法的常规研究内容
[3] 
。
随着时代的进步，我们需要不断调整研究方向。目前并行算法研究的新走向是：并行算法研究内容不断拓宽，并行计算被纳入研究范畴；与广大用户领域结合，注重应用，强调走到用户中去，为用户解决问题；重视新的、非常规计算模式，如神经计算、量子计算等，这些模式能够解决某类特定问题，有其自身的优越性。
无向图G=<V,E>,其中：
1.V是非空集合，称为顶点集。
2.E是V中元素构成的无序二元组的集合，称为边集。
[1]
直观来说，若一个图中每条边都是无方向的，则称为无向图。
（1）无向边的表示
无向图中的边均是顶点的无序对，无序对通常用圆括号表示。
【例】无序对(vi，vj)和(vj，vi)表示同一条边。
（2）无向图的表示
【例】下面(b)图中的G2和(c)图中的G3均是无向图，它们的顶点集和边集分别为：

V(G2)={v1，v2，v3，v4}
E(G2)={(vl，v2)，(v1，v3)，(v1，v4)，(v2，v3)，(v2，v4)，(v3，v4)}
V(G3)={v1，v2，v3，v4，v5，v6，v7}
E(G3)={(v1，v2)，(vl，v3)，(v2，v4)，(v2，v5)，(v3，v6)，(v3，v7)}
（3）若G是无向图，则0≤e≤n(n-1)/2
恰有n(n-1)/2条边的无向图称无向完全图(Undirected Complete Graph)
注意：完全图具有最多的边数。任意一对顶点间均有边相连。
[2]
在线性规划问题中，有些最优解可能是分数或小数，但对于某些具体问题，常要求某些变量的解必须是整数。例如，当变量代表的是机器的台数，工作的人数或装货的车数等。为了满足整数的要求，初看起来似乎只要把已得的非整数解舍入化整就可以了。实际上化整后的数不见得是可行解和最优解，所以应该有特殊的方法来求解整数规划。在整数规划中，如果所有变量都限制为整数，则称为纯整数规划；如果仅一部分变量限制为整数，则称为混合整数规划。整数规划的一种特殊情形是01规划，它的变数仅限于0或1。不同于线性规划问题，整数和01规划问题至今尚未找到一般的多项式解法。
整数规划是从1958年由R.E.戈莫里提出割平面法之后形成独立分支的 ，30多年来发展出很多方法解决各种问题。解整数规划最典型的做法是逐步生成一个相关的问题，称它是原问题的衍生问题。对每个衍生问题又伴随一个比它更易于求解的松弛问题（衍生问题称为松弛问题的源问题）。通过松弛问题的解来确定它的源问题的归宿，即源问题应被舍弃，还是再生成一个或多个它本身的衍生问题来替代它。随即 ，再选择一个尚未被舍弃的或替代的原问题的衍生问题，重复以上步骤直至不再剩有未解决的衍生问题为止。现今比较成功又流行的方法是分支定界法和割平面法，它们都是在上述框架下形成的。
[1]
整数规划又分为：
1、纯整数规划：所有决策变量均要求为整数的整数规划
2、混合整数规划：部分决策变量均要求为整数的整数规划
3、纯0－1整数规划：所有决策变量均要求为0－1的整数规划
4、混合0－1规划：部分决策变量均要求为0－1的整数规划
整数规划与线性规划不同这处只在于增加了整数约束。不考虑整数约束所得到的线性规划称为整数规划的线性松弛模型。
[2]
单纯形算法利用多面体的顶点构造一个可能的解，然后沿着多面体的边走到目标函数值更高的另一个顶点，直至到达最优解为止。虽然这个算法在实际上很有效率，在小心处理可能出现的“循环”的情况下，可以保证找到最优解，但它的最坏情况可以很坏：可以构筑一个线性规划问题，单纯形算法需要问题大小的指数倍的运行时间才能将之解出。事实上，有一段时期内人们曾不能确定线性规划问题是NP完全问题还是可以在多项式时间里解出的问题。
第一个在最坏情况具有多项式时间复杂度的线性规划算法在1979年由前苏联数学家Leonid Khachiyan提出。这个算法建基于非线性规划中Naum Shor发明的椭球法（ellip-soid method），该法又是Arkadi Nemirovski（2003年冯‧诺伊曼运筹学理论奖得主）和D. Yudin的凸集最优化椭球法的一般化。
理论上，“椭球法”在最恶劣的情况下所需要的计算量要比“单形法”增长的缓慢，有希望用之解决超大型线性规划问题。但在实际应用上，Khachiyan的算法令人失望：一般来说，单纯形算法比它更有效率。它的重要性在于鼓励了对内点算法的研究。内点算法是针对单形法的“边界趋近”观念而改采“内部逼近”的路线，相对于只沿着可行域的边沿进行移动的单纯形算法，内点算法能够在可行域内移动。
1984年，贝尔实验室印度裔数学家卡马卡（Narendra Karmarkar）提出了投影尺度法（又名Karmarkar's algorithm）。这是第一个在理论上和实际上都表现良好的算法：它的最坏情况仅为多项式时间，且在实际问题中它比单纯形算法有显著的效率提升。自此之后，很多内点算法被提出来并进行分析。一个常见的内点算法为Mehrotra predictor-corrector method。尽管在理论上对它所知甚少，在实际应用中它却表现出色。
单形法沿着边界由一个顶点移动到“相邻”的顶点，内点算法每一步的移动考量较周详，“跨过可行解集合的内部”去逼近最佳解。当今的观点是：对于线性规划的日常应用问题而言，如果算法的实现良好，基于单纯形法和内点法的算法之间的效率没有太大差别，只有在超大型线性规划中，顶点几成天文数字，内点法有机会领先单形法。
线性规划的求解程式在各种各样的工业最优化问题里被广泛使用，例如运输网络的流量的最优化问题，其中很多都可以不太困难地被转换成线性规划问题。
[2]
整数规划组合最优化
组合最优化通常都可表述为整数规划问题。两者都是在有限个可供选择的方案中，寻找满足一定约束的最好方案。有许多典型的问题反映整数规划的广泛背景。例如，背袋（或装载）问题、固定费用问题、和睦探险队问题（组合学的对集问题）、有效探险队问题（组合学的覆盖问题）、旅行推销员问题, 车辆路径问题等。因此整数规划的应用范围也是极其广泛的。它不仅在工业和工程设计和科学研究方面有许多应用，而且在计算机设计、系统可靠性、编码和经济分析等方面也有新的应用。
整数规划0—1规划
0—1规划在整数规划中占有重要地位，一方面因为许多实际问题，例如指派问题、选地问题、送货问题都可归结为此类规划，另一方面任何有界变量的整数规划都与0—1规划等价，用0—1规划方法还可以把多种非线性规划问题表示成整数规划问题，所以不少人致力于这个方向的研究。求解0—1规划的常用方法是分枝定界法，对各种特殊问题还有一些特殊方法，例如求解指派问题用匈牙利方法就比较方便。
[2]
最大团问题又称为最大独立集问题（Maximum Independent Set Problem）。确定性算法有回溯法、分支限界法等，启发式算法有蚁群算法、顺序贪婪算法、DLS-MC算法和智能搜索算法等。
给定无向图G=(V,E)，其中V是非空集合，称为顶点集；E是V中元素构成的无序二元组的集合，称为边集，无向图中的边均是顶点的无序对，无序对常用圆括号“( )”表示。如果U



V，且对任意两个顶点u，v∈U有(u,v)∈E，则称U是G的完全子图。G的完全子图U是G的团。G的最大团是指G的最大完全子图。
如果UÍV且对任意u，v∈U有(u,v)不属于E，则称U是G的空子图。G的空子图U是G的独立集当且仅当U不包含在G的更大的空子图中。G的最大独立集是G中所含顶点数最多的独立集。
对于任一无向图G=(V,E)，其补图G'=(V',E')定义为：V'=V，且(u,v)∈E'当且仅当(u,v)∉E。
如果U是G的完全子图，则它也是G'的空子图，反之亦然。因此，G的团与G'的独立集之间存在一一对应的关系。特殊地，U是G的最大团当且仅当U是G'的最大独立集。
通俗点讲就是在一个无向图中找出一个点数最多的完全图。
MCP问题是现实世界中一类真实问题，在市场分析、方案选择、信号传输、计算机视觉、故障诊断等领域具有非常广泛的应用。自1957年Hararv和Ross首次提出求解最大团问题的确定性算法以来，研究者们已提出了多种确定性算法来求解最大团问题。但随着问题规模的增大（顶点增多和边密度变大），求解问题的时间复杂度越来越高，确定性算法显得无能为力，不能有效解决这些NP完全问题。
20世纪80年代末，研究者们开始尝试采用启发式算法求解最大团问题，提出了各种各样的启发式算法，如顺序贪婪启发式算法、遗传算法、模拟退火算法、禁忌搜索算法、神经网络算法等，并且取得了令人满意的效果。在时间上，由于采用了启发式信息，启发式算法的运算时间与确定性算法的运算时间之间的比值会随着图的顶点、边密度的增加而变得越来越小。唯一的缺点就是不一定能找到最优值，有时只能找到近优值。
近年来研究表明，单独使用一种启发式算法求解最大团问题，算法性能往往并不是很好，因此，常借鉴算法之间优势互补策略，形成新的混合启发式算法来求解最大团问题。当前求解该问题最好的启发式算法有反作用禁忌搜索（Reactive Tabu Search, RTS）算法、基于遗传算法的简单启发式算法（Simple Heuristic Based Genetic Algorithm, HGA）、DLS-MC算法等。
最大团问题顺序贪婪启发式算法
顺序贪婪启发式算法是最早的求解最大团的启发式算法。这类算法通过给一个团重复进行加点操作得到一个极大团或者对一组并不是团的子图重复进行删除顶点操作以得到一个团。1987年，Kopf和Ruhe把这类型算法分为Best in和Worst out两类。
(1)Best in方法的基本思路：由一个团出发，和这个团中顶点相连的顶点组成候选集；然后以一定的启发式信息，从中选择顶点加入团中，以后反复进行，直到最后得到一个极大团。
(2)Worst out方法的基本思路：从整个顶点集开始，然后按一定的启发式信息，从中反复进行删除顶点操作，直到最后得到一个团。
顺序贪婪启发式算法有很大不足，该算法一旦找见一个极大团，搜索就停止，因此找到最大团的概率相对较低。
最大团问题局部搜索启发式算法
假设SG为图的所有极大团的集合，由于顺序贪婪启发式算法仅能找见SG中的一个极大团，因此，为了提高解的质量，应当扩大在SG的搜索区域，比如，可以在极大团S的邻居中继续进行搜索，以扩大搜索区域，进而提高解的质量。
在局部搜索启发式算法中，如果搜索S的邻居越多，提高解的质量的机会就越大。依赖不同的邻居定义，局部搜索启发式算法可以得到不同的解。在局部搜索启发式算法中，比较有名的算法是K-interchange启发式算法，它是一种基于K-neighbor邻居实现的，在解集S的K邻居中进行局部搜索的方法。
分析可知，局部搜索启发式算法存在一个问题，即仅能够找见一个局部最优值。所以为了提高求解的质量，常把该算法和其它算法相混合，从而得到求解MCP问题的新的算法。
WaynePullan和HolgerH．Hoos基于这一思想提出了求解最大团问题的DLS-MC算法，该算法是plateau search局部搜索启发式和算法迭代改善法相混合得到的，算法性能非常好，在该方法中引入了顶点惩罚函数，该函数在算法的求解过程中能够动态改变；在算法执行过程中迭代改善法和plateau search算法轮流执行来提高解的质量。在基准图上对该算法进行了测试，性能非常好。
最大团问题智能搜索启发式算法
智能搜索算法主要有遗传算法、禁忌算法、模拟退火算法、神经网络等。
最大团问题遗传算法
遗传算法（Genetic Algorithm, GA）是一种基于自然选择和群体遗传机理的搜索算法，它模拟了自然选择和自然遗传过程中发生的复制、交叉和变异现象。
1993年，Carter和Park首次提出使用遗传算法求解最大团问题，但由于所求解的质量差，计算复杂度高，因此，他们认为遗传算法并不适合求解最大团问题。与此同时，B&auml;ck和Khuri致力于最大独立集问题的求解，却得到了完全相反的结论，通过选用合适的适应度函数，取得了很好的效果。因此在使用GA来解决最大团问题时，适应度函数起着非常关键的作用。此后，基于遗传算法求解最大团问题的方法逐渐增多，但在提高解的质量，降低算法复杂度上方面却没有大幅度的提高。
l998年，Marchiori提出了一种基于遗传算法的简单启发式算法（simple heuristic based genetic algorithm, HGA)。算法由两部分组成：简单遗传算法（simple genetic algorithm, SGA）和简单的贪婪启发式局部搜索算法（simple greedy heuristic local search algorithm,SGHLSA）。在基准图上对算法HGA的性能进行测试，证明了该算法在解的质量和计算速度方面都优于基于遗传算法的其它算法。
因此，单纯使用遗传算法（改动变异、杂交、选择等算子）求解最大团问题时，算法的性能是比较差；要提高算法性能，遗传算法最好能和局部搜索算法相结合。
最大团问题模拟退火算法
模拟退火（Simulated Annealing, SA）算法是N. Metropolis在1953年提出的一种基于物质退火过程的随机搜索算法，是一种迭代求解的启发式随机搜索算法。首先在高温下较快地进行搜索，使系统进入“热平衡”状态，大致地找到系统的低能区域。随着温度的逐渐降低，搜索精度不断提高，可逐渐准确地找到最低能量的基态。作为局部搜索算法的扩展，当邻域的一次操作使当前解的质量提高时，接受这个改进解作为新的当前解；反之，以一定的概率接受相对质量比较差的解作为新的当前解。
Aarts和Korst提出使用模拟退火算法来解决独立集问题，建议在算法设计时引入惩罚函数，但却没有提供任何的实验结果。问题的解空间S是图G的全部可能的子图，并不要求是独立集，对于任一子图G*，成本函数为f(V')=|V'|-k|E'|，其中V'是图G*的顶点集，E'是图G*的边集，k是权因子（k>1）。选择邻居时，费用值大的将被选中，因此求解最大独立集问题也就是最大化成本函数问题。
Homer和Peinado把模拟退火算法和Johnson的贪婪启发式算法、Boppan的随机化算法、Halldorsson的子图排除法3种启发式算法进行比较，结果比这3种算法要好很多。总之，模拟退火算法在处理最大团问题上是一个非常好的算法。
最大团问题禁忌算法
禁忌算法（Tabu Algorithm）是一种改进的局部搜索算法。该算法为了避免在搜索过程中出现死循环和开发新的搜索区域，采用了一种基于禁止的策略。
1989年，Friden提出了基于禁忌搜索的求解最大独立集的启发式算法，独立集的大小固定，该算法的目标是最小化当前子集（解）顶点之间的边数。使用3个禁忌表：其中，一个禁忌表用来存放上一代的解，另外两个分别存放刚进入解顶点和刚被删去的顶点。
基于禁忌算法求解最大团问题具有代表性的是Batti和Protasi提出的反作用局部搜索（Reaction Local Search, RLS）算法，通过引入局部搜索算法，扩展了禁忌搜索的框架。与一般禁忌搜索算法相比，该算法的特点是：在执行过程中，根据所得到的解的情况形成一种内部反馈机制以控制调整算法的控制参数，所以该算法的控制参数是动态变化的；比如，禁止表长度参数是动态变化的，因此禁忌表长度是动态变化的。他们在DIMACS的基准图上对算法性能进行测试，取得非常好的效果。
最大团问题神经网络算法
人工神经网络指为了模拟生物大脑的结构和功能而构成的一种大型的、分布式系统，它有很强的自组织性、自适应性和学习能力。
20个世纪80年代末期，Ballard、Godbeerl、Ramanujam和Sadayappan等都尝试对最大团和相关问题按人工神经网络进行编码，进而求解该问题。然而，这些研究只提供了很少的实验结果。
Grossman提出一种离散的/确定性的Hopfield模型来求解最大团。这个模型有一个用来决定网络是否处于稳定态的临界值参数。Grossman建议在这个参数上使用退火策略，并且使用自适应机制选择网络的初始状态和临界值。在DIMACS基准图上测试，得到比较好的结果，但与性能好的启发式算法相比，其结果较差，比如结果要差于模拟退火算法。1995年Jagota对Hopfield模型进行了多处修改来近似求解最大团问题，其中有的是离散化的，有的是连续的；虽然有了一定改进，但是性能并没有显著提高。随后，仍然有好多研究者使用Hopfield神经网络来求解最大团问题，但是与其它智能搜索算法相比，效果比较差。
研究表明：(1) 前3种智能搜索算法适合求解MCP，而通过神经网络算法求解MCP时的性能比较差；(2) 单独使用智能搜索算法来求解MCP，算法性能并不好，因此，常和局部搜索算法相结合形成新的混合算法，比如：禁忌算法与局部搜索算法相混合形成的反作用禁忌搜索算法，遗传算法与局部搜索算法相混合形成的简单启发式算法等。
最大团问题改进蚁群算法-AntMCP
蚁群算法是由Dorigo M.等人依据模仿真实的蚁群行为而提出的一种模拟进化算法。蚂蚁之间是通过一种称为信息素（Pheromone）的物质传递信息的，蚂蚁能够在经过的路径上留下该种物质，而且能够感知这种物质的存在及其强度，并以此来指导自己的运动方向。因此，由大量蚂蚁组成的集体行为便表现出一种信息正反馈现象：某一条路径上走过的蚂蚁越多，该路径上留下的信息素就越多，则后来者选择该路径的概率就越大。蚂蚁之间就是通过这种信息素的交流，搜索到一条从蚁巢到食物源的最短路径。
2003年，Fenet和Solnon提出了求解最大团问题的蚁群算法AntClique，该算法仍然将信息素留在边上，信息素tij是指把结点i和结点j分配到同一个团中的期望。由于没有使用局部启发信息，这使得迭代初期各候选顶点的选择概率几乎相等，这样算法在迭代初期有一定的盲目性，往往需要更多的迭代次数才能得到最优解。针对这些不足及最大团问题的特点，曾艳于2010年提出了改进的蚁群算法-AntMCP。
算法伪代码描述如下：
Procedure Vertex_AntClique
Initialize //初始化信息素和局部启发信息
Repeat
For k in 1...nb Ants do:
Choose randomly a first vertex v f∈V
Ck←{v f }
Candidate &not;{v i |(v f,v i) ∈E}
While Candidate≠0 do
Choose a vertex v i∈Candidate with probability p(v i);
Ck←Ck∪{v i}
Candidate ←Candidate ∩{v j |(vi,v j) ∈E}
End of while
End of for
Update pheromone w.r.t {C1,…,CnbAnts}
Until max cyclesreached or optimal solution found
End of procedure
在AntMCP中，增加了局部启发信息；信息素t和启发信息h不是留在边上，而是留在顶点上。这样，变量t和h由二维降为一维，既可节省存储空间，又可提高运行速度，大量实验表明，该算法运算速度更快，效率更高。
最大团问题其它启发式算法
除上述几种启发式算法外，目前研究者们还提出了一些新的算法。当图的顶点数不大于阈值M时，称此图为低度图，求解低度图的最大团问题的时间复杂度为O(d)，基于这一思想，王青松和范铁生提出了一种求解低度图的最大团的确定性算法。在该算法中，通过对图按顶点逐步分解实现分别计算，较好地解决了低度图的最大团问题，算法的时间复杂度为O(d*n^3)。针对遗传算法在最大团求解中保持群体多样性能力不足、早熟、耗时长、成功率高等缺陷，依据均匀设计抽样理论对交叉操作进行重新设计，结合免疫机理定义染色体浓度设计克隆选择策略，周本达、岳芹等提出了一种求解最大团问题的均价设计抽样免疫遗传算法。仿真算例表明，该算法在解的质量、收敛速度等各项指标上均有提高，与DLS-MC、QUALEX等经典搜索算法相比，对部分算例能得到更好解。吴冬辉和马良提出了基于遗传算法的最大团问题求解算法，通过引入概率模型指导变异产生新的个体，并结合启发式局部算法搜索最大团。实例结果验证了该算法的有效性。针对求解最大团问题的分层的边权网络（Hierarchical Edge-Weight Network,HEWN）算法，郭长庚和潘晓伟设计了一个实现HEWN算法的数据结构，指出在HEWN算法中HEWN算法的存储宜采用邻接多重表和二叉表相结合的链表表示法，并进行了时间复杂度分析，得出HEWN算法的时间复杂度是指数级而不是O(n^8.5)。针对基于适应值的选择交叉机制在优化具有欺骗性的最大团问题中性能退化的问题，张雁、党群等提出了一种新的基于匹配教程的Memetic算法。算法中提出交叉匹配度的概念，用来估计两个体交叉所能获得的最佳适应值。通过匹配度的计算对交叉方向的选择进行控制，保证了交叉操作以较大的概率生成新的优良模式。测试结果表明，该算法优于目前在最大团问题求解中性能最好的多阶段动态局部搜索算法。DNA计算是应用分子生物技术进行计算的新方法，具有高度并行性、大容量、低能耗等特点。针对这一特点，李涛提出了用DNA算法求解最大团问题，开创了以生物技术为工具解决复杂问题的新纪元，为解决NP完全问题开辟了一条新途径。基于对粘贴模型的组成、基本实验及其生化实现过程的分析，根据最大团问题的需求，周康、刘朔等在粘贴模型中，提出了基于电泳技术和分离实验的DNA序列检测方法。基于分离实验提出了一种求解最大团问题的DNA算法，并给出了其生化实现过程。为了提高交叉熵算法求解最大团问题的性能，吕强、柏战华等提出了一种领导者-跟随者协作求解的并行策略来实现交叉熵算法，从而达到减少计算时间和保障解的质量两者的平衡。算法中领导者活跃在并行处理器之间采集数据，并根据当前获得信息对跟随者作出决策；受控的跟随者则主要根据领导者的决策信息自适应地调整搜索空间，完成各自的集团产生任务。实验结果表明该算法较基于种群的启发式算法有一定的性能改善。
最大团问题回溯法
回溯法（BacktrackingAlgorithm, BA）有“通用的解题法”之称，用它可以系统地搜索一个问题的所有解或任一解，是一个既带有系统性又带有跳跃性的搜索算法。在包含问题的所有解的解空间树中，按照深度优先的策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，总是先判断该结点是否肯定不包含问题的解，如果肯定不包含，则跳过对以该结点为根的子树的系统搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按照深度优先的策略进行搜索。BA在用来求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍才结束。而BA在用来求问题的任一解时，只要搜索到问题的一个解即可结束。这种以深度优先的方式系统地搜索问题的解的算法称为回溯法，它适用于解一些组合数较大的问题。
回溯法搜索解空间树时，根节点首先成为一个活结点，同时也成为当前的扩展节点。在当前扩展节点处，搜索向纵深方向移至一个新节点。这个新节点就成为一个新的活结点，并成为当前扩展节点。如果当前扩展节点不能再向纵深方向移动，则当前的扩展节点就成为死结点。此时，往回回溯至最近的一个活节点处，并使这个活结点成为当前的扩展节点。
回溯法以这种方式递归地在解空间中搜索，直至找到所有要求的解或解空间已无活结点为止。
搜索：回溯法从根结点出发，按深度优先策略遍历解空间树，搜索满足约束条件的解。
剪枝：在搜索至树中任一结点时，先判断该结点对应的部分解是否满足约束条件，或者是否超出目标函数的界；也即判断该结点是否包含问题的解，如果肯定不包含，则跳过对以该结点为根的子树的搜索，即剪枝（Pruning）；否则，进入以该结点为根的子树，继续按照深度优先的策略搜索。
一般来讲，回溯法求解问题的基本步骤如下：
(1)针对所给问题，定义问题的解空间；确定易于搜索的解空间结构；以深度优先方式搜索解空间，并在搜索过程中利用Pruning函数剪去无效的搜索。
(2)无向图G的最大团问题可以看作是图G的顶点集V的子集选取问题。因此可以用子集树表示问题的解空间。设当前扩展节点Z位于解空间树的第i层。在进入左子树前，必须确认从顶点i到已入选的顶点集中每一个顶点都有边相连。在进入右子树之前，必须确认还有足够多的可选择顶点使得算法有可能在右子树中找到更大的团。
(3)用邻接矩阵表示图G，n为G的顶点数，cn存储当前团的顶点数，bestn存储最大团的顶点数。cn+n-i为进入右子树的上界函数，当cn+n-i<bestn时，不能在右子树中找到更大的团，利用剪枝函数可将Z的右结点剪去。
实例分析
图1

如图1所示，给定无向图G={V, E}，其中V={1,2,3,4,5}，E={(1,2), (1,4), (1,5),(2,3), (2,5), (3,5), (4,5)}。根据MCP定义，子集{1,2}是图G的一个大小为2的完全子图，但不是一个团，因为它包含于G的更大的完全子图{1,2,5}之中。{1,2,5}是G的一个最大团。{1,4,5}和{2,3,5}也是G的最大团。图2是无向图G的补图G'。根据最大独立集定义，{2,4}是G的一个空子图，同时也是G的一个最大独立集。虽然{1,2}也是G'的空子图，但它不是G'的独立集，因为它包含在G'的空子图{1,2,5}中。{1,2,5}是G'的最大独立集。{1,4,5}和{2,3,5}也是G'的最大




图2

独立集。以图1为例，利用回溯法搜索其空间树，具体搜索过程（见图3所示）如下：假设我们按照1&reg;2&reg;3&reg;4&reg;5的顺序深度搜索。开始时，根结点R是唯一活结点，也是当前扩展结点，位于第1层，此时当前团的顶点数cn=0，最大团的顶点数bestn=0。在这个扩展结点处，我们假定R和第二层的顶点1之间有边相连，则沿纵深方向移至顶点1处。此时结点R和顶点1都是活结点，顶点1成为当前的扩展结点。此时当前团的顶点数cn=1，最大团的顶点数bestn=0。继续深度搜索至第3层顶点2处，此时顶点1和2有边相连，都是活结点，顶点2成为当前扩展结点。此时当前团的顶点数cn=2，最大团的顶点数bestn=0。再深度搜索至第4层顶点3处，由于顶点3和2有边相连但与顶点1无边相连，则利用剪枝函数剪去该枝，此时由于cn+n-i=2+5-4=3>bestn=0，则回溯到结点2处进入右子树，开始搜索。此时当前团的顶点数cn=2，最大团的顶点数bestn=0。再深度搜索至第5层顶点4处，由于顶点3和4无边相连，剪去该枝，回溯到结点3处进入右子树，此时当前团的顶点数cn=2，最大团的顶点数bestn=0。继续深度搜索至第6层顶点5处，由于顶点5和4有边相连，且与顶点1和2都有边相连，则进入左子树搜索。由于结点5是一个叶结点，故我们得到一个可行解，此时当前团的顶点数cn=3，最大团的顶点数bestn=3。vi的取值由顶点1至顶点5所唯一确定，即v=(1, 2, 5)。此时顶点5已不能再纵深扩展，成为死结点，我们返回到结点4处。由于此时cn+n-i=3+5-6=2<bestn=3，不能在右子树中找到更大的团，利用剪枝函数可将结点4的右结点剪去。以此回溯，直至根结点R再次成为当前的扩展结点，沿着右子树的纵深方向移动，直至遍历整个解空间。最后得到图1的按照1&reg;2&reg;3&reg;4&reg;5的顺序深度搜索的最大团为U={1,2,5}。当然{1,4,5}和{2,3,5}也是其最大团。




图3
C++ 代码
//MaxClique.cpp : 定义控制台应用程序的入口点。
/*

回溯法求解最大团问题
*/
#include <fstream>
#include <iostream>
#include <stdlib.h>
#include <conio.h>
using namespace std;
#define MAX_v 50 //定义一个最大顶点个数
typedef struct{
    int a[MAX_v][MAX_v]; //
无向图G的
邻接矩阵
    int v; //无向图G的顶点
    int e; //无向图G的边
    int x[50]; //顶点与当前团的连接，x[i]=1 表示有连接
    int bestx[50]; //当前最优解
    int cnum; //当前团的顶点数目
    int bestn; //最大团的顶点数目
}MCP;
void Creat(MCP &G);
void 
Backtrack(MCP &G,int i);
void Creat(MCP &G){
    int i,j;
    ifstream fin("data.txt");
    if (!fin)
    {
        cout<<"不能打开文件:"<<"data.txt"<<
endl;
        exit(1);
    }
    fin>>G.v;
    for (int i=1;i<=G.v;i++)
        for (int j=1;j<=G.v;j++)
            fin>>G.a[i][j];
    for(i=1;i<=G.v;i++) //初始化
    {
        G.bestx[i]=0;
        G.x[i]=0;
        G.bestn=0;
        G.cnum=0;
    }
    cout<<"————————————————"<<
endl;
    cout<<"———
回溯法求解最大团问题———"<<endl;
    cout<<"————————————————"<<endl;
    cout<<"输入初始化
无向图矩阵为:"<<
endl; //初始化
    for(i=1;i<=G.v;i++)
    {
        for(j=1;j<=G.v;j++)
        cout<<G.a[i][j]<<" ";
        cout<<
endl;
    }
}
void Backtrack(MCP &G,int i){
    if (i>G.v){
        for (int j=1; j<=G.v; j++)
            G.bestx[j] = G.x[j];
        G.bestn =G.cnum;
        return ;
    }
    //检查顶点i与当前团的连接
    int OK = 1;
    for (int j=1; j<=i ; j++)
        if (G.x[j]&& G.a[i][j]==0){
            //i不与j相连
            OK = 0;
            break;
        }
    if (OK) {
        G.x[i] = 1;//把i加入团
        G.cnum++;
        Backtrack(G,i+1);
        G.x[i]=0;
        G.cnum-- ;
    }
    if (G.cnum+G.v- i>G.bestn){
        G.x[i] = 0;
        Backtrack(G,i+1);
    }
}
int main(){
    MCP G;
    Creat(G);
    Backtrack(G,1);
    cout<<"最大团包含的顶点数为:"<<G.bestn<<
endl;
    cout<<"最大团方案为:( ";
    for (int i=1;i<=G.v;i++)
        if(G.bestx[i]==1){
            cout<<i<<" ";
        }
    cout<<")"<<
endl;
    
getch();
}
最大团问题分支限界法
分支限界（BranchandBound）法类似于回溯法，也是一种在问题的解空间树上搜索问题的解的算法。
分支限界法常以广度优先或最小耗费（最大效益）优先的方式搜索解空间树。在分支限界法中，每一个活结点只有一次机会成为扩展结点。一旦活结点成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，舍弃那些导致不可行解或导致非最优解的儿子结点，将其余儿子结点加入活结点表中。此后，从活结点表中取下一个结点成为当前扩展结点，并重复上述结点扩展过程，直至找到所需的解或活结点表为空时为止。
具体来讲，分支限界法由“分支”策略和“限界”策略两部分组成。“分支”体现在对问题空间是按广度优先搜索；“限界”策略是为了加速搜索速度而采用启发式剪枝的策略。分支搜索法采用广度优先的策略，依次生成E结点所有分支（即所有的子结点）。在生成的结点中，将采用更有效的约束函数（限界函数）控制搜索路径，去除那些不满足约束条件（即不可能导出最优解）的结点，使之能更好地朝着状态空间树上有最优解的分支推进。
根据从活结点表中选择下一个扩展结点的方式的不同，分支限界法主要分为以下两类：
1.队列式（FIFO）分支限界法
队列式分支限界法将活结点表组织成一个队列，并按队列的FIFO原则选取下一个结点成为当前扩展结点。具体流程为：
A.初始化，根结点是唯一的活结点，根结点入队。
B.从活结点队中取出根结点后，作为当前E结点。对当前E结点，先从左到右地产生它的所有儿子，用约束条件检查，把所有满足约束函数的儿子加入活结点队列中。
C.重复上述过程：再从活结点表中取出队首结点（队中最先进来的结点）为当前E结点，……；直到找到一个解或活结点队列为空为止。
2.优先队列式分支限界法
优先队列式分支限界法将活结点表组织成一个优先队列，并按优先队列中规定的结点优先级选取优先级最高的下一个结点成为当前扩展结点。具体流程为：对每一活结点计算一个优先级，并根据这些优先级，从当前活结点表中优先选择一个优先级最高（最有利）的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。
C++ 代码

//MaxClique_BB.cpp : 定义控制台应用程序的入口点。
/*

分支限界法求解最大团问题
*/
#include <fstream>
#include <iostream>
#include <queue>
#include <conio.h>
using namespace std;
typedef struct{
    int v; //
无向图G的顶点
    int e; //无向图G的边
    int a[50][50]; //定义图G的
邻接矩阵
    int bestx[50]; //最优解
}MCP;
void Creat(MCP &G){
    int i,j;
    ifstream fin("data.txt");
    if(!fin)
    {
        cout<<"不能打开文件:"<<"data.txt"<<endl;
        exit(1);
    }
    fin>>G.v;
    for(int i=1;i<=G.v;i++)
        for(int j=1;j<=G.v;j++)
            fin>>G.a[i][j];
    for(i=1;i<=G.v;i++) //初始化
    {
        G.bestx[i]=0;
    }
    cout<<"————————————————————————"<<
endl;
    cout<<"———
优先队列式
分支限界法求解最大团问题———"<<endl;
    cout<<"————————————————————————"<<endl;
    cout<<"输入初始化
无向图矩阵为:"<<endl; //初始化
    for(i=1;i<=G.v;i++)
    {
        for(j=1;j<=G.v;j++)
        cout<<G.a[i][j]<<" ";
        cout<<endl;
    }
}
struct BBNode
{
    BBNode *parent; //指向父结点的指针
    bool LChild; //左儿子结点标志
};
struct CliqueNode //定义
优先队列类型为CliqueNode
{
    int cnum; //当前团的顶点数
    int un; //当前团最大顶点数的上界
    int level; //结点在子集空间树种所处的层次
    BBNode *p; //指向活结点在子集树中相应结点的指针
    bool operator<(const CliqueNode &b) const //<号
重载建立大根堆
    {
        if (b.un>un) return true;
    if (b.un==un&& b.cnum>cnum) return true;
    else return false;
   }
};
void BBMaxClique(MCP&G)
{
    BBNode *E=new(BBNode); //定义B代表记录的队列情况
    //初始化
    int j,i=1;
    int cnum=0,bestn=0;
    int OK=1;
    priority_queue<CliqueNode> Q; //定义
优先队列Q
    E->LChild=false; //初始化
    E->parent=NULL;
    
while(i!=G.v+1)//非叶结点
    {
        //检查顶点i与当前团中其它顶点之间是否有边相连
        OK=1;
        BBNode *B=E; //把当前点的数据给B，B为中间变量
        for(j=i-1;j>0;B=B->parent,j--)
        if(B->LChild&& G.a[i][j]==0) //如果不满足就停止
        {
            OK=0;
            break;
        }
        if(OK) //满足条件，即左儿子结点为可行结点
        {
            CliqueNode *D=new(CliqueNode); //定义一个节点D
            D->p=new(BBNode);
            if(cnum+1>bestn)bestn=cnum+1;
            D->cnum=cnum+1;
            D->level=i+1;
            D->p->LChild=true;
            D->p->parent=E;
            D->un=cnum+1+G.v-i;
            Q.push(*D); //进队列
        }
        if(cnum+G.v-i>bestn) //不满足条件但是还是可能有最优解
        {
            CliqueNode *D=new(CliqueNode); //定义一个节点D
            D->p=new(BBNode);
            D->cnum=cnum;
            D->level=i+1;
            D->p->LChild=false;
            D->p->parent=E;
            D->un=cnum+G.v-i;
            Q.push(*D); //进队列
        }
        CliqueNode N;
        N=Q.top(); //取队顶元素，
最大堆
        Q.pop(); //删除队顶元素
        E=N.p; //记录当前团的信息
        cnum=N.cnum; //记录当前团的顶点数
        i=N.level; //所在的层次
    }
    for(j=G.v;j>0;j--) //保存最优解
    {
        G.bestx[j]=E->LChild;
        E=E->parent;
        bestn=cnum;
    }
}
int main(){
    MCP G;
    Creat(G);
    BBMaxClique(G);
    cout<<"最大团方案为:(";
    for(int i=G.v;i>0;i--)
        if (G.bestx[i]==1){
            cout<<i<<" ";
        }
    cout<<")"<<
endl;
    
getch();
}
树的二叉链表实现方式
（孩子兄弟表示法）
以二叉链表作为树的存储结构。链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点。
typedef　struct CSNode{
ElemType data；
struct CSNode *firstchild ， *netsibling；
} CSNode，* CSTree；
由于二叉树的存储结构比较简单，处理起来也比较方便，所以有时需要把复杂的树，转换为简单的二叉树后再作处理。
bitree.h
//二叉链表定义
#include <iostream>
using namespace std;
typedef char TElemType;
struct BiTNode{
TElemType data;
BiTNode *lchild,*rchild;
};
typedef BiTNode *BiTree;
void initBiTree(BiTree &T);
void createBiTree(BiTree &T);
void preOrderTraverse(BiTree T,void (*visit)(TElemType)); //递归前序遍历
void preOrderTraverse1(BiTree T,void (*visit)(TElemType)); //非递归前序遍历
void inOrderTraverse(BiTree T,void (*visit)(TElemType)); //递归中序遍历
void postOrderTraverse(BiTree T,void (*visit)(TElemType)); //递归后序遍历
void levelOrderTraverse(BiTree T,void (*visit)(TElemType)); //层序遍历
bitree.cpp
#include "bitree.h"
void initBiTree(BiTree &T){ //构造空二叉树T
T=NULL;
}
void createBiTree(BiTree &T){
//按先序次序输入二叉树中结点的值（'#'表示空格），构造二叉链表表示的二叉树T。
TElemType ch;
cin>>ch;
if(ch=='#') // 空
T=NULL;
else{
T=new BiTNode;
if(!T)
exit(1);
T->data=ch; // 生成根结点
createBiTree(T->lchild); // 构造左子树
createBiTree(T->rchild); // 构造右子树
}
}
void preOrderTraverse(BiTree T,void (*visit)(TElemType)){
// 先序递归遍历T,对每个结点调用函数Visit一次且仅一次
if(T){ // T不空
visit(T->data); // 先访问根结点
preOrderTraverse(T->lchild,visit); // 再先序遍历左子树
preOrderTraverse(T->rchild,visit); // 最后先序遍历右子树
}
}
void preOrderTraverse1(BiTree T,void (*visit)(TElemType)){
//前序遍历二叉树T的非递归算法(利用栈)，对每个数据元素调用函数Visit
BiTree s[100];
int top=0; //top为栈顶指针
while((T!=NULL)||(top>0)){
while(T!=NULL){
visit(T->data);
s[top++]=T;
T=T->lchild;
}
T=s[--top];
T=T->rchild;
}
}
void inOrderTraverse(BiTree T,void (*visit)(TElemType)){
//中序递归遍历T,对每个结点调用函数Visit一次且仅一次
if(T){
inOrderTraverse(T->lchild,visit); // 先中序遍历左子树
visit(T->data); // 再访问根结点
inOrderTraverse(T->rchild,visit); // 最后中序遍历右子树
}
}
void postOrderTraverse(BiTree T,void (*visit)(TElemType)){
//后序递归遍历T,对每个结点调用函数Visit一次且仅一次
if(T){
inOrderTraverse(T->lchild,visit); // 后序遍历左子树
inOrderTraverse(T->rchild,visit); // 再后序遍历右子树
visit(T->data); // 最后访问根结点
}
}
void levelOrderTraverse(BiTree T,void (*visit)(TElemType)){
//层序遍历T(利用队列),对每个结点调用函数Visit一次且仅一次
BiTree q[100],p;
int f,r; // f,r类似于头尾指针
q[0]=T;
f=0;
r=1;
while(f<r){
p=q[f++]; //出队
visit(p->data);
if(p->lchild!=NULL)
q[r++]=p->lchild; //入队
if(p->rchild!=NULL)
q[r++]=p->rchild; //入队
}
}
串
拼音:chuàn　guàn
部首:丨,部外笔画:6,总笔画:7



笔画顺序：竖、横折、横、竖 、横折、横、竖
五笔86&98:KKHK　仓颉:LL
笔顺编号:2512512　四角号码:50006　UniCode:CJK 统一汉字 U+4E32
[1]
串基本字义
● 串
chuànㄔㄨㄢˋ
1、本义：将物品连贯在一起。或亦指连贯而成的物品。如：串珠子、钱串。
2、衍义：交错连接。如：电话串线、看书串行。
3、衍义：互相沟通、勾结。如：串气、串供、串通一气。
4、衍义：由这里到那里走动。如：串乡、串门。
5、衍义：临时扮演自己本行以外的角色。如：串演、客串。
6、衍义：量词，用于连贯起来的东西。如：几串葡萄。
7、衍义：亲近，巴结。也作串昵。如：《新唐书》：“文静数履军陷阵，以才自进，而寂专用串昵显。”
串详细字义
◎ 串 chuàn
1、本义：将物品连贯在一起。或亦指连贯而成的物品。（英语：string together）如：串珠子、钱串。
2、衍义：多个同类东西连贯在一起。如：串讲、贯串。
3、衍义：交错连接。（英语：cross）如：电话串线、看书串行。
4、衍义：错误地连接。如：串行。串味。串换。
5、衍义：互相沟通合谋、勾结（英语：gang up on;conspire）。如：串气、串供、串通一气。
6、衍义：由这里到那里走动（英语：walk;pay a visit to）。如：串乡、串门。
7、衍义：临时扮演自己本行以外的角色。（英语：Play a role outside of your field temporarily）如：串演、客串。
8、衍义：亲近，巴结。（英语：fawn on）也作串昵。如：《新唐书》：“文静数履军陷阵，以才自进，而寂专用串昵显。”
9、衍义：亲近的人。（英语：people on intimate terms）如：晋·谢惠连《秋怀》：“团歌遂成赋，聊用布亲串。”又如:亲串；戚串
10、衍义：习惯 。（英语：Habit）如：《南史·宗悫传》：“宗军人串噉粗食。”。又如:串用(惯用)；串习(习惯)。
11、衍义：相谑，戏谑 。（英语：Banter）如:串狎(戏谑)
12、衍义：量词，用于连贯起来的东西。如：几串葡萄。
13、衍义：网络语：两个“中”连在一起，表示非常赞同。

◎ 串 guàn
〈名〉
(1) 习惯 [habit]
宗军人串噉粗食。——《南史·宗悫传》
(2) 又如:串用(惯用);串习(习惯)
(3) 亲近的人 [people on intimate terms]
团歌遂成赋,聊用布亲串。——晋· 谢惠连《秋怀》
(4) 又如:亲串;戚串
词性变化
◎ 串 guàn
〈动〉
(1) 亲近,巴结。也作串昵[fawn on]
文静数履军陷阵,以才自进,而 寂专用串昵显。——《新唐书》
(2) 相谑,戏谑 [joke]。如:串狎(戏谑)
(3) 另见 chuàn
表示人自大、轻佻、目中无人还仗势欺人，无理取闹！
串是字符的有限序列，它是由单个字符组成的特殊线性表；记为：
String=‘a1 a2 a3 … an’　n是串的长度,n≥0,为0表示空串。
串中任意个连续字符组成的字符子序列称为子串。当2个串的长度相等，且各对应位置上的字符都相同时，称两个子串是相等的。
康熙字典
《广韵》《集韵》《正韵》𠀤古患切，与惯通。狎习也。《诗·大雅》串夷载路。《毛传》串习。夷，常也。《笺》串夷卽混夷。西戎国名。《荀子·大略篇》国法禁拾遗，恶民之串，以无分得也。《梁𥳑文帝诗》长颦串翠眉。《谢惠连·秋怀诗》聊用布亲串。《注》言赋诗布与亲狎之人也。　　又《正韵》枢绢切，音钏。物相连贯也。与穿读去声通。穿，亦作串。《前汉·司马迁传》贯穿经传，卽贯串，言博通经传大义也。　　又与𠢏通，别作賗。《文字指归》支取货物之契曰賗，今官司仓库收帖曰串子。　　又《正韵》五换切，音玩。义同。
[2]
谜语：大嘴对小嘴，一线将其穿（打一字）——串
谜语解析：“嘴”即为“口”，大嘴、小嘴相对，为“吕”字，中间穿着一根线，即为“串”。
◎ 串
bunch　cluster　strand
English
◎ string; relatives; conspire
◎ 串 chuàn
〈量〉
(1) 穿在绳上的一组东西,尤指穿满的一串 [string]。如:一串洋葱;一串鱼
(2) 另见 guàn
◎ 串并联 chuàn-bìnglián
[series-parallel connection;series multiple] 管路或电路元件的一种排列,其中两个或多个元件的并联组又串联地连接起来
◎ 串供 chuàngòng
[act in collusion to make each other's confessions tally] 同案犯人互相串通,编造口供
◎串户chuànhù
[visit one house after another] 即挨家串门
走村串户
◎串话chuànhuà
[cross talk] 在电话受话器中听到的由附近的电话线路感应产生的说话声
◎ 串换 chuànhuàn
[exchange] 互换
串换座次
◎ 串讲 chuànjiǎng
[construe] 逐字逐句地讲解课文或把整篇著作内容连贯起来概括讲述
◎ 串联 chuànlián
(1) [series connection]∶电路中的元件或部件排列得使电流全部通过每一部件或元件而不分流
(2) [establish ties;contact]∶逐个地联系
◎串门子chuàn ménzi
(1) [call on one’s neighbors;call at sb.'s home] 到别人家里去走动,聊天
不做饭,不做针线,光串门子,到老算个什么
(2) 也说“串门儿”
◎ 串骗 chuànpiàn
[gang up ] 串通起来诈骗
◎串气chuànqì
(1) [collude with]∶相通串连,合成一气;暗中勾结,互相配合
(2) [visceral herniation]∶疝气的俗称
◎ 串亲戚 chuàn qīnqi
[go visiting one's relatives] 去亲戚家看望
◎ 串通 chuàntōng
(1) [collude with;gang up]∶互相配合,彼此勾结
串通一气
(2) [contact]∶串联;联系
◎ 串戏 chuànxì
[play a part in] 演戏,特指非职业演员扮演戏曲角色
◎ 串演 chuànyǎn
[play(act) the role of] 饰演,在剧中担任一个或多个角色
◎ 串子 chuànzi
[a string of ] 连贯起来的东西
钱串子
串的书法




串的书法(4张)
串是零个或多个字符组成的有限序列。一般记S=‘a1a2....an ’其中，S是串名，单引号括起的字符序列是串值；ai（1〈=i〈=n）可以是字母，数字或其它字符；串中所包含的字符个数为该串的长度。长度为零的串称为空串，它不包含任何字符。
串中任意个连续的字符组成的子序列称为该串的子串。包含子串的相应地称为主串。通常，把子串在主串中第一次出现时，子串的第一次字符在主串中的序号，定义为子串在主串中的序号。
称两个串是相等的，当且仅当这两个串的值相等。也就是说，只有当两个串的长度相等，并且各个对应位置的字符都相等时才相等。
值得一提的是，串值必须用一对单引号括起来，但单引号本身不属于。
串的基本操作
LENGTH（S）　求串S的长度。
SUBSTR（S，start，len）　从串S中的start位置开始，求len个字符的子串。
DATE=’20‘+SUBSTR（’03/07/00‘，7，2）+’年‘
CONCAT（S1，S2）　联接S1和S2，组成一个新串
S=CONCAT（’Str‘，’ing‘）
INDEX（S1，S2）　确定S2在S1中的位置。
REPLACE（S1，S2，S3）　用串S3替换串S1中所有与串S2相等且不重叠的子串。
串操作举例
对串的操作可以用上述5种基本操作来实现。例如，
已知 S=’（XYZ）+*‘T=’（X+Z）*Y‘，将S转化为T。
S = REPLACE（S，’（XYZ）‘，’（X+Z）‘）
S1 = SUBSTR(S,1,5)
S1 = CONCAT（S1，SUBSTR（S，7，1））
T = CONCAT（S1，SUBSTR（S，3，1））
串儿是一种河南省安阳县水冶小吃。特点是好吃不贵，一块钱十二串。
串是《雪在烧》女主角罗一的饰演者吕一的粉丝名称。
地址空间存储器抽象
在计算机中，每个设备以及进程都被分配了一个地址空间。处理器的地址空间由其地址总线以及寄存器决定。地址空间可以分为Flat——表示起始空间位置为0；或者Segmented——表示空间位置由偏移量决定。在一些系统中，可以进行地址空间的类型转换。至于IP地址空间，IPV4协议并没有预见到IP地址的需求量如此之大，32位的地址空间已经无法满足需求了。因此，开发了IPV6协议，支持128位的地址空间
[1] 
。
地址空间暴露问题
把物理地址暴露给进程会带来下面几个严重问题。第一，如果用户程序可以寻址内存的每个字节，它们就可以很容易地（故意地或偶然地）破坏操作系统，从而使系统慢慢地停止运行。即使在只有一个用户进程运行的情况下，这个问题也是存在的。第二，使用这种模型，想要同时（如果只有一个CPU就轮流执行）运行多个程序是很困难的。在个人计算机上，同时打开几个程序是很常见的（一个文字处理器，一个邮件程序，一个网络浏览器，其中一个当前正在工作，其余的在按下鼠标的时候才会被激活）。在系统中没有对物理内存的抽象的情况下，很难做到上述情景，因此，我们需要其他办法。
要保证多个应用程序同时处于内存中并且不互相影响，则需要解决两个问题：保护和重定位。我们来看一个原始的对前者的解决办法：给内存块标记上一个保护键，并且比较执行进程的键和其访问的每个内存字的保护键。然而，这种方法本身并没有解决后一个问题，虽然这个问题可以通过在程序被装载时重定位程序来解决，但这是一个缓慢且复杂的解决方法。
一个更好的办法是创造一个新的内存抽象：地址空间。就像进程的概念创造了一类抽象的CPU以运行程序一样，地址空间为程序创造了一种抽象的内存。地址空间是一个进程可用于寻址内存的一套地址集合。每个进程都有一个自己的地址空间，并且这个地址空间独立于其他进程的地址空间（除了在一些特殊情况下进程需要共享它们的地址空间外）。
地址空间的概念非常通用，并且在很多场合中出现。随着数量的增长，空间变得越来越不够用了，从而导致需要使用更多位数。
地址空间可以不是数字的。互联网域名也是地址空间。这个地址空间是由所有包含2~63个字符并且后面跟着字符串组成的，组成这些字符串的字符可以是字母、数字和连字符。
[2]
物理地址 (physical address): 放在寻址总线上的地址。放在寻址总线上，如果是读，电路根据这个地址每位的值就将相应地址的物理内存中的数据放到数据总线中传输。如果是写，电路根据这个地址每位的值就将相应地址的物理内存中放入数据总线上的内容。物理内存是以字节(8位)为单位编址的。
虚拟地址 (virtual address): CPU启动保护模式后，程序运行在虚拟地址空间中。注意，并不是所有的“程序”都是运行在虚拟地址中。CPU在启动的时候是运行在实模式的，内核在初始化页表之前并不使用虚拟地址，而是直接使用物理地址的。
物理存储器和存储地址空间是两个不同的概念。但是由于这两者有十分密切的关系，而且两者都用B、KB、MB、GB来度量其容量大小，因此容易产生认识上的混淆，弄清这两个不同的概念，有助于进一步认识主存储器和用好主存储器。
物理存储器是指实际存在的具体存储器芯片。如主板上装插的主存条和装载有系统的BIOS的ROM芯片，显示卡上的显示RAM芯片和装载显示BIOS的ROM芯片，以及各种适配卡上的RAM芯片和ROM芯片都是物理存储器。
存储地址空间是指对存储器编码（编码地址）的范围。所谓编码就是对每一个物理存储单元（一个字节）分配一个号码，通常叫作“编址”。分配一个号码给一个存储单元的目的是为了便于找到它，完成数据的读写，这就是所谓的“寻址”（所以，有人也把地址空间称为寻址空间）。
CPU在操控物理存储器的时候，把物理存储器都当作内存来对待，把它们总的看作一个由若干存储单元组成的逻辑存储器，这个逻辑存储器就是我们所说的内存地址空间。
有的物理存储器被看作一个由若干存储单元组成的逻辑存储器，每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间。CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。
地址空间的大小和物理存储器的大小并不一定相等。举个例子来说明这个问题：某层楼共有17个房间，其编号为801～817。这17个房间是物理的，而其地址空间采用了三位编码，其范围是800～899共100个地址，可见地址空间是大于实际房间数量的。
对于386以上档次的微机，其地址总线为32位，因此地址空间可达2的32次方,即4GB。但实际上我们所配置的物理存储器通常只有1MB、2MB、4MB、8MB、16MB、32MB等，远小于地址空间所允许的范围
[1] 
。
IPv6是下一代互联网协议。现有的互联网是在IPv4的基础上运行的，随着互联网的迅速发展，IPv4定义的有限地址（IP地址）空间将被耗尽，必将影响互联网的进一步发展。IPv4采用32位地址长度，只有大约43亿个地址，估计在2009～2010年间将被分配完毕。IPv6重新定义地址空间，采用128位地址长度，几乎可以不受限制地提供地址，保守估计IPv6实际可分配的地址，整个地球每平方米面积上就可分配1000多个地址。
除了地址空间巨大之外，IPv6还具有这几方面的优势：无状态自动配置，网络更加安全，服务质量更好。

在x86体系结构中分段机制是必选的，而分页机制则可由具体的操作系统而选择，Linux通过让段的基地址为0而巧妙的绕过了基地址。因此，对于Linux来说，虚地址和线性地址是一致的。在32位的平台上，线性地址的大小为固定的4GB。并且，由于采用了保护机制，Linux内核将这4GB分为两部分，虚地址较高的1GB（0xC0000000到0xFFFFFFFF）为共享的内核空间；而较低的3GB（0x00000000到0xBFFFFFFF）为每个进程的用户空间。由于每个进程都不能直接访问内核空间，而是通过系统调用间接进入内核，因此，所有的进程都共享内核空间。而每个进程都拥有各自的用户空间，各个进程之间不能互相访问彼此的用户空间。因此，对于每一个具体的进程而言，都拥有4GB的虚拟地址空间
[3] 
。
[(both) parents; father and mother] 父亲和母亲。
[1]
指父母。
唐 韩翃 《赠兖州孟都督》诗：“不见双亲办丰膳，能留五马尽佳期。” 宋 晁补之 《洞仙歌·柑》词：“双亲云水外，游子空怀，惆怅无人可归遗。” 清 蒲松龄 《聊斋志异·小翠》：“有新妇在，刀锯斧钺，妇自受之，必不令贻害双亲。” 巴金《家》六：“在家里得着双亲的钟爱，在私塾得到先生的赞美。”
[1]
单链表概念介绍
链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。
以“结点的序列”表示线性表称作线性链表（单链表），单链表是链式存取的结构。
单链表链接存储方法
链接方式存储的线性表简称为链表（Linked List）。
链表的具体存储表示为：
① 用一组任意的存储单元来存放线性表的结点（这组存储单元既可以是连续的，也可以是不连续的）
② 链表中结点的逻辑次序和物理次序不一定相同。为了能正确表示结点间的逻辑关系，在存储每个结点值的同时，还必须存储指示其后继结点的地址（或位置）信息（称为指针（pointer）或链(link)）
链式存储是最常用的存储方式之一，它不仅可用来表示线性表，而且可用来表示各种非线性的数据结构。
单链表结点结构
┌───┬───┐
│data │next │
└───┴───┘
data域--存放结点值的数据域
next域--存放结点的直接后继的地址（位置）的指针域（链域）
链表通过每个结点的链域将线性表的n个结点按其逻辑顺序链接在一起的，每个结点只有一个链域的链表称为单链表（Single Linked List）。
单链表头指针head和终端结点
单链表中每个结点的存储地址是存放在其前趋结点next域中，而开始结点无前趋，故应设头指针head指向开始结点。链表由头指针唯一确定，单链表可以用头指针的名字来命名。
终端结点无后继，故终端结点的指针域为空，即NULL。
单链表C语言结构定义
typedef char DataType; //假设结点的数据域类型为字符
typedef struct node{ //结点类型定义
DataType data; //结点的数据域
struct node *next;//结点的指针域
}ListNode;
typedef ListNode *LinkList;
ListNode *p;
LinkList head;
[1]
注意：
①LinkList和ListNode是不同名字的同一个指针类型（命名的不同是为了概念上更明确）
②*LinkList类型的指针变量head表示它是单链表的头指针
③ListNode类型的指针变量p表示它是指向某一结点的指针
单链表指针变量和结点变量
指针变量
结点变量
定义
在变量说明部分显式定义
在程序执行时，通过标准函数malloc生成
取值
非空时，存放某类型结点
实际存放结点各域内容的地址
操作方式
通过指针变量名访问
通过指针生成、访问和释放
①生成结点变量的标准函数
p=( ListNode *)malloc(sizeof(ListNode))；
//函数malloc分配一个类型为ListNode的结点变量的空间,并将其首地址放入指针变量p中
②释放结点变量空间的标准函数
free(p)；//释放p所指的结点变量空间
③结点分量的访问
利用结点变量的名字*p访问结点分量
方法一：(*p).data和(*p).next
方法二：p-﹥data和p-﹥next
④指针变量p和结点变量*p的关系
指针变量p的值——结点地址
结点变量*p的值——结点内容
(*p).data的值——p指针所指结点的data域的值
(*p).next的值——*p后继结点的地址
*((*p).next)——*p后继结点
[1]
注意：
① 若指针变量p的值为空（NULL），则它不指向任何结点。此时，若通过*p来访问结点就意味着访问一个不存在的变量，从而引起程序的错误。
② 有关指针类型的意义和说明方式的详细解释
可见，在链表中插入结点只需要修改指针。但同时，若要在第 i 个结点之前插入元素，修改的是第 i-1 个结点的指针。
因此，在单链表中第 i 个结点之前进行插入的基本操作为:
找到线性表中第i-1个结点，然后修改其指向后继的指针。
单链表的建立有头插法、尾插法两种方法。
单链表头插法
单链表是用户不断申请存储单元和改变链接关系而得到的一种特殊数据结构，将链表的左边称为链头，右边称为链尾。头插法建单链表是将链表右端看成固定的，链表不断向左延伸而得到的。头插法最先得到的是尾结点。
由于链表的长度是随机的，故用一个while循环来控制链表中结点个数。假设每个结点的值都大于O，则循环条件为输入的值大于o。申请存储空间可使用malloc()函数实现，需设立一申请单元指针，但malloc()函数得到的指针并不是指向结构体的指针，需使用强制类型转换，将其转换成结构体型指针。刚开始时，链表还没建立，是一空链表，head指针为NULL。
链表建立的过程是申请空间、得到数据、建立链接的循环处理过程。
[2]
单链表尾插法
若将链表的左端固定，链表不断向右延伸，这种建立链表的方法称为尾插法。尾插法建立链表时，头指针固定不动，故必须设立一个搜索指针，向链表右边延伸，则整个算法中应设立三个链表指针，即头指针head、搜索指针p2、申请单元指针pl。尾插法最先得到的是头结点。
[2]
链表操作中动态存储分配要使用标准函数，先介绍一下这些函数。
(1)malloc(size)
在内存的动态存储区申请一个长度为size字节的连续空间。
(2)calloc(n，size)
在内存的动态存储区申请n个长度为size字节的连续空间，函数返回值为分配空间的首地址。若此函数未被成功执行，函数返回值为0。
(3)free(p)
释放由指针p所指向的存储单元，而存储单元的大小是最近一次调用malloc()或calloc()函数时所申请的存储空间。
在头文件\"stdlib．h”中包含了这些函数的信息，使用这些函数时需在程序开头用文件包含指令#include“stdlib．h”指明。
调用动态存储分配函数返回的指针是指向void类型或char类型的指针，在具体使用时，要根据所指向的数据进行强制类型转换。
线性表的双向链表存储结构：
typedef struct DuLNode
{
ElemType data;
struct DuLNode *prior,*next;
}DuLNode,*DuLinkList;
带头结点的双向循环链表的基本操作：
void InitList(DuLinkList L)
{ /* 产生空的双向循环链表L */
L=(DuLinkList)malloc(sizeof(DuLNode));
if(L)
L->next=L->prior=L;
else
exit(OVERFLOW);
}
销毁双向循环链表L：
void DestroyList(DuLinkList L)
{
DuLinkList q,p=L->next; /* p指向第一个结点 */
while(p!=L) /* p没到表头 */
{
q=p->next;
free(p);
p=q;
}
free(L);
L=NULL;
}
重置链表为空表：
void ClearList(DuLinkList L) /* 不改变L */
{ 　DuLinkList q,p=L->next; /* p指向第一个结点 */
while(p!=L) /* p没到表头 */
{
q=p->next;
free(p);
p=q;
}
L->next=L->prior=L; /*头结点的两个指针域均指向自身 */
}
验证是否为空表
[1] 
：
Status ListEmpty(DuLinkList L)
{ /* 初始条件：线性表L已存在
if(L->next==L&&L->prior==L)
return TRUE;
else
return FALSE;
}
计算表内元素个数
int ListLength(DuLinkList L)
{ /* 初始条件：L已存在。操作结果： */
int i=0;
DuLinkList p=L->next; /* p指向第一个结点 */
while(p!=L) /* p没到表头 */
{
i++;
p=p->next;
}
return i;
}
赋值：
Status GetElem(DuLinkList L,int i,ElemType *e)
{ /* 当第i个元素存在时，其值赋给e并返回OK，否则返回ERROR */
int j=1; /* j为计数器 */
DuLinkList p=L->next; /* p指向第一个结点 */
while(p!=L&&j<i)
{
p=p->next;
j++;
}
if(p==L||j>i) /* 第i个元素不存在 */
return ERROR;
*e=p->data; /* 取第i个元素 */
return OK;
}
查找元素：
int LocateElem(DuLinkList L,ElemType e,Status(*compare)(ElemType,ElemType))
{ /* 初始条件：L已存在，compare()是数据元素判定函数 */
/* 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。 */
/* 若这样的数据元素不存在，则返回值为0 */
int i=0;
DuLinkList p=L->next; /* p指向第1个元素 */
while(p!=L)
{
i++;
if(compare(p->data,e)) /* 找到这样的数据元素*/
return i;
p=p->next;
}
return 0;
}
查找元素前驱：
Status PriorElem(DuLinkList L,ElemType cur_e,ElemType *pre_e)
{ /* 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱， */
/* 否则操作失败，pre_e无定义 */
DuLinkList p=L->next->next; /* p指向第2个元素 */
while(p!=L) /* p没到表头 */
{
if(p->data==cur_e)
{
*pre_e=p->prior->data;
return TRUE;
}
p=p->next;
}
return FALSE;
}
查找元素后继：
Status NextElem(DuLinkList L,ElemType cur_e,ElemType *next_e)
{ /* 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继， */
/* 否则操作失败，next_e无定义 */
DuLinkList p=L->next->next; /* p指向第2个元素 */
while(p!=L) /* p没到表头 */
{
if(p->prior->data==cur_e)
{
*next_e=p->data;
return TRUE;
}
p=p->next;
}
return FALSE;
}
查找元素地址：
DuLinkList GetElemP(DuLinkList L,int i) /* 另加 */
{ /* 在双向链表L中返回第i个元素的地址。i为0，返回头结点的地址。若第i个元素不存在，*/
/* 返回NULL */
int j;
DuLinkList p=L; /* p指向头结点 */
if(i<0||i>ListLength(L)) /* i值不合法 */
return NULL;
for(j=1;j<=i;j++)
p=p->next;
return p;
}
元素的插入：
Status ListInsert(DuLinkList L,int i,ElemType e)
{ /* 在带头结点的双链循环线性表L中第i个位置之前插入元素e，i的合法值为1≤i≤表长+1 */
/* 改进算法2.18，否则无法在第表长+1个结点之前插入元素 */
DuLinkList p,s;
if(i<1||i>ListLength(L)+1) /* i值不合法 */
return ERROR;
p=GetElemP(L,i-1); /* 在L中确定第i个元素前驱的位置指针p */
if(!p) /* p=NULL,即第i个元素的前驱不存在(设头结点为第1个元素的前驱) */
return ERROR;
s=(DuLinkList)malloc(sizeof(DuLNode));
if(!s)
return OVERFLOW;
s->data=e;
s->prior=p; /* 在第i-1个元素之后插入 */
s->next=p->next;
p->next->prior=s;
p->next=s;
return OK;
}
元素的删除：
Status ListDelete(DuLinkList L,int i,ElemType *e)
{ /* 删除带头结点的双链循环线性表L的第i个元素，i的合法值为1≤i≤表长 */
DuLinkList p;
if(i<1) /* i值不合法 */
return ERROR;
p=GetElemP(L,i); /* 在L中确定第i个元素的位置指针p */
if(!p) /* p=NULL,即第i个元素不存在 */
return ERROR;
*e=p->data;
p->prior->next=p->next;
p->next->prior=p->prior;
free(p);
return OK;
}
正序查找
[1] 
：
void ListTraverse(DuLinkList L,void(*visit)(ElemType))
{ /* 由双链循环线性表L的头结点出发，正序对每个数据元素调用函数visit() */
DuLinkList p=L->next; /* p指向头结点 */
while(p!=L)
{
visit(p->data);
p=p->next;
}
printf("\n");
}
void ListTraverseBack(DuLinkList L,void(*visit)(ElemType))
逆序查找：
{ /* 由双链循环线性表L的头结点出发，逆序对每个数据元素调用函数visit()。另加 */
DuLinkList p=L->prior; /* p指向尾结点 */
while(p!=L)
{
visit(p->data);
p=p->prior;
}
printf("\n");
}
/*****************************************************
*文件名：LinkedList.h
*功能：实现双向链表的基本功能
*注意：为了使最终程序执行得更快，仅在Debug模式下检测操作合法性。
*另外不对内存分配失败作处理,因为一般情况下应用程序有近2GB真正可用的空间
*********************************************************/
#pragma once
#include <assert.h>
template<class T>
class LinkedList
{
private:
class Node
{
public:
T data; //数据域,不要求泛型T的实例类有无参构造函数
Node* prior; //指向前一个结点
Node* next; //指向下一个结点
Node(const T& element,Node*& pri,Node*& nt):data(element),next(nt),prior(pri){}
Node():data(data){}//泛型T的实例类的复制构造函数将被调用.在Vc2010测试可行
};
Node* head; //指向第一个结点
public:
//初始化：构造一个空结点，搭建空链
LinkedList():head(new Node()){head->prior=head->next=head;}
//获取元素总数
int elementToatal()const;
//判断是否为空链
bool isEmpty()const{return head==head->next?true:false;}
//将元素添加至最后，注意node的指针设置
void addToLast(const T& element){Node* ne=new Node(element,head->prior,head);head->prior=head->prior->next=ne;}
//获取最后一个元素
T getLastElement()const{assert(!isEmpty());return head->prior->data;}
//删除最后一个元素，注意node的指针设置
void delLastElement(){assert(!isEmpty());Node* p=head->prior->prior;delete head->prior;head->prior=p;p->next=head;}
//修改最后一个元素
void alterLastEmlent(const T& newElement){assert(!isEmpty());head->prior->data=newElement;}
//插入元素
void insertElement(const T& element,int position);
//获取元素
T getElement(int index)const;
//删除元素
T delElement(int index);
//修改元素
void alterElement(const T & Newelement,int index);
//查找元素
int findElement(const T& element) const;
//正序遍历
void Traverse(void (*visit)(T&element));
//逆序遍历
void TraverseBack(void (*visit)(T&element));
//重载[]函数
T& operator [](int index);
//清空链表
void clearAllElement();
//销毁链表
~LinkedList();
};
/***************************************
*返回元素总数
****************************************/
template<class T>
int LinkedList<T>::elementToatal()const
{
int Total=0;
for(Node* p=head->next;p!=head;p=p->next) ++Total;
return Total;
}
/**********************************************
*在position指定的位置插入元素。原来position及后面的元
*素后移
***********************************************/
template<class T>
void LinkedList<T>::insertElement(const T& element,int position)
{
assert(position>0 && position<=elementToatal()+1);
Node* p=head;
while(position)
{
p=p->next;
position--;
}
//此时p指向要插入的结点
Node* pNew=new Node(element,p->prior,p);
p->prior=p->prior->next=pNew;
}
/***************************************
*返回找到的元素的副本
***************************************/
template<class T>
T LinkedList<T>::getElement(int index)const
{
assert(index>0 && index<=elementToatal() && !isEmpty());//位置索引是否合法,链表是否空
Node* p=head->next;
while(--index) p=p->next;
return p->data;
}
/**********************************
*删除指定元素，并返回它
**********************************/
template<class T>
T LinkedList<T>::delElement(int index)
{
assert(index>0 && index<=elementToatal() && !isEmpty());//位置索引是否合法,链表是否空
Node* del=head->next;
while(--index) del=del->next;
//此时p指向要删除元素
del->prior->next=del->next;
del->next->prior=del->prior;
T delData=del->data;
delete del;
return delData;
}
/****************************************
*用Newelement代替索引为index的元素
*****************************************/
template<class T>
void LinkedList<T>::alterElement(const T & Newelement,int index)
{
assert(index>0 && index<=elementToatal() && !isEmpty());//位置索引是否合法,链表是否空
Node* p=head->next;
while(--index) p=p->next;
p->data=Newelement;
}
/********************************
*找到返回元素的索引，否则返回0
********************************/
template<class T>
int LinkedList<T>::findElement(const T& element) const
{
Node* p=head->next;
int i=0;
while(p!=head)
{
i++;
if(p->data==element) return i;
p=p->next;
}
return 0;
}
/***************************************
*正向遍历，以链表中每个元素作为参数调用visit函数
*****************************************/
template<class T>
void LinkedList<T>::Traverse(void (*visit)(T&element))
{
Node* p=head->next;
while(p!=head)
{
visit(p->data);//注意此时外部visit函数有权限修改LinkedList<T>的私有数据
p=p->next;
}
}
/*************************************************
*反向遍历，以链表中每个元素作为参数调用visit函数
*************************************************/
template<class T>
void LinkedList<T>::TraverseBack(void (*visit)(T&element))
{
Node* p=head->prior;
while(p!=head)
{
visit(p->data);//注意此时外部visit函数有权限修改LinkedList<T>的私有数据
p=p->prior;
}
}
/**************************************************
*返回链表的元素引用，并可读写.实际上链表没有[]意义上的所有功能
*因此[]函数是有限制的.重载它是为了客户端代码简洁，因为从链表读写
*数据是最常用的
***************************************************/
template<class T>
T& LinkedList<T>::operator [](int index)
{
assert(index>0 && index<=elementToatal() && !isEmpty());//[]函数使用前提条件
Node* p=head->next;
while(--index) p=p->next;
return p->data;
}
/***************************
*清空链表
***************************/
template<class T>
void LinkedList<T>::clearAllElement()
{
Node* p=head->next,*pTemp=0;
while(p!=head)
{
pTemp=p->next;
delete p;
p=pTemp;
}
head->prior=head->next=head;//收尾工作
}
/******************************
*析构函数，若内存足够没必要调用该函数
*******************************/
template<class T>
LinkedList<T>::~LinkedList()
{
if(head)//防止用户显式析构后，对象又刚好超出作用域再调用该函数
{
clearAllElement();
delete head;
head=0;
}
}
循环链表是一种链式存储结构，它的最后一个结点指向头结点，形成一个环。因此，从循环链表中的任何一个结点出发都能找到任何其他结点。循环链表的操作和单链表的操作基本一致，差别仅仅在于算法中的循环条件有所不同。
[1]
数据项可以是字母、数字或两者的组合。通过数据类型（逻辑的、数值的、字符的等）及数据长度来描述。数据项用来描述实体的某种属性。在地理信息系统中，数据项描述对象是地理实体各要素及其属性，分为几何属性（地理位置和形状）和非几何属性，包括标量属性（各种量测值）和名称属性（地名及地物名）等。
数据项计算机数据
数据（Data）：数据是信息的载体。它能够被计算机识别、存储和加工处理，是计算机程序加工的"原料"。随着计算机应用领域的扩大。
数据的范畴包括：整数、实数、字符串、图像和声音等。
数据项软道语录
数据项：数据项（Data Item）是powerdesigner中提供的属性模板。
数据项数据元素概念
数据元素（Data Element）是数据的基本单位。数据元素也称元素、结点、顶点、记录。一个数据元素可以由若干个数据项（也可称为字段、域、属性）组成。
数据（data）是对客观事物的符号表示，是用于表示客观事物的未经加工的原始素材，如图形符号、数字、字母等。或者说，数据是通过物理观察得来的事实和概念，是关于现实世界中的地方、事件、其他对象或概念的描述。
数据项计算机数据元素
在计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的符号的介质的总称，是用于输入电子计算机进行处理，具有一定意义的数字、字母、符号和模拟量等的通称。是组成地理信息系统的最基本要素。
性质分类
种类很多，按性质分为：
①定位的，如各种坐标数据；
②定性的，如表示事物属性的数据（居民地、河流、道路等）；
③定量的，反映事物数量特征的数据，如长度、面积、体积等几何量或重量、速度等物理量；④定时的，反映事物时间特性的数据，如年、月、日、时、分、秒等。
表现形式分类
按表现形式分为：
①数字数据，如各种统计或量测数据；
②模拟数据，由连续函数组成，又分为图形数据（如点、线、面）、符号数据、文字数据和图像数据等。按记录方式分为地图、表格、影像、磁带、纸带。按数字化方式分为矢量数据、格网数据等。在地理信息系统中，数据的选择、类型、数量、采集方法、详细程度、可信度等，取决于系统应用目标、功能、结构和数据处理、管理与分析的要求。
树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树形象表示。树在计算机领域中也得到广泛应用，如在编译源程序如下时，可用树表示源源程序如下的语法结构。又如在数据库系统中，树型结构也是信息的重要组织形式之一。一切具有层次关系的问题都可用树来描述。
一棵树（tree）是由n（n>0）个元素组成的有限集合，其中：
（1）每个元素称为结点（node）；
（2）有一个特定的结点，称为根结点或根（root）；
（3）除根结点外，其余结点被分成m（m>=0）个互不相交的有限集合，而每个子集又都是一棵树（称为原树的子树）
树结构度
树的度——也即是宽度，简单地说，就是结点的分支数。以组成该树各结点中最大的度作为该树的度，如上图的树，其度为3;树中度为零的结点称为叶结点或终端结点。树中度不为零的结点称为分枝结点或非终端结点。除根结点外的分枝结点统称为内部结点。
树结构深度
树的深度——组成该树各结点的最大层次，如上图，其深度为4；
树结构层次
根结点的层次为1，其他结点的层次等于它的父结点的层次数加1.
树结构路径
对于一棵子树中的任意两个不同的结点，如果从一个结点出发，按层次自上而下沿着一个个树枝能到达另一结点，称它们之间存在着一条路径。可用路径所经过的结点序列表示路径，路径的长度等于路径上的结点个数减1.
树结构森林
指若干棵互不相交的树的集合
树结构父亲数组
设T是一棵树，表示T的一种最简单的方法是用一个一维数组存储每个结点，数组的下标就是结点的位置指针，每个结点中有一个指向各自的父亲结点的数组下标的域，这样可使Parent操作非常方便。类型定义如下：
Type
TPosition=integer; {结点的位置类型为整型}
NodeType=Record
Label:LabelType; {该结点的标号}
Parent:TPosition; {该结点的父亲的数组下标，对于根结点该域为0}
End;
TreeType=Record
NodeCount:integer; {树的结点的总数目}
Node:Array [1..MaxNodeCount] of NodeType;{存储树的结点}
End;
由于树中每个结点的父亲是唯一的，所以上述的父亲数组表示法可以唯一地表示任何一棵树。在这种表示法下，寻找一个结点的父结点只需要O(1)时间。在树中可以从一个结点出发找出一条向上延伸到达其祖先的道路，即从一个结点到其父亲，再到其祖父等等。求这样的道路所需的时间正比于道路上结点的个数。在树的父亲数组表示法中，对于涉及查询儿子和兄弟信息的树操作，可能要遍历整个数组。为了节省查询时间，可以规定指示儿子的数组下标值大于父亲的数组下标值，而指示兄弟结点的数组下标值随着兄弟的从左到右是递增的。
树结构儿子链表
树的另一种常用的表示方法就是儿子链表表示法。这种表示法用一个线性表来存储树的所有结点信息，称为结点表。对每个结点建立一个儿子表。儿子表中只存储儿子结点的地址信息，可以是指针，数组下标甚至内存地址。由于每个结点的儿子数目不定，因此儿子表常用单链表来实现，因此这种表示法称为儿子链表表示法。这种实现法与图的邻接表表示法类似。下图是一个儿子链表表示法的示意图。
图3 树的儿子链表实现
图3中儿子链表结构表示的树如图4所示，树中各结点存放于一个数组实现的表中，数组下标作为各结点的指针。每一个数组元素（即每一个结点）含有一个儿子表，在图3中儿子表是用单链表来实现的，当然也可以用其他表的实现方式来实现儿子表，比如说游标方式(静态链表)。但由于每个结点的儿子数目不确定，所以一般不用数组来实现儿子表，但可以用数组来实现结点表，就如图3所示。在图3中可以看到，位于结点表第一个位置的结点(未必是根结点)有两个儿子结点，从左到右的两个儿子结点分别位于结点表的第2和第3个位置。因为图3中的结点表用数组实现，所以结点的标号就是结点在结点表中的数组下标。如图4所示。
图4 图3中儿子链表所表示的树
为了指明树的根结点的位置，我们可以用一个变量Root记录根结点在结点表中的位置。有了根结点的位置，就可以利用儿子表依次找到树中所有的结点。
儿子链表表示的树的类型定义如下：
Type
{======================
NodeListType是一个元素为NodeType类型的线性表，其位置类型为TPosition，
NodeListType定义了结点表的类型；
ChildrenListType是一个元素为TPosition类型的线性表， ChildrenListType定义了儿子表的类型
=======================}
TPosition=....
ChildrenListType=...
NodeType=Record {结点的类型}
Label:LabelType; {结点的标号}
Children:ChildrenListType;{结点的儿子表}
End;
NodeListType=...
TreeType=record
root:TPosition; {记录树根在结点表中的位置}
Node:NodeListType; {结点表}
end;
其中NodeListType是一个元素为NodeType类型的线性表，其位置类型为TPosition，NodeListType定义了结点表的类型；ChildrenListType是一个元素为TPosition类型的线性表， ChildrenListType定义了儿子表的类型。以上类型定义并不考虑表的具体实现方式，如果假设结点表和儿子表都用单链表实现，则类型定义可以具体实现如下：
{儿子链表实现树的类型定义的一个具体实例，结点表和儿子表都用单链表实现}
Type
TPosition=^NodeType; {结点表的位置类型}
ChildrenNodeType=record {儿子表的结点项的类型}
child:TPosition; {指向儿子结点的位置指针}
next:^ChildrenNodeType; {指向下一个儿子表项的指针}
end;
NodeType=Record {结点的类型定义为单链表}
Label:LabelType; {结点的标号}
Children:^ChildrenNodeType;{指向儿子表的指针}
Next:TPosition;
End;
TreeType=^NodeType; {树的类型定义为结点指针类型}
注意以上的定义只是一种具体情况，实际应用中结点表和儿子表可能用数组、链表等任何一种表的实现方式实现。
树结构左儿子右兄弟
树的左儿子右兄弟表示法又称为二叉树表示法或二叉链表表示法。每个结点除了data域外，还含有两个域，分别指向该结点的最左儿子和右邻兄弟。这种表示法常用二叉链表实现，因此又称为二叉链表表示法。但是实际应用中常用游标(静态链表)来代替链表，请参见表的游标实现。
若用指针实现，其类型定义为：
Type
TPosition=^NodeType;
NodeType=record
Label:LabelType;
Leftmost_Child,Right_Sibling:TPosition;
end;
TreeType=TPosition;
若用游标实现，其类型定义为:
Type
TPosition=integer;
NodeType=record
Label:LabelType;
Leftmost_Child,Right_Sibling:TPosition;
end;
CellspaceType=array [1..MaxNodeCount] of NodeType;
TreeType=TPosition;
var
Cellspace:CellspaceType;
Tree:TreeType;
此时树类型TreeType是整数类型，它指示树根在cellspace中的游标。例如图5(a)中树的左儿子右兄弟表示法的指针和游标实现分别如图5(b)和(c)所示。
(a)
(b)
(c)
图5 树的左儿子右兄弟表示法
用树的左儿子右兄弟表示法可以直接实现树的大部分操作，只有在对树结点作Parent操作时需遍历树。如果要反复执行Parent操作，可在结点记录中再开辟一个指向父结点的指针域，也可以利用最右儿子单元中的Right_Sibling作为指向父结点的指针(否则这里总是空指针)。当执行Parent(v)时，可以先通过Right_Sibling逐步找出结点v的最右兄弟，再通过最右兄弟的Right_Sibling(父亲指针)找到父结点。这个结点就是结点v的父亲。在这样的表示法下，求一个结点的父亲所需要的时间正比于该结点右边的兄弟个数。不过，这时每个记录中需要多用一位(bit)空间，用以标明该记录中的right_sibling是指向右邻兄弟还是指向父亲。
考虑到对于现在的计算机，内存已经不是很重要的限制因素了。我们下面就采取增加一个parent域的方案，以改进左儿子右兄弟表示法中Parent操作的效率。因此重新定义树的类型如下：
若用指针实现，其类型定义为：
Type
TPosition=^NodeType;
NodeType=record
Label:LabelType;
Parent,Leftmost_Child,Right_Sibling:TPosition; {增加一个Parent域}
end;
TreeType=TPosition;
var
Tree:TreeType;
若用游标实现，其类型定义为:
Type
TPosition=integer;
NodeType=record
Label:LabelType;
Parent,Leftmost_Child,Right_Sibling:TPosition; {增加一个Parent域}
end;
CellspaceType=array [1..MaxNodeCount] of NodeType;
TreeType=TPosition;
var
Cellspace:CellspaceType;
Tree:TreeType;
树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的系统的访问，即依次对树中每个结点访问一次且仅访问一次。树的3种最重要的遍历方式分别称为前序遍历、中序遍历和后序遍历。以这3种方式遍历一棵树时，若按访问结点的先后次序将结点排列起来，就可分别得到树中所有结点的前序列表，中序列表和后序列表。相应的结点次序分别称为结点的前序、中序和后序。
树的这3种遍历方式可递归地定义如下：
§ 如果T是一棵空树，那么对T进行前序遍历、中序遍历和后序遍历都是空操作，得到的列表为空表。
§ 如果T是一棵单结点树，那么对T进行前序遍历、中序遍历和后序遍历都只访问这个结点。这个结点本身就是要得到的相应列表。
§ 否则，设T如图6所示，它以n为树根，树根的子树从左到右依次为T1,T2,..,Tk，那么有：
§ 对T进行前序遍历是先访问树根n,然后依次前序遍历T1,T2,..,Tk。
§ 对T进行中序遍历是先中序遍历T1，然后访问树根n，接着依次对T2,T2,..,Tk进行中序遍历。
§ 对T进行后序遍历是先依次对T1,T2,..,Tk进行后序遍历，最后访问树根n。
树结构二叉排序树
排序是一种十分重要的运算。所谓排序就是把一堆杂乱无章的元素按照某种次序排列起来，形成一个线性有序的序列。二叉排序树是利用二叉树的结构特点来实现对元素排序的。
一、二叉排序树的定义
二叉排序树或者是空树，或者是具有如下性质的二叉树：
1、左子树上所有结点的数据值均小于根结点的数据值；
2、右子树上所有结点的数据值均大于或等于根结点的数据值；
3、左子树、右子树本身又各是一棵二叉排序树。
由此可见，二叉排序树是一种特殊结构的二叉树。（18（10（3，15（12，15）），21（20，21（，37））））就是一棵二叉排序树。
二、二叉排序树的构造
二叉排序树的构造过程实质上就是排序的过程，它是二叉排序树作媒介，将一个任意的数据序列变成一个有序序列。二叉排序树的构造一般是采用陆续插入结点的办法逐步构成的。具体构造的思路是：
1、以待排序的数据的第一个数据构成根结点；
2、对以后的各个数据，逐个插入结点，而且规定：在插入过程的每一步，原有树结点位置不再变动，只是将新数据的结点作为一个叶子结点插入到合适的位置，使树中任何结点的数据与其左、右子树结点数据之间的关系仍然符合对二叉排序树的要求。
树结构Huffman树
一、哈夫曼树的含义：哈夫曼树是一种带权路径长度最短的树。
所谓路径长度就是某个端结点到树的根结点的距离，等于该端结点的祖先数，或该结点所在层数减1，用lk表示。二叉树中每个端结点对应的一个实数称为该结点的权，用Wk表示。我们定义各端结点的权Wk与相应的路径程度lk乘积的代数和为该二叉树的带权路径长度，用WPL表示，即：
可以证明，哈夫曼树是最优二叉树。如给定权值{5，4，7，2，3}，可以生成很多棵二叉树，其中的（A（B（7，5），C（4，D（3，2））））是哈夫曼树。
二、哈夫曼树的构造
1、哈夫曼算法：
（1）根据给定的n个权值{W1，W2，…，Wn}构成n棵二叉树的森林：F{T1，T2，…，Tn}。其中每棵二叉树Ti只有一个带权为Wi的根结点，其左右子树为空。
（2）在F中选取两棵结点的权值最小的树作为左右子树构成一棵新的二叉树，且置新的二叉树的根结点的权值为其左右子树上根结点的权值之和。
（3）在F中删除这两棵树，同时，将新得到的二叉树加入F中。
（4）重复（2）、（3），直到F只含一棵树为止。最后的这棵树便是哈夫曼树。
2、算法描述
为了上述算法，选用数组型的链表作为存储结构，其类型设计如下：
Type tnode=RECORD
weight：real；
Lc，Rc：integer；
END；
tree=ARRAY[1..2*n-1] of tnode;
node=RECORD
weight：real；
adr：integer；
END；
A=ARRAY[1..n] of node;
下面是在这个存储结构上实现的构造哈夫曼树的算法：
Procedure Huffmantree（VAR W：ARRAY[1..n]OF real;VAR TR:tree）；
VAR AT:A;
BENGIN
FOR i:=1 TO n DO{实现第(1)步}
BEGIN
TR[i].weight:=W[i];{将权值放在树叶中}
TR[i].Lc：=0；
TR[i].Rc：=0；
AT[i].weight:=TR[i].weight;{用AT存放当前森林的根}
AT[i].adr:=i;
END;
num:=n;{森林中结点个数}
K:=num+1;{形成的新结点在TR数组中的位置}
WHILE (num>=2) DO {重复实现第(2)、(3)步}
BEGIN
SORTING(AT,num);{按根值大小对森林中的树进行升序排列}
TR[k].weight:=AT[1].weight+AT[2].weight;
{选择两棵结点权值最小的树构造新二叉树}
TR[k].Lc:=AT[1].adr; {左子树：权值最小的树}
TR[k].Rc:=AT[2].adr; {右子树：权值次小的树}
AT[1].weight:=TR[k].weight; {新树赋予第一}
AT[1].adr:=k; {新树结点标号}
AT[2].weight:=AT[num].weight;{原最后树赋予第二}
AT[2].adr:=AT[num].adr; {跟进结点标号}
num:=num-1; {删除原最后树}
k:=k+1; {增加结点标号}
END;
END;
三、应用：哈夫曼编码
利用哈夫曼树构造的用于通信的二进制编码，称为哈夫曼编码。
例如，有一段电文‘CAST TAT A SA’，统计电文中字母的频度，f('C')=1,f('S')=2,f('T')=3,f(' ')=3,f('A')=4，可用其频度{1，2，3，3，4}为权值生成Huffman树，并在每个叶子上注明对应的字符。树中从根到每个叶子都有一条路径，若对路径上的各分支进行约定，指向左子树根的分支用“0”码表示，指向右子树根的分支用“1”码表示，再取每条路径上的“0”或“1”的序列作为与各个叶子对应的字符的编码，这就是哈夫曼编码。
二叉树是一类非常重要的树形结构，它可以递归地定义如下：
二叉树T是有限个结点的集合，它或者是空集，或者由一个根结点u以及分别称为左子树和右子树的两棵互不相交的二叉树u(1)和u(2)组成。若用n,n1和n2分别表示T，u(1)和u(2)的结点数，则有n=1+n1+n2 。u(1)和u(2)有时分别称为T的第一和第二子树。
因此，二叉树的根可以有空的左子树或空的右子树，或者左、右子树均为空。
二叉树具有以下的重要性质：
高度为h≥0的二叉树至少有h+1个结点； 高度不超过h(≥0)的二叉树至多有2h+1-1个结点； 含有n≥1个结点的二叉树的高度至多为n-1； 含有n≥1个结点的二叉树的高度至少为 logn ，因此其高度为Ω(logn)。 详见二叉树词条。
最短路径问题是图论研究中的一个经典算法问题， 旨在寻找图（由结点和路径组成的）中两结点之间的最短路径。 算法具体的形式包括：
确定起点的最短路径问题 - 即已知起始结点，求最短路径的问题。
[1]
确定终点的最短路径问题 - 与确定起点的问题相反，该问题是已知终结结点，求最短路径的问题。在无向图中该问题与确定起点的问题完全等同，在有向图中该问题等同于把所有路径方向反转的确定起点的问题。
确定起点终点的最短路径问题 - 即已知起点和终点，求两结点之间的最短路径。
全局最短路径问题 - 求图中所有的最短路径。
综述
用于解决最短路径问题的算法被称做“最短路径算法”， 有时被简称作“路径算法”。 最常用的路径算法有：
Dijkstra算法
SPFA算法\Bellman-Ford算法
Floyd算法\Floyd-Warshall算法
Johnson算法
A*算法
所谓单源最短路径问题是指：已知图G=（V，E），我们希望找出从某给定的源结点S∈V到V中的每个结点的最短路径。
[1]
首先，我们可以发现有这样一个事实：如果P是G中从vs到vj的最短路，vi是P中的一个点，那么，从vs沿P到vi的路是从vs到vi的最短路。
Dijkstra算法（迪杰斯特拉）是典型的最短路径路由算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。可以用堆优化。
Dijkstra算法是很有代表性的最短路算法，在很多专业课程中都作为基本内容有详细的介绍，如数据结构，图论，运筹学等等。
Dijkstra一般的表述通常有两种方式，一种用永久和临时标号方式，一种是用OPEN, CLOSE表方式，Drew为了和下面要介绍的 A* 算法和 D* 算法表述一致，这里均采用OPEN,CLOSE表的方式。
其采用的是贪心法的算法策略
大概过程：
创建两个表，OPEN, CLOSE。
OPEN表保存所有已生成而未考察的节点，CLOSED表中记录已访问过的节点。
1． 访问路网中距离起始点最近且没有被检查过的点，把这个点放入OPEN组中等待检查。
2． 从OPEN表中找出距起始点最近的点，找出这个点的所有子节点，把这个点放到CLOSE表中。
3． 遍历考察这个点的子节点。求出这些子节点距起始点的距离值，放子节点到OPEN表中。
4． 重复第2和第3步,直到OPEN表为空，或找到目标点。
C++代码
#include<iostream>
#include<vector>
using namespace std;
void dijkstra(const int &beg,//出发点
              const vector<vector<int> > &adjmap,//邻接矩阵，通过传引用避免拷贝
              vector<int> &dist,//出发点到各点的最短路径长度
              vector<int> &path)//路径上到达该点的前一个点
//负边被认作不联通
//福利：这个函数没有用任何全局量，可以直接复制！
{
    const int &NODE=adjmap.size();//用邻接矩阵的大小传递顶点个数，减少参数传递
    dist.assign(NODE,-1);//初始化距离为未知
    path.assign(NODE,-1);//初始化路径为未知
    vector<bool> flag(NODE,0);//标志数组，判断是否处理过
    dist[beg]=0;//出发点到自身路径长度为0
    while(1)
    {
        int v=-1;//初始化为未知
        for(int i=0; i!=NODE; ++i)
            if(!flag[i]&&dist[i]>=0)//寻找未被处理过且
                if(v<0||dist[i]<dist[v])//距离最小的点
                    v=i;
        if(v<0)return;//所有联通的点都被处理过
        flag[v]=1;//标记
        for(int i=0; i!=NODE; ++i)
            if(adjmap[v][i]>=0)//有联通路径且
                if(dist[i]<0||dist[v]+adjmap[v][i]<dist[i])//不满足三角不等式
                {
                    dist[i]=dist[v]+adjmap[v][i];//更新
                    path[i]=v;//记录路径
                }
    }
}
int main()
{
    int n_num,e_num,beg;//含义见下
    cout<<"输入点数、边数、出发点：";
    cin>>n_num>>e_num>>beg;
    vector<vector<int> > adjmap(n_num,vector<int>(n_num,-1));//默认初始化邻接矩阵
    for(int i=0,p,q; i!=e_num; ++i)
    {
        cout<<"输入第"<<i+1<<"条边的起点、终点、长度（负值代表不联通）：";
        cin>>p>>q;
        cin>>adjmap[p][q];
    }
    vector<int> dist,path;//用于接收最短路径长度及路径各点
    dijkstra(beg,adjmap,dist,path);
    for(int i=0; i!=n_num; ++i)
    {
        cout<<beg<<"到"<<i<<"的最短距离为"<<dist[i]<<"，反向打印路径：";
        for(int w=i; path[w]>=0; w=path[w])
            cout<<w<<"<-";
        cout<<beg<<'\n';
    }
}
数据结构在计算机中的表示（映像）
数据库的物理结构文件按其作用可以分为三类：
数据文件
日志文件
控制文件
重做日志文件记录对数据库的所有修改信息。它是三类文件中最复杂的一类文件，也是保证数据库安全与数据库备份与恢复有直接关系的文件。
日志文件组与日志成员
在每一个oracle数据库中，至少有两个重做日志文件组。每组有一个个或多个重做日志文件，即日志成员。同一组中的成员是镜像关系，它们存储的内容是一模一样的。oracle在写日志时，以一个日志组为逻辑单位写入，只在将日志都写入日志组中的每个成员文件中后，写日志才完成。
日志工作原理
oracle有多个日志文件组，当一个日志文件组中所有的成员所有的成员同时被写满数据时，系统自动转换到下一个日志文件组，这个转换过程称为日志切换。
当日志切换后，会给前一个日志组编一个号，用于归档日志的编号，这个编号称为日志序列号。此编号由1开始，每切换一次，序列号自动加1，最大值受参数MAXLOGHISTORY限制，该参数的最大值为65534。
当oracle把最后一个日志组写满了以后，自动转向第一个日志组，这时,再向第一个日志组写日志的时候，如果数据库运行在非归档模式下，这个日志组中的原有日志信息就会被覆盖。
使用以下语句查询日志文件信息：
sql>select * from v$log
相关字段说明如下：
GROUP#:日志文件组号
THREAD#:日志文件线程号，一般为1,双机容时为2
SEQUENCE#:日志序列号
BYTES:日志文件大小
MEMBERS:该组的日志成员个数
ARC:该组日志信息是否已经完成归档
STATUS:该组状态（CURRENT:表示当前正在使用的组；NACTIVE:表示非活动组；ACTIVE:表示归档未完成）
FIRST_CHANGE#:系统改变号SCN，也叫检查点号
FIRST_TIME:系统改变时间
DBA可以使用下列命令进行强制日志切换
sql>alter system switch logfile
NOARCHIVELOG/ARCHIVELOG
NOARCHIVELOG是非归档模式，如果数据库运行在这种模式下，当日志切换时，新切换到的日志组中的日志信息会被覆盖。ARCHIVELOG:归档模式，如果数据库运行在这种模式下，日志会被归档存储，产生归档日志，且在未归档之前，日志不允许被覆盖写入。
要确认数据库的归档方式，可以查询数据字典v$database:
sql>select log_mode from v$database
要了解归档日志的信息，可以查询数据字典v$archived_log。
要将数据库改为归档模式：
a.alter database archivelog
b.设置初始化参数LOG_ARCHIVE_START=TRUE
c.设置归档文件目标存储路径 LOG_ARCHIVE_DEST=C:\ORA\ARCHIVE
d.设置归档文件命名格式参数 LOG_ARCHIVE_FORMAT="ORCK%T%S.ARC"。这个格式中的%S表示日志序列号，自动左边补零；%s表示日志序列号，自动左边不补零；%T表示日志线程号，左边补零；%t表示日志线程号不补零。
e.重新启动数据库
CKPT进程
CKPT进程保证有修改过的数据库缓冲区中的数据都被写入到数据文件，日志文件、数据文件、数据库头和控制文件中都有写入检查点标记。数据库在恢复时，只需提供自上一个检查以来所做的修改。检查点完成时系统将更新数据库数据库头和控制文件。
参数LOG_CHECKPOINT_TIMEOUT决定一个检查点发生的时间间隔。LOG_CHECKPOINT_INTERVAL决定一个检查需要填充的日志文件块的数量。检查点号，也称系统改变号(SCN)，它标识一个检查点。可以通过v$log查询日志文件的检查点信息，通过v$datafile查询数据文件的检查点信息，通过v$database查询数据库头的检查点信息。三个地方的检查点号相同，如果不同，说明发明数据库不同步，此时数据库肯定无法正常启动。
增加与删除日志文件组、日志成员
(详细语法请参考oracle文档)
alter database [database] add logfile [group integer] filespec[,[group...
alter database [database] add logfile (...)
alter database [database] drop logfile [grout integer]
alter database [database] add logfile member "filespec" [reuse] to group integer
alter database [database] drop logfile member "filename","filename"...
alter database [database] rename file "filename" to "filename"
清除日志文件数据
alter database [database] clear [unarchived] logfile group integer|filespec
控制文件是一个二进制文件，用来描述数据库的物理结构，一个数据库只需要一个控制文件，控制文件的内容包括：
数据库名及数据库唯一标识
数据文件和日志文件标识
数据库恢复所需的同步信息，即检查点号
控制文件由参数control_files指定，格式如下：
control_files=("home/app/.../control01.ctl","home/app/.../control02.ctl")
参数中各个文件是镜像关系，也就是说，几个文件中只要有一个文件完好，数据库就可以正常运行。
以下语句查询控制文件的信息：
sql>select * from v$controlfile
如果控制文件损坏或丢失，数据库将终止并且无法启动，所以，要对控制文件进行镜象，手工镜像步骤如下：
a.关闭数据库
b.复制控制文件
c.修改参数文件，加入新增的控制文件位置描述
d.重新启动数据库
另外注意，控制文件中还包含几个服务器参数的设置，如果修改这些参数的值，刚需要重新创建控制文件，这些参数是：
MAXLOGFILES:最大日志文件个数
MAXLOGMEMBERS:最大日志成员个数
MAXLOGHISTORY:最大历史日志个数
MAXDATAFILES:最大数据文件个数
MAXINSTANCES:最大实例文件个数
所有修改数据库结构的命令都会引起控制文件的改变。同时出会记录在oracle跟踪文件中，跟踪文件的名称为alter_SID.log，路径如下：
d:\oracle\product\10.1.0\admin\DB_NAME\bdump\SIDALRT.log(unix是alter_SID.ora)
也可以在参数文件中指定跟踪文件的存储路径，后台进程跟踪文件目录由参数background_dump_dest指定，用户跟踪文件位置由参数user_bdump_dest指定，如：
background_bdump_dest=/u01/app/oracle/oralog/bdump
user_bdump_dest=/u01/app//oralog/udump
数据文件用来存储数据库的数据，如表、索引等。读取数据时，系统首先从数据库文件中读取数据，并存储到SGA的数据缓冲区中。这是为了减少I/O，如果读取数据时，缓冲区中已经有要读取的数据，就不需要再从磁盘中读取了。存储数据时也是一样，事务提交时改变的数据先存储到内存缓冲区中，再由oracle后台进程DBWR决定如何将其写入到数据文件中。
查询数据文件的信息
sql>select * from dba_data_files或
sql>select * from v$datafile(此数据字典包含文件的动态信息)
一个数据文件只与一个数据库相联系。数据文件的大小是可以改变的。可以通过以下语句查询表空间的空间空闲量
sql>select * from dba_free_space
修改数据文件的大小
sql>alter database datafile "d:\...\df1.dbf" resize 800m
数据库文件的自动扩展特性
请看下面的例子:
sql>alter tablespace tbs1 add datafile "d:\...\df2.dbf" size 500m autoextend on next 50m maxsize 1000m
sql>alter database mydb1 datafile "d:\...\df2.dbf","d:\...\df3.dbf" autoexetend off
sql>alter database mydb1 datafile "d:\...\df2.dbf","d:\...\df3.dbf" autoexetend on next 30m maxsize unlimited
一棵深度为k且有2k-1个结点的二叉树称为满二叉树。
[2]
根据二叉树的性质2, 满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有2i-1个结点 (i≥1) 。
[2]
如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。
[2]
从满二叉树和完全二叉树的定义可以看出, 满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树。
[2]

1.具有n个结点的完全二叉树的深度为[Log2 n]+1;
[2]
2.如果对一棵有n个结点的完全二叉树的结点按层序编号, 则对任一结点i (1≤i≤n) 有:
[2]
(1) 如果i=1, 则结点i是二叉树的根, 无双亲;如果i>1, 则其双亲parent (i) 是结点[i/2].
[2]
(2) 如果2i>n, 则结点i无左孩子, 否则其左孩子lchild (i) 是结点2i;
[2]
(3) 如果2i+1>n, 则结点i无右孩子, 否则其右孩子rchild (i) 是结点2i+1.
[2]
完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。
[1]
完全二叉树算法思路
判断一棵树是否是完全二叉树的思路
[3]
1>如果树为空，则直接返回错　　2>如果树不为空：层序遍历二叉树　　2.1>如果一个结点左右孩子都不为空，则pop该节点，将其左右孩子入队列；　　2.1>如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树；　　2.2>如果遇到一个结点，左孩子不为空，右孩子为空；或者左右孩子都为空；则该节点之后的队列中的结点都为叶子节点；该树才是完全二叉树，否则就不是完全二叉树；
[3]
完全二叉树代码实现
#include <iostream>
#include <queue>

using namespace std;

template <class T>
struct TreeNode
{
    T data;
    TreeNode<T> *left;
    TreeNode<T> *right;
    TreeNode(const T &x) : data(x),
                           left(NULL),
                           right(NULL) {}
};
template <class T>
bool IsComplete(TreeNode<T> *root)
{
    //1.树为空，返回错误
    if (root == NULL)
    {
        return false;
    }
    //2.树不为空
    queue<TreeNode<T> *> q;
    q.push(root);
    while (!q.empty())
    {
        TreeNode<T> *top = q.front();
        //2.1如果该节点两个孩子都有，则直接pop
        if (top->left && top->right)
        {
            q.pop();
            q.push(top->left);
            q.push(top->right);
        }
        //2.2如果该节点左孩子为空，右孩子不为空，则一定不是完全二叉树
        if (top->left == NULL && top->right)
        {
            return false;
        }
        //2.3如果该节点左孩子不为空，右孩子为空或者该节点为叶子节点，则该节点之后的所有结点都是叶子节点
        if ((top->left && top->right == NULL) || (top->left == NULL && top->right == NULL))
        {
                        if (NULL != top->left && NULL == top->right) 
                        {
                            q.push(top->left);    
                        }
            q.pop(); //则该节点之后的所有结点都是叶子节点
            while (!q.empty())
            {
                top = q.front();
                if (top->left == NULL && top->right == NULL)
                {
                    q.pop();
                }
                else
                {
                    return false;
                }
            }
            return true;
        }
    }
    return true;
}

//满二叉树
void test1()
{
    //       1
    //   2       3
    // 4    5  6   7
    TreeNode<int> *node1 = new TreeNode<int>(1);
    TreeNode<int> *node2 = new TreeNode<int>(2);
    TreeNode<int> *node3 = new TreeNode<int>(3);
    TreeNode<int> *node4 = new TreeNode<int>(4);
    TreeNode<int> *node5 = new TreeNode<int>(5);
    TreeNode<int> *node6 = new TreeNode<int>(6);
    TreeNode<int> *node7 = new TreeNode<int>(7);
    node1->left = node2;
    node1->right = node3;
    node2->left = node4;
    node2->right = node5;
    node3->left = node6;
    node3->right = node7;
    cout << IsComplete<int>(node1) << endl;
}

//二叉树为空
void test2()
{
    cout << IsComplete<int>(NULL) << endl;
}

//3.二叉树不为空，也不是满二叉树，遇到一个结点左孩子为空，右孩子不为空
void test3()
{
    //       1
    //   2       3
    // 4    5      7
    TreeNode<int> *node1 = new TreeNode<int>(1);
    TreeNode<int> *node2 = new TreeNode<int>(2);
    TreeNode<int> *node3 = new TreeNode<int>(3);
    TreeNode<int> *node4 = new TreeNode<int>(4);
    TreeNode<int> *node5 = new TreeNode<int>(5);
    TreeNode<int> *node7 = new TreeNode<int>(7);
    node1->left = node2;
    node1->right = node3;
    node2->left = node4;
    node2->right = node5;
    node3->right = node7;
    cout << IsComplete<int>(node1) << endl;
}

//4.二叉树不为空，也不是满二叉树，遇到叶子节点,则该叶子节点之后的所有结点都为叶子节点
void test4()
{
    //        1
    //    2       3
    // 4    5
    TreeNode<int> *node1 = new TreeNode<int>(1);
    TreeNode<int> *node2 = new TreeNode<int>(2);
    TreeNode<int> *node3 = new TreeNode<int>(3);
    TreeNode<int> *node4 = new TreeNode<int>(4);
    TreeNode<int> *node5 = new TreeNode<int>(5);
    node1->left = node2;
    node1->right = node3;
    node2->left = node4;
    node2->right = node5;
    cout << IsComplete<int>(node1) << endl;
}

//4.二叉树不为空，也不是满二叉树，遇到左孩子不为空，右孩子为空的结点，则该节点之后的所有结点都为叶子节点
void test5()
{
    //        1
    //    2       3
    // 4    5   6
    TreeNode<int> *node1 = new TreeNode<int>(1);
    TreeNode<int> *node2 = new TreeNode<int>(2);
    TreeNode<int> *node3 = new TreeNode<int>(3);
    TreeNode<int> *node4 = new TreeNode<int>(4);
    TreeNode<int> *node5 = new TreeNode<int>(5);
    TreeNode<int> *node6 = new TreeNode<int>(6);
    node1->left = node2;
    node1->right = node3;
    node2->left = node4;
    node2->right = node5;
    node3->left = node6;
    cout << IsComplete<int>(node1) << endl;
}

int main()
{
    test1();
    /*test2();*/
    /*test3();*/
    /*test4();*/
    /*test5();*/
    return 0;
}
在无向图中，顶点所具有的边的数目称为顶点的度。如图1(a)中．无向图



的顶点



的度为3，顶点



的度为2。
在有向图中，以顶点为头的边的数目称为该顶点的入度；以顶点为尾的边的数目称为该顶点的出度；一个顶点的入度与出度之和称为该顶点的度。如图1中，有向图



的顶点



的入度为2，出度也是2，顶点



的度则为4。
图1（a）G₁
图1（b）G₂
设无向图



有



个顶点，e条边，每个顶点的度为



，则有
[2] 
：

出度图的定义
一个图由一个非空有限顶点集和一个边的有限集组成。图



的顶点集和边集分别用



和



表示，则图G可表示成



。
在图中，若每条边都用箭头指明了方向，则称此图为有向图，否则为无向图。有向图中的边用



表示，其中



是有向图的两个顶点，



称为尾，



称为头，在有向图中用从



到



的箭头表示，见图2(a)。无向图中的边用



表示，



为无向图的两个顶点。图2(b)是无向图。无向图的边



是无序的，也就是说



与



表示同一条边。
从图2中可知，(b)是一棵树，而(a)不是树，所以说树是图的特例。具有n个顶点的无向图，若有



条边，称之为完全图。图2中(c)便是一个完全图。具有n个顶点的无向图，至多有



条边；具有n个顶点的有向图，则至多有



条边
[2] 
。
出度子图
设图



的顶点集和边集为



和



，图



的顶点集和边集为



和



，若：
则称图



是图



的子图。例如，图2中图



是图



的子图，图



是图



的子图
[2] 
。
八皇后问题如果用穷举法需要尝试 88 =16,777,216 种情况。每一列放一个




八皇后问题(3张)



皇后，可以放在第 1 行，第 2 行，……，直到第 8 行。穷举的时候从所有皇后都放在第 1 行的方案开始，检验皇后之间是否会相互攻击。如果会，把列 H 的皇后挪一格，验证下一个方案。移到底了就 “进位” 到列 G 的皇后挪一格，列 H 的皇后重新试过全部的 8 行。如图 1 所示，这种方法无疑是非常低效率的，因为它并不是哪里有冲突就调整哪里，而是盲目地按既定顺序枚举所有的可能方案。
回溯算法优于穷举法。将列 A 的皇后放在第一行以后，列 B 的皇后放在第一行已经发生冲突。这时候不必继续放列 C 的皇后，而是调整列 B 的皇后到第二行，继续冲突放第三行，不冲突了才开始进入列 C。如此可依次放下列 A 至 E 的皇后，如图 2 所示。将每个皇后往右边横向、斜向攻击的点位用叉标记，发现列 F 的皇后无处安身。这时回溯到列 E 的皇后，将其位置由第 4 行调整为第 8 行，进入列 F，发现皇后依然无处安身，再次回溯列 E。此时列 E 已经枚举完所有情况，回溯至列 D，将其由第 2 行移至第 7 行，再进入列 E 继续。按此算法流程最终找到如图 3 所示的解，成功在棋盘里放下了 8 个 “和平共处” 的皇后。继续找完全部的解共 92 个。
回溯算法求解八皇后问题的原则是：有冲突解决冲突，没有冲突往前走，无路可走往回退，走到最后是答案。为了加快有无冲突的判断速度，可以给每行和两个方向的每条对角线是否有皇后占据建立标志数组。放下一个新皇后做标志，回溯时挪动一个旧皇后清除标志。以下给出回溯算法解八皇后问题的编程代码实现。
八皇后问题GO
package main
import "fmt"
func main() { 
    var balance = [8]int{0, 0, 0, 0, 0, 0, 0, 0} 
    queen(balance, 0)
}
func queen(a [8]int, cur int) {
    if cur == len(a) {
        fmt.Print(a)  
        fmt.Println()  
        return
    } 
    for i := 0; i < len(a); i++ {  
        a[cur] = i  
        flag := true  
        for j := 0; j < cur; j++ {   
            ab := i - a[j]   
            temp := 0   
            if ab > 0 {
                temp = ab   
            } else {    
                temp = -ab
            }
            if a[j] == i || temp == cur-j {
                flag = false    
                break  
            }
         }  
         if flag {   
             queen(a, cur+1)  
         }
    }
}
八皇后问题JS
function queen(a,cur){
    if(cur==a.length){console.log(a);return};
    for(var i=0;i<a.length;i++){
        a[cur]=i;
                var flag=true;
        for(var j=0;j<cur;j++){
            var ab=i-a[j];
            if(a[j]==i||(ab>0?ab:-ab)==cur-j){flag=false;break};
        };
        if(flag){queen(a,cur+1)};
    };
};
queen([1,1,1,1,1,1,1,1],0)
八皇后问题C++
#include<iostream>
using namespace std;
static int gEightQueen[8] = { 0 }, gCount = 0;
void print()//输出每一种情况下棋盘中皇后的摆放情况
{
    for (int i = 0; i < 8; i++)
    {   
        int inner;
        for (inner = 0; inner < gEightQueen[i]; inner++)
            cout << "0";
            cout <<"#";
        for (inner = gEightQueen[i] + 1; inner < 8; inner++)
            cout << "0";
        cout << endl;
    }
    cout << "==========================\n";
}
int check_pos_valid(int loop, int value)//检查是否存在有多个皇后在同一行/列/对角线的情况
{
    int index;
    int data;
    for (index = 0; index < loop; index++)
    {
        data = gEightQueen[index];
        if (value == data)
            return 0;
        if ((index + data) == (loop + value))
            return 0;
        if ((index - data) == (loop - value))
            return 0;
    }
    return 1;
}
void eight_queen(int index)
{
    int loop;
    for (loop = 0; loop < 8; loop++)
    {
        if (check_pos_valid(index, loop))
        {
            gEightQueen[index] = loop;
            if (7 == index)
            {
                gCount++, print();
                gEightQueen[index] = 0;
                return;
            }
            eight_queen(index + 1);
            gEightQueen[index] = 0;
        }
    }
}
int main(int argc, char*argv[])
{
    eight_queen(0);
    cout << "total=" << gCount << endl;
    return 0;
}
八皇后问题Pascal
program queen;
var
a:array[1..8]of longint;//记录皇后的行坐标
b,c,d:array[-7..16]of longint;//行，右上，右下斜线的占位标志
m,ans:longint;
procedure queen(j:longint);
var
i:longint;
begin
    if j>8 then
    begin
        inc(ans);//满足条件，找到一种方案
        exit;
    end;
    for i:=1 to 8 do//每个皇后位置有八种可能
        if(b[i]=0)and(c[i+j]=0)and(d[j-i]=0)then//如果位置没有被占则运行
        begin
            a[j]:=i;//皇后放置在此行
            b[i]:=1;//占领第i行
            c[i+j]:=1;//占领右上
            d[j-i]:=1;//占领右下
            queen(j+1);//递归
            b[i]:=0;//回溯，恢复行占位标志
            c[i+j]:=0;//回溯，恢复斜上方（右上）占位标志
            d[j-i]:=0;///回溯，恢复斜下方（右下）占位标志
        end;
end;
begin//主程序
    for m:=-7 to 16 do//数据初始化为0
    begin
        b[m]:=0;//行数据初始化为0
        c[m]:=0;//右上数据初始化为0
        d[m]:=0;//右下数据初始化为0
    end;
    ans:=0;
    queen(1);//开始放置第一个皇后
    writeln(ans);
end.
八皇后问题Java
public class Queen {
    private int[] column; //同栏是否有皇后，1表示有
    private int[] rup; //右上至左下是否有皇后
    private int[] lup; //左上至右下是否有皇后
    private int[] queen; //解答
    private int num; //解答编号

    public Queen() {
        column = new int[8+1];
        rup = new int[(2*8)+1];
        lup = new int[(2*8)+1];
        for (int i = 1; i <= 8; i++)
            column[i] = 0;
        for (int i = 1; i <= (2*8); i++)
            rup[i] = lup[i] = 0;  //初始定义全部无皇后
        queen = new int[8+1];
    }

    public void backtrack(int i) {
        if (i > 8) {
            showAnswer();
        } else {
            for (int j = 1; j <= 8; j++) {
                if ((column[j] == 0) && (rup[i+j] == 0) && (lup[i-j+8] == 0)) {
                    //若无皇后
                    queen[i] = j; //设定为占用
                    column[j] = rup[i+j] = lup[i-j+8] = 1;
                    backtrack(i+1);  //循环调用
                    column[j] = rup[i+j] = lup[i-j+8] = 0;
                }
            }
        }
    }

    protected void showAnswer() {
        num++;
        System.out.println("\n解答" + num);
        for (int y = 1; y <= 8; y++) {
            for (int x = 1; x <= 8; x++) {
                if(queen[y]==x) {
                    System.out.print("Q");
                } else {
                    System.out.print(".");
                }
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        Queen queen = new Queen();
        queen.backtrack(1);
    }
}
八皇后问题Erlang
-module(queen).
-export([printf/0, attack_range/2]).
-define(MaxQueen, 4).%寻找字符串所有可能的排列
%perms([]) ->% [[]];
%perms(L) ->% [[H | T] || H <- L, T <- perms(L -- [H])].
perms([]) ->[[]];
perms(L) ->[[H | T] || H <- L, T <- perms(L -- [H]), attack_range(H,T) == []].printf() ->L = lists:seq(1, ?MaxQueen),io:format("~p~n", [?MaxQueen]),perms(L).
%检测出第一行的数字攻击到之后各行哪些数字%left向下行的左侧检测%right向下行的右侧检测
attack_range(Queen, List) ->attack_range(Queen, left, List) ++ attack_range(Queen, right, List).attack_range(_, _, []) ->[];
attack_range(Queen, left, [H | _]) when Queen - 1 =:= H ->[H];
attack_range(Queen, right, [H | _]) when Queen + 1 =:= H ->[H];

attack_range(Queen, left, [_ | T]) ->attack_range(Queen - 1, left, T);attack_range(Queen, right, [_ | T]) ->attack_range(Queen + 1, right, T).
八皇后问题python
def queen(A, cur=0):
    if cur == len(A):
        print(A)
        return 0
    for col in range(len(A)):
        A[cur], flag = col, True
        for row in range(cur):
            if A[row] == col or abs(col - A[row]) == cur - row:
                flag = False
                break
        if flag:
            queen(A, cur+1)
queen([None]*8)
八皇后问题C#
using System;
using System.Collections.Generic;
namespace EightQueens_CSharp
{
    public class EightQueens
    {
        private List<int[]> solutions;
        public List<int[]> GetSolutions(int queenCount)
        {
            solutions = new List<int[]>();
            List<int> queenList = new List<int>();
            for (int i = 0; i < queenCount; i++)
            {
                queenList.Add(0);
            }
            putQueen(queenCount, queenList, 0);
            printSolutions(solutions);
            return solutions;
        }
        
        private void putQueen(int queenCount, List<int> queenList, int nextY)
        {
            for (queenList[nextY] = 0; queenList[nextY] < queenCount; queenList[nextY]++)
            {
                if (checkConflict(queenList, nextY) == false)
                {
                    nextY++;
                    if (nextY < queenCount)
                    {
                        putQueen(queenCount, queenList, nextY);
                    }
                    else
                    {
                        solutions.Add(queenList.ToArray());
                        Console.WriteLine(string.Join(", ", queenList));
                    }
                    nextY--;
                }
            }
        }
        
        private bool checkConflict(List<int> queenList, int nextY)
        {
            for (int positionY = 0; positionY < nextY; positionY++)
            {
                if (Math.Abs(queenList[positionY] - queenList[nextY]) == Math.Abs(positionY - nextY) || queenList[positionY] == queenList[nextY])
                {
                    return true;
                }
            }
            return false;
        }
        
        private void printSolutions(List<int[]> solutions)
        {
            int count = 0;
            foreach (var solution in solutions)
            {
                Console.WriteLine("Solution: {0}", count++);
                int queenCount = solution.Length;
                for (int i = 0; i < queenCount; i++)
                {
                    printLine(solution[i], queenCount);
                }
                Console.WriteLine("------------------");
            }
        }
        
        private void printLine(int pos, int width)
        {
            for (int i = 0; i < width; i++)
            {
                if (pos == i)
                {
                    Console.Write(" x");
                }
                else
                {
                    Console.Write(" .");
                }
            }
            Console.WriteLine();
        }
    }
}
八皇后问题Scheme
#lang racket
(define (enumerate-interval low high) 
   (cond ((> low high) null) 
         ((= low high) (list high)) 
         (else (cons low (enumerate-interval (+ 1 low) high))))) 
  
 (define (flatmap proc seq) 
   (foldr append null (map proc seq))) 
  
 (define empty-board null) 
  
 (define (safe? test-column positions) 
   (define (two-coordinate-safe? coordinate1 coordinate2) 
     (let ((row1 (row coordinate1)) 
           (row2 (row coordinate2)) 
           (col1 (column coordinate1)) 
           (col2 (column coordinate2))) 
       (if (or (= row1 row2) 
               (= (abs (- row1 row2)) (abs (- col1 col2)))) 
           #f 
           #t))) 
   (let ((test-coordinate (get-coordinate-by-column test-column positions))) 
         (foldr (lambda (coordinate results)  
                        (and (two-coordinate-safe? test-coordinate coordinate) 
                             results)) 
                #t 
                (remove test-coordinate positions)))) 
                         
      
 (define (adjoin-position new-row new-column existing-positions) 
   (cons (make-coordinate new-row new-column) existing-positions)) 
  
    
 (define (make-coordinate row column) 
   (list row column)) 
 (define (row coordinate) 
   (car coordinate)) 
 (define (column coordinate) 
   (cadr coordinate)) 
 (define (get-coordinate-by-column target-column coordinates) 
   (cond ((null? coordinates) null) 
         ((= target-column (column (car coordinates))) (car coordinates)) 
         (else (get-coordinate-by-column target-column (cdr coordinates))))) 
  
    
  
 (define (queens board-size) 
   (define (queen-cols k) 
     (if (= k 0) 
         (list empty-board) 
         (filter 
          (lambda (positions) (safe? k positions)) 
          (flatmap 
           (lambda (rest-of-queens) 
             (map (lambda (new-row) 
                    (adjoin-position 
                     new-row k rest-of-queens)) 
                  (enumerate-interval 1 board-size))) 
           (queen-cols (- k 1)))))) 
   (queen-cols board-size))

;敲（queens 8），得到运行结果,每个坐标，第一个代表行，第二个代表列
;纯递归思路，运行环境racket 7.5
定理：一个有向图是强连通的，当且仅当G中有一个回路，它至少包含每个节点一次。
证明：
（1）充分性：如果G中有一个回路，它至少包含每个节点一次，则G中任两个节点都是互相可达的，故G是强连通图。
（2）必要性：如果有向图是强连通的，则任两个节点都是相互可达。故必可做一回路经过图中所有各点。若不然则必有一回路不包含某一结点v，并且v与回路上的个节点就不是相互可达，与强连通条件矛盾
[1] 
。
有n个顶点的强连通图最多有n（n-1）条边，最少有n条边




图1

。
（1）最多的情况：即n个顶点中两两相连，若不计方向，n个点两两相连有n（n-1）/2条边，而由于强连通图是有向图，故每条边有两个方向，n（n-1）/2×2=n（n-1），故有n个顶点的强连通图最多有n（n-1）条边。
（2）最少的情况：即n个顶点围成一个圈，且圈上各边方向一致，即均为顺时针或者逆时针，此时有n条边。
下面举例说明：如图1所示，设ABCD四个点构成强连通图，则：
（1）边数最多有4×3=12条，如图1所示。
（2）边数最少有4条，如图2所示。




图2
问题：给一个有向图，判断给图是否是强连通的。
如图3所示，则是一个强连通图。
对于无向图则比较简单，只需要从某一个顶点出发，使用BFS或DFS搜索，如果可以遍历到所有的顶点，则给定的图是连通的。
但这种方法对有向图并不适用，例如 ： 1 -> 2 -> 3 -> 4，并不是强连通图。
强连通图方法一
可以调用DFS搜索 V 次，V是顶点的个数，就是对每个顶点都做一次DFS搜索，判断是否可达。这样的复杂度为O(V*(V+E))。
强连通图方法二
可以参考求解连通分量的算法Tarjan算法，我们可以在O(V+E) 的时间内找到所有的连通分量，如果连通分量的个数为1，则说明该图是强连通的。
#include <iostream>
#include <list>
#include <stack>
using namespace std;
class Graph
{
    int V;    // 顶点个数
    list<int> *adj;    // 邻接表存储
    // DFS遍历，打印以v为起点的 强连通分量
    void DFSUtil(int v, bool visited[]);
public:
    Graph(int V) { this->V = V;  adj = new list<int>[V];}
    ~Graph() { delete [] adj; }
    void addEdge(int v, int w);
    //判断是是否是强连通图
    bool isSC();
    // 得到当前图的逆置
    Graph getTranspose();
};
void Graph::DFSUtil(int v, bool visited[])
{
    visited[v] = true;
    list<int>::iterator i;
    for (i = adj[v].begin(); i != adj[v].end(); ++i)
        if (!visited[*i])
            DFSUtil(*i, visited);
}
// 返回当前图的转置图
Graph Graph::getTranspose()
{
    Graph g(V);
    for (int v = 0; v < V; v++)
    {
        list<int>::iterator i;
        for(i = adj[v].begin(); i != adj[v].end(); ++i)
        {
            g.adj[*i].push_back(v);
        }
    }
    return g;
}
void Graph::addEdge(int v, int w)
{
    adj[v].push_back(w);
}
bool Graph::isSC()
{
    bool visited[V];
    for (int i = 0; i < V; i++)
        visited[i] = false;
    DFSUtil(0, visited);
     //如果有没有被访问的点就返回false
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
             return false;
    // 创建当前图的转置图
    Graph gr = getTranspose();
    for(int i = 0; i < V; i++)
        visited[i] = false;
    gr.DFSUtil(0, visited);
    // 查看是否是所有的点都被访问到
    for (int i = 0; i < V; i++)
        if (visited[i] == false)
             return false;
    return true;
}
// 测试
int main()
{
    // 创建图1
    Graph g1(5);
    g1.addEdge(0, 1);
    g1.addEdge(1, 2);
    g1.addEdge(2, 3);
    g1.addEdge(3, 0);
    g1.addEdge(2, 4);
    g1.addEdge(4, 2);
    g1.isSC()? cout << "Yes\n" : cout << "No\n";
    // 创建图2
    Graph g2(4);
    g2.addEdge(0, 1);
    g2.addEdge(1, 2);
    g2.addEdge(2, 3);
    g2.isSC()? cout << "Yes\n" : cout << "No\n";
    return 0;
}
在现实世界中存在很多队列的实例。例如，在电影院的售票窗口排队等待买票的人，就是通过队列这种数据结构组织在一起的。人们按先来后到的顺序排成一队，最先买到票的人就是最先来的人。当某人买完票，他就会从队列的最前端离开，这就相当于删除操作。而添加的操作却仅能在队列的尾部进行，因此新来的人就只能排在队列的最后。此外，还有像公共汽车站人们排队等车、医院中病人排队候诊等都是显示生活中队列的例子。
[2]
顺序队列通常采用一维数组进行存储。其中，连续的存储单元依次存放队列中的元素。同时，使用两个指针分别表示数组中存放的第一个元素和最后一个元素的位置。其中，指向第一个元素的指针被称为队头指针front，指向最后一个元素的位置的指针被称为队尾指针rear。
[3]
在实际编程过程中，通常设队头指针指向队列的第一个元素，队尾指针指向队尾元素的后一个位置。front和rear的初值在队列初始化时均应置为0；入队时将新元素插入rear所指的位置，然后将rear加1。出队时，删去front所指的元素，然后将front加1并返回被删元素：由此可见，当头尾指针相等时队列为空。在非空队列里，头指针始终指向队头元素，而尾指针始终指向队尾元素的下一个位置。
[4]
入队时：将新元素插入rear所指的位置，然后将rear加1。
出队时：删去front所指的元素，然后将front加1并返回被删元素。
注意：
(1)当头尾指针相等时，队列为空。
(2)在非空队列里，队头指针始终指向队头元素，队尾指针始终指向队尾元素的下一位置。
[5]
在普通顺序队列中，入队操作就是先将尾指针rear后移一个单元(rear++)，然后将元素值赋给rear单元(data[rear]=X)。出队时．则是头指针front后移(front++)。像这样进行了一定数量入队和出队操作后，可能会出现这样的情况：尾指针rear已指到数组的最后一个元素．即rear==MAXLEN-1．此时若再执行入队操作，便会出现队满“溢出”。然而，由于在此之前可能也执行了若干次出队操作．因而数组的前面部分可能还有很多闲置的元素空间，即这种溢出并非是真的没有可用的存储空间，故称这种溢出现象为“假溢出”。显然，必须要解决这一似溢出的问题，否则顺序队列就没有太多使用价值。
[6]
计算机科学是个非常年轻的科学，非常多的研究至今可能都不超过50年，很多研究的都可以追溯到20世纪50年代，而那个时候从事计算机事业的大师们很多今天仍健在。所以相对而言，我们对与一些事情的历史可以更加细致地但不会过于冗长地进行介绍。通过本文，我希望读者了解到进程代数是什么，并可以在脑中形成一条简单的时间线，清楚地看到进程代数发生的历史。
这些代数理论都使用通信，而不是共享存储，作为进程之间相互作用的基本手段，表现出面向分布式系统的特征。 在语法上，进程代数用一组算子作为进程的构件。算子的语义通常用结构化操作语义方法定义， 这样进程就可看成是带标号的变迁系统。进程代数 的一个显著特征是把并发性归结为非确定性，将并 发执行的进程的行为看成是各单个进程的行为的所 有可能的交错合成，即所谓交错语义。 进程代数研究的核心问题是进程的等价性，即在什么意义下两个进程的行为相同?在进程代数领域使用的最为广泛的等价关系有互模拟、测试等价、 失败等价(参见通信顺序进程)等。对这些语义等价 关系均建立了相应的公理系统。关于公理系统的研 究不仅加深了对语义理论的理解，而且使得有可能 对语义等价关系进行形式推理。 为了将进程代数的理论成果应用于解决实际问题，20世纪80年代后期出现了许多计算机支持工具。用这些工具可对进程的行为进行推理或模拟
[1] 
。
谈到进程代数，很多人会想到Petri-net，在进程代数之前，这个1962年由Petri发明的形式化方法是并行理论的唯一工具，用来研究并行和分布式系统。
1970年的时候，世界上关于计算（computation）的形式化推理方法，基本分为三种：
操作语义学(Operational semantics)——通过语言的实现方式定义语言的语义，也就是将语言成分所对应的计算机的操作作为语言成分的语义。因为语言的语义应该是标准的，不应依赖于特定的计算机系统，或一种具体的实现方式，因此，操作语义学使用抽象机和抽象解释程序来定义语言的语义。
指称语义学(Denotational semantics)——通过执行语言成分所要得到的最终效果来定义该语言成分的语义。指称语义学方法认为语言成分的含义是语言成分本身固有的，不依赖于具体实现该语言成分的计算机。对同一种语言成分，不同的计算机的执行实现过程可以不同，但所产生的最终效果应该是相同的。这种最终效果被看作是语言成分所指称的外在物体，称作语言成分的指称物。指称物多为数学对象，如整数、集合、函数等。指称语义学方法在定义语言的语义时，先确定指称物，然后给出语言成分到指称物的语义映射，这种映射必须满足两个条件：每个语言成分都对应有指称；复合成分的指称只依赖于它的子成分的指称。论域理论是指称语义学方法的数学基础。
公理化语义(Axiomatic semantics)——通过使用数学中的公理化方法，用公理系统定义程序设计语言的语义。另外，公理语义学还研究和寻求适用于描述程序语义、便于语义推导的逻辑语言。例如，用时态逻辑定义的语言的公理语义又称为时态语义。典型的公理语义方法是Hoare公理系统
[2] 
。
进程代数英文为：process algebra，在英文中，这个词组中的process代表一个system(系统的)behavior（行为）；一个系统就是一个能表现出各种行为的事物，在计算机世界，process主要指一个软件系统的行为；这句话很抽象，说白了就是，一个软件系统可以表现为一个动作（action），比如转换一个文件的格式，也可以发生一个个事件（event），比如格式转换完毕，另外，一个软件系统也可以



。
进程代数英文为：process algebra，在英文中，这个词组中的process代表一个system(系统的)behavior（行为）；一个系统就是一个能表现出各种行为的事物，在计算机世界，process主要指一个软件系统的行为；这句话很抽象，说白了就是，一个软件系统可以表现为一个动作（action），比如转换一个文件的格式，也可以发生一个个事件（event），比如格式转换完毕，另外，一个软件系统也可以在一定的序列下完成一系列动作（action）；我们可以从各个角度（aspect）去观察一个系统的行为。研究者往往会关注一个角度的系统行为，这是他们会把系统进行抽象，称这种抽象为对系统行为的一种观察（observation）。
有一些研究人员，以这样的一个角度观察系统的行为：
系统由一大堆动作（action）组成；
动作之间都是离散的（discrete），独立的；
离散的意思是action发生在某一时间，各个action发生的时间是独立的，不相关的。
离散数学中，群（Group）是一个代数结构，它的运算符特性满足该群的约束要求，比如群(G,*)是一个代数系统，其中运算符*要满足结合律的要求，从群论的角度来看，进程代数是一个以进程为基本元素，并且进程上的运算符满足特定的约束的代数结构。
进程代数理论中提出了许多种模型，其中最早的（大约是20世纪中期）、最简单的模型是：将行为看做是一个带有输入/输出的函数，在进程开始时，给予一个输入值，在进程的执行过程中的某个时刻会给予外界它的某个输出值。这个模型是基于有穷自动机理论的，即每个process被看做一个自动机（automaton）【注：今天仍然有人将一个process看作自动机，进行研究】，一个自动机有很多状态（state）和迁移（transition），状态通过迁移进行状态之间之间的转换，这样，用自动机代表一个进程时，状态之间的迁移就代表进程执行了一个动作，所以迁移描述了进程的最基本行为，另外，一个自动机还可以有一个初始状态和多个终止状态。一次行为（behiour）就是一个自动机迁移的实例，即从初始态到达某一个终止态的具体路径过程。
但是后来，人们发现这种自动机模型并不能完全表达一个系统的行为，它无法描述两个系统之前的交互行为，也就是说自动机无法用来描述并行系统或分布式系统，或者说反应系统（reactive system）的行为。因此人们开始了并发理论（concurrency theory）研究，所以说并发理论是针对反应式、并行式或分布式系统的，这些系统与云计算也有重要的相关之处。
那么进程代数可以说是并行理论中的一个研究方向，所以我们在后面会看到，一种进程代数通常都会有一个基本的运算符——并行组合（parallel composition），这里组合(compostion)是指多个离散的动作的组合。除了并行的组合，还有带有选择分支的组合（alternative composition--choice）和按顺序组合(sequential composition--sequencing），这样，我们就可以对系统使用进程代数建模，然后通过代数的运算，方程推导进行分析和验证以判断系统是否满足我们所希望的特性。
我们使用加号“ +” 作为 alternative composition, 分号“;” 作为sequential composition，而双竖线“||” 表示 parallel composition.那么我们定义以下法则：
– x + y = y + x (commutativity of alternative composition)
– x + (y + z) = (x + y) + z (associativity of alternative composition)
– x + x = x (idempotency of alternative composition)
– (x + y); z = x; z + y; z (right distributivity of + over ;)
– (x; y); z = x; (y; z) (associativity of sequential composition)
– x k y = y k x (commutativity of parallel composition)
– (x k y) k z = x k (y k z) (associativity of parallel composition)
如果任何带有三个运算符的代数结构满足以上七条法则，那么就称这个代数为进程代数，这就是一个简单的进程代数的概念定义
[3] 
。
进程代数Bekič
奥地利维也纳的IBM实验室在整个60年代和70年代都以其程序语言的定义和语义方面的研究而著称，这个期间Hans Bekič就工作在这里，他主要从事ALGOL和PL/I(相信学过计算机的同志对这些名词都有点眼熟)的指称语义方面的研究，但是针对PL/I的parallel composition运算符如何指定指称语义遇到了困难，他提出了一个类并行组合运算符（quasi-parallel composition operator），后来更正为并行组合运算符，并提出了一些其他的基本运算和概念，使得进程代数的一些基本概念开始浮现，但是还不成熟。
进程代数CCS
进程代数历史上最重要的人物是Robin Milner，1973至1980年间发明了CCS(Calculus of Communicating Systems，通信系统演算)，是用于描述通信并发系统的代数理论。
假定一个标号集L，其补集Act=L∪L∪{τ}称为动作集，其中τ是特殊的不可见动作。CCS的进程构造算子如下： 算子 直观意义 0 空进程 a.P 动作前缀(a∈Act) P+Q 非确定选择 P|Q 并行复合 P\S 限制(S L) P[f) 换标号(f是从L到L的部分函数)此外还允许递归算子。 CCS的语义由结构化操作语义方法给出，下面列出几条典型的语义规则。P→Q表示进程P可执行动作a而演变为Q。 从关于并行算子|的规则可以看出，由两个进程并行复合而成的进程可以做每个分进程所能做的动作(PAR1)和(PAR2)，但当两个分进程同时执行一对互补的动作时，则发生通信，产生τ动作(COM)。这种通信方式称为握手式通信。CCS的基本思想是用τ和+来模拟|，将并发归结为非确定性，即所谓交错语义。这一思想体现在下面的展开律中： CCS采用互模拟作为基本的进程等价关系。强互模拟等价满足下面的Monoid公理： P+0=P，P+P=P，P+Q=Q+P， (P+Q)+R=P+(Q+R) 对观察等价(将τ忽略不计)还成立三条，—公理： a.τ．P=a.P， P+τ．P=τ．P， a．(P+τ．Q)+a．Q=a．(P+τ．Q) 上面介绍的CCS称为基本CCS，或纯CCS，进程之间只能通过执行互补动作实现同步，而不能直接进行通信。全CCS引入输出动作c<-e和输入动作c->x， c<-e表示沿通道c发送数据表达式e的值，c->x表示从通道c接收一个值赋给x，此外还有条件表达式if- then-else。用全CCS可以直接描述进程间的通信。
进程代数CSP
Tony Hoare是另一位重要的人物。1978年C. A．R．Hoare提出的通信顺序进程 CSP，是面向分布式系统的程序设计语言。在该语言中，一个并发系统由若干并行运行的顺序进程组成，每个进程不能对其他进程的变量赋值。进程之间只能通过一对通信原语实现协作：Q->x表示从进程Q输入一个值到变量x中；P<-e表示把表达式e的值发送给进程P。当P进程执行Q->x，同时Q进程执行P<-e时，发生通信，e的值从Q进程传送给P进程的变量x。后来出现的实用编程语言OCCAM即以CSP为基础发展而成。 1984年S．Brooks，C．A．R．Hoare和W．Roscoe提出CSP理论(TCSP)。这是一个代数演算系统，其基本成分是事件(或动作)。进程由事件和一组算子构造而成。典型的算子有：→(前缀)，|(外部非确定性选择)，　(内部非确定性选择)　(交错并行)，　(同步并行)，\e(事件隐蔽)，以及递归等。 例：(自动售货机) VM=coin→(choc→VM|coffee→VM)， CUST：coin→(choc→CUST coffee→CUST) 这里定义了两个进程：VM(售货机)和CUST (顾客)。售货机在接受了硬币coin后，可按顾客的要求支付choc或coffee。顾客在付了硬币后，或者想要choc，或者想要coffee，其选择不受外界影响。 与CCS不同(也与作为程序设计语言的CSP不同)，TCSP采用的是广播式通信，而不是握手式通信，即只有当并行运行的各进程都执行同一动作时，才发生同步。 TCSP采用失败等价作为确定进程等价的准则，这也称为失败语义。一个失败是一二元组(s,X)，其中s是事件的有限序列，X是事件集(称为拒绝集)。若进程P可以执行事件序列s，且到达一个无法执行X中任一事件的状态，则称(s,X)是P的一个失败。例如，设有进程P=a→(b→c→STOP|b→d→STOP)，则(ab，{c})是P的一个失败，因为P可执行ab，变成d→STOP而无法做c。类似地，(ab， {d})也是P的一个失败，但(ab，{c})不是。两个进程失败等价当且仅当它们具有相同的失败集。例如对自动售货机的例子，可以证明进程VM|CUST与CUST失败等价。 利用失败可以构造TCSP的指称模型，在此模型中，失败等价的进程被解释为同一个元素。关于失败等价建立了一些公理系统，可以对语义上的等价关系进行形式推导。
进程代数林惠民
林惠民院士主要从事软件的基础性研究。计算机是一种工具，大部分的人是在进行应用研究，即如何利用现有的理论和模型来开发出更有用的东西。而基础性研究与应用研究不同，它不仅要关心怎么样，还要知道为什么这样，要能够提出新的模型和方法。计算机软件科学的特点是基础研究和应用研究是紧密结合的，而且时效性非常强，基础研究的最新成果很快就会应用到工程中去。林惠民院士从事的一项工作是关于并发程序的形式语义学及形式化方法的研究。他和他的同事设计并实现了世界上第一个通用的进程代数验证工具。进程代数的实际应用离不开计算机辅助工具的支持。八十年代后期，一批进程代数验证工具应运而生（如CWB, PSF, LOTOSphere等），其共同局限性是每一工具只适用于某一特定的进程演算。这种局限性妨碍了验证工具的推广应用。如何克服这种局限性是当时国际进程代数界面临的一个重大挑战。这些验证工具无法做到通用，根本原因在于缺乏既能描述不同进程演算的语义，又能为计算机所理解的通用语言。经过对不同演算的反复比较，并考虑到在计算机上实现的可能性，他提炼出了一个元语言，用它可以描述各种进程演算的公理化语义，并且具有良好的可读性。在此基础上实现了通用的交互式进程代数验证工具PAM，只要将这个元语言描述的进程演算定义输入PAM，就得到该演算的证明器。PAM可同时接受多个不同的演算，对每个演算又可生成多个证明窗口。这是世界上第一个通用的进程代数证明工具。1993年他又利用当时刚刚取得的关于消息传送进程证明系统的理论结果，对PAM加以扩充，研制成迄今世界上唯一能对付消息传送进程的验证工具VPAM。PAM和VPAM都是通过ftp在Internet上公开发行的，其用户遍布各大洲，包括美国、加拿大、英、法、德、意、荷兰、丹麦、瑞典、斯洛伐克、巴西、印度、新西兰、南非等十几个国家，其中既有来自大学的，也有来自菲利普、惠普和贝尔等著名公司实验室的。
函数对象（function object）是一个程序设计的对象允许被当作普通函数来调用。
函数对象与函数指针相比，有两个优点：第一是编译器可以内联执行函数对象的调用；第二是函数对象内部可以保持状态。
函数式程序设计语言还支持闭包，例如，first-class函数支持在其创建时用到的函数外定义的变量的值保持下来，成为一个函数闭包。
[1]
C++的STL中的众多algorithm，非常依赖于函数对象处理容器的元素。因此，STL预定义了许多函数对象、谓词（predicate）、以及用于复合（composite）函数对象的binder、member function adapter、 pointer to function adapters、 negaters、 function objects base structure。由于STL中的algorithm使用函数对象作为参数时，一般都是传值调用，所以函数对象应该仔细设计其复制构造函数。
[2]
函数对象预定义的函数对象
C++98在头文件functional中定义了下述函数对象： plus<type>() 结果为(param1 + param2) minus<type>() 结果为(param1 - param2) multiplies<type>() 结果为(param1 * param2) divides<type>() 结果为(param1 / param2) modulus<type>() 结果为(param1% param2)
[2]
函数对象谓词（predicate）
返回布尔值（或者可以隐式转换为布尔值）的函数对象。用于STL中的algorithm时，谓词应该是无状态的（ stateless）函数对象，即谓词的结果不依赖于内部的数据成员。这是因为STL中的algorithm不保证内部实现时对传入的谓词要复制多少次。 C++98在头文件functional中定义了下述谓词:
equal_to<type>() 结果为(param1 == param2)
not_equal_to<type>() 结果为(param1!= param2)
less<type>() 结果为 (param1 < param2)
greater<type>() 结果为(param1 > param2)
less_equal<type>() 结果为 (param1 <= param2)
greater_equal<type>() 结果为 (param1 >= param2)
logical_not<type>() 结果为 (!param1)
logical_and<type>() 结果为 (param1 && param2)
logical_or<type>() 结果为 (param1 || param2)
[2]
函数对象Function Adapter
用于组合（combine）、变换（transform）、操作（manipulate）函数对象、特定参数值、或者特定函数。进一步细分为：
Binder
C++98在头文件functional中定义了两个函数bind1st与bind2nd，返回值为binder1st、binder2nd类型。用于把二元函数对象分别绑定第一个、第二个参数后成为单元函数对象。
Negater
negate把一个作为谓词的函数对象取反。C++98在头文件functional中定义了两个函数not1与not2，返回值为unary_negate、binary_negate类型。
Member function adapter
Member function adapter用于把类的成员函数用作STL中的algorithm的参数。C++98在头文件functional中定义了:
函数mem_fun，返回值为mem_fun_t类型，用于通过一个类对象指针来调用成员函数指针。
函数mem_fun_ref，返回值为mem_fun_ref_t类型，用于通过一个类对象引用来调用成员函数指针。
Pointer to function adapter
函数指针适配器（Pointer to function adapter）是把函数指针包装为一个函数对象，以便STL中的algorithm用函数对象作为统一的参数类型，不用再考虑以函数指针作为传入参数的情形。C++98在头文件functional中定义了:
函数ptr_fun，返回值为pointer_to_unary_function类型，包装了一个单参数的函数指针。
重载函数ptr_fun，返回值为pointer_to_binary_function类型，包装了一个双参数的函数指针。
[2]
函数对象Function Object Base
函数对象基类（Function Object Base）定义在头文件functional中，用作STL的预定义的与函数对象有关的各个类的基类，其中定义了几个类型，分别表示函数调用的各个参数类型、结果类型。
unary_function类，定义了2个类型：argument_type、result_type；
binary_function类，定义了3个类型：first_argument_type、second_argument_type、result_type；
[2]
通配符是一类键盘字符。
当查找文件夹时；当不知道真正字符或者不想键入完整名字时，常常使用通配符代替一个或多个真正字符。
星号（*）
可以使用星号代替零个、单个或多个字符。如果正在查找以AEW开头的一个文件，但不记得文件名其余部分，可以输入AEW*，查找以AEW开头的所有文件类型的文件，如AEWT.txt、AEWU.EXE、AEWI.dll等。要缩小范围可以输入AEW*.txt，查找以AEW开头的所有文件类型并.txt为扩展名的文件如AEWIP.txt、AEWDF.txt。
问号（？）
可以使用问号代替一个字符。如果输入love?，查找以love开头的一个字符结尾文件类型的文件，如lovey、lovei等。要缩小范围可以输入love?.doc，查找以love开头的一个字符结尾文件类型并.doc为扩展名的文件如lovey.doc、loveh.doc。
通配符包括星号“*”和问号“？”
星号表示匹配的数量不受限制，而后者的匹配字符数则受到限制。这个技巧主要用于英文搜索中，如输入““computer*”，就可以找到“computer、computers、computerised、computerized”等单词，而输入“comp?ter”，则只能找到“computer、compater、competer”等单词。
通配符优先级
对于使用通配符模式的各种资源，Tivoli Access Manager for Operating Systems 必须确定将应用何种通配符模式。例如，假设有两种模式：
/usr/local/*.log
和
/usr/local/user1/*.log
字符串 /usr/local/user1/x.log 与这两种模式都匹配。
为了解决这种模棱两可的情况，应用了优先级规则。模式越具体，其优先级也越高。根据这种原则，/usr/local/user1/x.log 在与 /usr/local/*.log 模式相匹配之前先与 /usr/local/user1/*.log 模式相匹配。由于找到一个匹配项，任何可应用于匹配此模式的对象的策略都将适用。
下表显示了通配符元素的优先级。表中较高位置的元素优先于表中较低位置的元素。
表：通配符元素优先级规则
优先级 元素 示例
1 精确字符 a, \*, \\
2 字符范围 [Aa], [[:digit:]]
3 任意字符 ?
4 重复的精确字符 a+
5 重复的字符范围 [Aa]+, [[:digit:]]+
6 重复的任意字符 ?+
7 任意字符串 *
根据资源的种类，将通过从开始到结束（或者相反方向）逐个元素比较模式来确定优先级。匹配文件名称的模式是从开始比较到结束。匹配主机名称的模式是从结束比较到开始。
除了认为相同的两种模式之外，将认为较长的模式比较短的模式更具体，除非较长的字符串是由于星号（*）而较长。
通配符优先级的示例
表 4 显示了按优先级从最高到最低排列的文件名和主机名通配符模式。
表 4. 通配符模式优先级示例
优先级 文件名称模式 主机名称模式
1 log/0[0-9]/error
2 log/0?/error
3 log/0*/error
4 log/[0-9]+/error.1
5 log/*/error.1
6 log*/error.1
7 log*/error
8 log*/error* *
9 log*
10 * *
当两个模式之间的唯一差别是字符集合中指定的字符时，将通过逐字比较包含模式的两个字符串来确定优先级。仅在要匹配的字符集包含一些相同字符时才必须考虑这一点。如果在两个集合中没有公共字符，则任一给定的字符串最多只能匹配这两个模式中的一个。
路由配置中的通配符
在路由器的配置中，经常出现通配符。和子网掩码一样，都是以“0”或“1”表示，不过与子网掩码所表示的意思却不一样。
子网掩码所表示的是IP的网络位和主机位，而通配符则表示与IP是否匹配。
通配符同样是32位，和IP地址一一对应，“0”位代表精确匹配，而“1“位代表不许匹配。例如路由器EIGRP的配置中：
RouterA(config)#router eigrp 100
RouterA(config-router)#network 10.0.0.0 0.0.0.255
RouterA(config-router)#network 192.168.1.0 0.0.0.255
10.0.0.0 0.0.0.255说明只要接口的IP地址是以“10”开头就参与EIGRP进程。同理的，192.168.1.0 0.0.0.255说明只要IP是以192.168.1开头的IP就符合。
SQL 通配符
在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。
SQL 通配符必须与 LIKE 运算符一起使用。
在 SQL 中，可使用以下通配符：
通配符
描述
%
替代零个或多个字符
_
仅替代一个字符
[charlist]
字符列中的任何单一字符
[^charlist]
或者
[!charlist]
不在字符列中的任何单一字符
原始的表
(用在例子中的)：
Persons 表:
Id
LastName
FirstName
Address
City
1
Adams
John
Oxford Street
London
2
Bush
George
Fifth Avenue
New York
3
Carter
Thomas
Changan Street
Beijing
使用 % 通配符
例子 1
我们希望从上面的 "Persons" 表中选取居住在以 "Ne" 开始的城市里的人：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE City LIKE 'Ne%'结果集：
Id
LastName
FirstName
Address
City
2
Bush
George
Fifth Avenue
New York
例子 2
接下来，我们希望从 "Persons" 表中选取居住在包含 "lond" 的城市里的人：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE City LIKE '%lond%'结果集：
Id
LastName
FirstName
Address
City
1
Adams
John
Oxford Street
London
使用 _ 通配符
例子 1
我们希望从上面的 "Persons" 表中选取名字的第一个字符之后是 "eorge" 的人：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE FirstName LIKE '_eorge'结果集：
Id
LastName
FirstName
Address
City
2
Bush
George
Fifth Avenue
New York
例子 2
接下来，我们希望从 "Persons" 表中选取的这条记录的姓氏以 "C" 开头，然后是一个任意字符，然后是 "r"，然后是任意字符，然后是 "er"：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE LastName LIKE 'C_r_er'结果集：
Id
LastName
FirstName
Address
City
3
Carter
Thomas
Changan Street
Beijing
使用 [charlist] 通配符
例子 1
我们希望从上面的 "Persons" 表中选取居住的城市以 "A" 或 "L" 或 "N" 开头的人：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE City LIKE '[ALN]%'结果集：
Id
LastName
FirstName
Address
City
1
Adams
John
Oxford Street
London
2
Bush
George
Fifth Avenue
New York
例子 2
我们希望从上面的 "Persons" 表中选取居住的城市不以 "A" 或 "L" 或 "N" 开头的人：
我们可以使用下面的 SELECT 语句：
SELECT * FROM PersonsWHERE City LIKE '[!ALN]%'结果集：
Id
LastName
FirstName
Address
City
3
Carter
Thomas
Changan Street
Beijing
在图论的数学领域，完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。完整的有向图又是一个有向图，其中每对不同的顶点通过一对唯一的边缘（每个方向一个）连接。n个端点的完全图有n个端点以及n(n − 1) / 2条边，以Kn表示。它是(k − 1)-正则图。所有完全图都是它本身的团（clique）。
图形理论本身以莱昂哈德欧拉于1736年在Königsberg七桥的工作开始。 然而，完全图的绘图，其顶点放置在正多边形的点上，已经在13世纪中出现。这样的绘画有时被称为神秘玫瑰。
[1]
n个顶点的完全图表示为



 。 一些消息来源称，这个符号中的字母K代表德语单词komplett，但完全图的德文名称vollständigerGraph不包含字母K，其他来源则表示符号表示 Kazimierz Kuratowski图论。
具有



 个边（三角数），并且是维度为n-1的常规图。所有完全图都是它们自己的最大组。 它们是最大化连接的，因为断开图形的唯一顶点是所有的顶点集。完全图的补码图是一个空图。
如果一个完全图的边缘都被赋予一个方向，那么所得的有向图就被称为比赛。
完全图的匹配数由电话号码给出：
1，1，2，4，10，26，76，232，764，2620，9496，35696，140152，568504，2390480，10349536，46206736，...（OEIS中的序列A000085）。
这些数字给出了n顶点图的Hosoya索引的最大可能值。完全图



 （n均匀）完美匹配的数量由双因子



 给出。
的交叉号码是已知的，



 需要7233或7234个交叉口。 进一步的值是由直线交叉号码项目收集的。



 的交叉数字是：
0,0,0,0,1,3,9,29,36,62,102,153,229,324,447,603,798,1029,1318,1657,2055,2528,3077,3699,4430,5250,6180，...（OEIS中的序列A014540）。
具有n个节点的完全图表示（n-1） - 复杂的边缘。 几何



 形成三角形的边缘集合，



 是四面体等。具有圆环拓扑的非凸多面体Császár多面体具有完整的图形



 作为其骨架。 四个或更多维度的每个多面体也具有完整的框架。
至



 均为平面图。 然而，具有五个或更多个顶点的完整图形的每个平面图都必须包含交叉点，并且非平面完全图



 在平面图的表征中起关键作用：通过库拉托斯基定理，当且仅当它既不包含



 也不是包含



 作为细分，图才能成为平面图，通过瓦格纳定理，图形代替细分也是一样的结果。 康威和戈登证明，



 在三维空间中的每一次嵌入是内在联系的，至少有一对连接的是三角形。 康威和戈登还表明，



 的任何三维嵌入包含一个嵌入在空间中的哈密尔顿循环。
n顶点的完全图，在n从1到12之间，与边缘数量一起显示如下：
K1：K4(4张)
无向完全图是用n表示图中顶点数目的一种图，一张图中每条边都是无方向的。
完全图定义
用n表示图中顶点数目，用e表示边或弧的数目。若<vi,vj>∈VR，则vi≠vj，那么，对于无向图，e的取值范围是0到



，有



条边的无向图称为完全图。
完全图解释
直观来说，若一个图中每条边都是无方向的，则称为无向图。
（1）无向边的表示
无向图中的边均是顶点的无序对，无序对通常用圆括号表示。
【例】无序对(vi，vj)和(vj，vi)表示同一条边。
（2）无向图的表示
【例】下面(b)图中的G2和(c)图中的G3均是无向图，它们的顶点集和边集分别为：
V(G2)={v1，v2，v3，v4}
E(G2)={(vl，v2)，(v1，v3)，(v1，v4)，(v2，v3)，(v2，v4)，(v3，v4)}
V(G3)={v1，v2，v3，v4，v5，v6，v7}
E(G3)={(v1，v2)，(vl，v3)，(v2，v4)，(v2，v5)，(v3，v6)，(v3，v7)}
完全图注意
在以下讨论中，不考虑顶点到其自身的边。即若(v1，v2)或<vl，v2>是E(G)中的一条边，则要求v1≠v2。此外，不允许一条边在图中重复出现，即只讨论简单的图。
3．图G的顶点数n和边数e的关系
（1）若G是无向图，则0≤e≤n(n-1)/2
恰有n(n-1)/2条边的无向图称无向完全图(Undirected Complete Graph)
（2）若G是有向图，则0≤e≤n(n-1)。
恰有n(n-1)条边的有向图称为有向完全图(Directed Complete Graph)。
注意：
完全图具有最多的边数。任意一对顶点间均有边相连。
【例】上面(b)图的G2就是具有4个顶点的无向完全图。
用n表示图中顶点数目，用e表示边或弧的数目。若<vi,vj>∈VR，则



≠



，那么，对于有向图，e的取值范围是0到



 ，有



 条边的有向图称为有向完全图。
数学模型
（1）列出约束条件及目标函数




线性规划步骤
（2）画出约束条件所表示的可行域
（3）在可行域内求目标函数的最优解及最优值
描述线性规划问题的常用和最直观形式是标准型。标准型包括以下三个部分：
一个需要极大化的线性函数：
以下形式的问题约束：
和非负变量：　　



　　



　　其它类型的问题，例如极小化问题，不同形式的约束问题，和有负变量的问题，都可以改写成其等价问题的标准型。
从实际问题中建立数学模型一般有以下三个步骤；
1.根据影响所要达到目的的因素找到决策变量；
2.由决策变量和所在达到目的之间的函数关系确定目标函数；
3.由决策变量所受的限制条件确定决策变量所要满足的约束条件。




线性规划难题解法
所建立的数学模型具有以下特点：
1、每个模型都有若干个决策变量（x1，x2，x3……，xn），其中n为决策变量个数。决策变量的一组值表示一种方案，同时决策变量一般是非负的。
2、目标函数是决策变量的线性函数，根据具体问题可以是最大化（max）或最小化（min），二者统称为最优化（opt）。
3、约束条件也是决策变量的线性函数。
当我们得到的数学模型的目标函数为线性函数，约束条件为线性等式或不等式时称此数学模型为线性规划模型。
例：
生产安排模型：某工厂要安排生产Ⅰ、Ⅱ两种产品，已知生产单位产品所需的设备台时及A、B两种原材料的消耗，如表所示，表中右边一列是每日设备能力及原材料供应的限量，该工厂生产一单位产品Ⅰ可获利2元，生产一单位产品Ⅱ可获利3元，问应如何安排生产，使其获利最多？
解：
1、确定决策变量：设x1、x2分别为产品Ⅰ、Ⅱ的生产数量；
2、明确目标函数：获利最大，即求2x1+3x2最大值；
3、所满足的约束条件：
设备限制：x1+2x2≤8
原材料A限制：4x1≤16
原材料B限制：4x2≤12
基本要求：x1，x2≥0
用max代替最大值，s.t.（subject to 的简写）代替约束条件，则该模型可记为：
max z=2x1+3x2
s.t. x1+2x2≤8
4x1≤16
4x2≤12
x1，x2≥0
求解线性规划问题的基本方法是单纯形法，已有单纯形法的标准软件，可在电子计算机上求解约束条件和决策变量数达 10000个以上的线性规划问题。为了提高解题速度，又有改进单纯形法、对偶单纯形法、原始对偶方法、分解算法和各种多项式时间算法。对于只有两个变量的简单的线性规划问题，也可采用图解法求解。这种方法仅适用于只有两个变量的线性规划问题。它的特点是直观而易于理解，但实用价值不大。通过图解法求解可以理解线性规划的一些基本概念。
对于一般线性规划问题：




图解法解线性规划问题

Min z=CX
S.T.
AX =b
X>=0
其中A为一个m*n矩阵。
若A行满秩
则可以找到基矩阵B，并寻找初始基解。
用N表示对应于B的非基矩阵。则规划问题1可化为：
规划问题2：
Min z=CB XB+CNXN
S.T.




线性规划法解题

B XB+N XN = b (1)
XB >= 0, XN >= 0 (2)
(1)两边同乘B-1，得
XB + B-1 N XN = B-1 b
同时，由上式得XB = B-1 b - B-1 N XN，也代入目标函数，问题可以继续化为：
规划问题3：
Min z=CB B-1 b + ( CN - CB B-1 N ) XN
S.T.
XB+B-1N XN = B-1 b (1)
XB >= 0, XN >= 0 (2)
令N:=B-1N，b:= B-1 b，ζ= CB B-1b，σ= CN - CB B-1 N，则上述问题化为规划问题形式4：
Min z= ζ + σ XN
S.T.
XB+ N XN = b (1)
XB >= 0, XN >= 0 (2)
在上述变换中，若能找到规划问题形式4，使得b>=0，称该形式为初始基解形式。
上述的变换相当于对整个扩展矩阵（包含C及A） 乘以增广矩阵 。所以重在选择B，从而找出对应的CB。
若存在初始基解
若σ>= 0
则z >=ζ。同时，令XN = 0，XB = b，这是一个可行解，且此时z=ζ，即达到最优值。所以，此时可以得到最优解。
若σ >= 0不成立
可以采用单纯形表变换。
σ中存在分量<0。这些负分量对应的决策变量编号中，最小的为j。N中与j对应的列向量为Pj。
若Pj <=0不成立
则Pj至少存在一个分量ai，j为正。在规划问题4的约束条件（1）的两边乘以矩阵T。
T=
则变换后，决策变量xj成为基变量，替换掉原来的那个基变量。为使得T b >= 0，且T Pj=ei（其中，ei表示第i个单位向量），需要：
l ai，j>0。
l βq+βi*(-aq,j/ai,j)>=0，其中q!=i。即βq>=βi/ ai,j * aq,j。
n 若aq,j<=0，上式一定成立。
n 若aq,j>0，则需要βq / aq,j >=βi/ ai,j。因此，要选择i使得βi/ ai,j最小。
如果这种方法确定了多个下标，选择下标最小的一个。
转换后得到规划问题4的形式，继续对σ进行判断。由于基解是有限个，因此，一定可以在有限步跳出该循环。
若对于每一个i，ai,j<=0
最优值无解。
若不能寻找到初始基解
无解。
若A不是行满秩
化简直到A行满秩，转到若A行满秩。
法国数学家J.- B.- J.傅里叶和C.瓦莱－普森分别于1832和1911年独立地提




可解的问题会有一个简单多边形的可行域

出线性规划的想法，但未引起注意。
1939年苏联数学家Л.В.康托罗维奇在《生产组织与计划中的数学方法》一书中提出线性规划问题，也未引起重视。
1947年美国数学家G.B.Dantzing提出求解线性规划的单纯形法，为这门学科奠定了基础。
1947年美国数学家J.von诺伊曼提出对偶理论,开创了线性规划的许多新的研究领域，扩大了它的应用范围和解题能力。
1951年美国经济学家T.C.库普曼斯把线性规划应用到经济领域，为此与康托罗维奇一起获1975年诺贝尔经济学奖。
50年代后对线性规划进行大量的理论研究，并涌现出一大批新的算法。例如，1954年C.莱姆基提出对偶单纯形法，1954年S.加斯和T.萨迪等人解决了线性规划的灵敏度分析和参数规划问题，1956年A.塔克提出互补松弛定理，1960年G.B.丹齐克和P.沃尔夫提出分解算法等。
线性规划的研究成果还直接推动了其他数学规划问题包括整数规划、随机规划和非线性规划的算法研究。由于数字电子计算机的发展，出现了许多线性规划软件，如MPSX，OPHEIE，UMPIRE等，可以很方便地求解几千个变量的线性规划问题。
1979年苏联数学家L. G. Khachian提出解线性规划问题的椭球算法，并证明它是多项式时间算法。
1984年美国贝尔电话实验室的印度数学家N.卡马卡提出解线性规划问题的新的多项式时间算法。用这种方法求解线性规划问题在变量个数为5000时只要单纯形法所用时间的1/50。现已形成线性规划多项式算法理论。50年代后线性规划的应用范围不断扩大。 建立线性规划模型的方法
在企业的各项管理活动中,例如计划、生产、运输、技术等问题，线性规划是指从各种限制条件的组合中，选择出最为合理的计算方法，建立线性规划模型从而求得最佳结果。
满二叉树对于国内的满二叉树
从图形形态上看，满二叉树外观上是一个三角形。
图一
从数学上看，满二叉树的各个层的结点数形成一个首项为1，公比为2的等比数列。
因此由等比数列的公式，满二叉树满足如下性质。
1、一个层数为k 的满二叉树总结点数为：



。因此满二叉树

的结点数一定是奇数个。
2、第i层上的结点数为：
3、一个层数为k的满二叉树的叶子结点个数（也就是最后一层）：
满二叉树对于国外的满二叉树
满二叉树的结点要么是叶子结点，度为0，要么是度为2的结点，不存在度为1的结点。
图三
因此，右图中这个二叉树也是满二叉树。但是按照国内的定义，它却不是满二叉树。
美国以及国际上所定义的满二叉树，即full binary tree,和国内的定义不同，美国NIST给出的定义为：A binary tree in which each node has exactly zero or two children. In other words, every node is either a leaf or has two children. For efficiency, any Huffman coding is a full binary tree.
满二叉树的任意节点，要么度为0，要么度为2.换个说法即要么为叶子结点，要么同时具有左右孩子。霍夫曼树是符合这种定义的，满足国际上定义的满二叉树，但是不满足国内的定义。
[1]
一种基于满二叉树的原地快速排序算法。 与经典快速排序算法相比, 新算法每趟划分采用动态枢轴而不是静态枢轴, 同时新算法利用满二叉树的特点计算下一趟划分的枢轴位置和元素范围, 避免使用递归或开辟内存堆栈。 实验表明, 新算法的时间性能优于最好的原地排序—堆排序。 原地快速排序二叉树的概念对排序算法的研究和改进具有很好的理论和实用参考价值。
给定一个长度为m的顺序表 ,每个元素由一个关键字和其他的相关信息构成 , 排序算法的任务就是根据关键字以非降序(或非升序)重新安排数组中的元素(不失一般性, 以下我们按非降序排序)。排序算法仅允许做关键字比较和元素移动操作, 并用关键字比较次数和元素移动次数 ,衡量排序算法的时间性能和空间性能 。如果一个算法所使用的额外空间是一个固定常数 ,与处理问题的规模无关 ,则我们称该算法是原地的。快速排序算法是最好的排序算法之一, 它的基本思想是通过若干次划分得到有序表。一次划分后枢轴左边元素的关键字都不大于枢轴的关键字, 枢轴右边元素的关键字都不小于枢轴的关键字 。然后对枢轴左边和右边的元素继续划分 ,直到每个部分都只有1个元素为止。经典快速排序或用递归函数实现或自己开辟内存堆栈实现,需要



的额外空间, 都不是严格意义上的原地算法 。在本文中 ,将满二叉树的概念引入快速排序中, 利用满二叉树的特点计算下一趟划分的枢轴位置和元素范围 ,避免了使用递归或开辟内存堆栈 ,从而将快速排序改造成严格原地的。实验表明, 该算法的时间性能优于最好的原地排序 —堆排序。
在推荐系统中应用K-means算法聚类可有效降维，然而聚类效果往往依赖于选定的初始中心，并且一旦选定目标簇后，推荐过程只针对目标簇进行，与其他簇无关。针对上述两个问题，提出一种基于满二叉树的二分K-means聚类并行推荐算法。该算法首先反复迭代二分K-means算法，迭代过程中使用簇内凝聚度作为分裂阈值，形成一颗满二叉树；然后通过层次遍历将用户归入到K个叶子节点（簇）；最后针对K个簇，应用MapReduce框架进行并行推荐预测。MovieLens上的实验结果表明，该算法可大幅度提高推荐系统准确性，同时增强系统可扩展性。
[2]
为提高输入信息较长时重复累积码的编码效率，对重复累积码的交织器进行优化改进。按照满二叉树子节点的奇偶排列方式对交织器的输入序列依次分组，并利用叶子节点对分组信息重新组合获得输出序列，与S随机交织器相比，大大降低输入信息之间的相关性，避免了RA码校验矩阵中I、II类4环的产生，保证了译码的准确性。仿真结果表明，在输入信息序列较长时，改进的交织器编码速度快且误码率远低于行列规则交织器；与S随机交织器相比，改进的交织器可以显著提高编码速率，且在误码率同为



时约有0.3dB的增益。
[3]
在AOV网中，若不存在回路，则所有活动可排列成一个线性序列，使得每个活动的所有前驱活动都排在该活动的前面，我们把此序列叫做拓扑序列(Topological order)。
设G=(V,E)是一个具有n个顶点的有向图，V中的顶点序列v1,v2,…,vn,满足若从顶点vi到vj有一条路径，则在顶点序列中顶点vi必在vj之前，则我们称这样的顶点序列为一个拓扑序列。
[1]
有向无环图（Directed Acyclic Graph, DAG）是有向图的一种，字面意思的理解就是图中没有环。常常被用来表示事件之间的驱动依赖关系，管理任务之间的调度。　　   AOV网：在每一个工程中，可以将工程分为若干个子工程，这些子工程称为活动。如果用图中的顶点表示活动，以有向图的弧表示活动之间的优先关系，这样的有向图称为AOV网，即顶点表示活动的网。在AOV网中，如果从顶点vi到顶点j之间存在一条路径，则顶点vi是顶点vj的前驱，顶点vj是顶点vi的后继。活动中的制约关系可以通过AOV网中的表示。 在AOV网中，不允许出现环，如果出现环就表示某个活动是自己的先决条件。因此需要对AOV网判断是否存在环，可以利用有向图的拓扑排序进行判断。
拓扑排序：拓扑排序是对一个有向图构造拓扑序列的过程。拓扑排序（Topological Sorting）是一个有向无环图（DAG, Directed Acyclic Graph）的所有顶点的线性序列。且该序列必须满足下面两个条件：　　  （1）每个顶点出现且只出现一次。　　  （2）若存在一条从顶点 A 到顶点 B 的路径，那么在序列中顶点 A 出现在顶点 B 的前面。
对于一个给定的有向图，得到其拓扑序列的步骤如下：　　①从图中选择一个人度为0的顶点，并输出该顶点；　　②从图中删除该顶点及其相关联的有向边，调整被删除有向边的终点的入度（人度减1）；　　③重复①和②；　　④直到所有顶点均被输出，拓扑序列完成；否则，无拓扑序列。　　可以证明，任何一个无环的有向图一定有拓扑序列，有环的有向图则无拓扑序列。
[2]
该排列满足：如果图中有一条从u到v的路径，则顶点v必须出现在顶点u之后。找出顶点活动网中的拓扑序列称“拓扑排序”。
拓扑排序既可用深度优先搜索，也可用广度优先搜索实现。
环路就是空间中一条闭合的连续曲线， 它和自身没有交点。 从代数拓扑的角度看， 环路就是从单位圆 到拓扑空间的一个单的连续映射。
环路是引进基本群概念的基础对象。
在图论中，环路就是指只有一个端点的边。
所有环路的形成都是由于目的路径不明确导致混乱而造成的。网络环路也分为第二层环路和第三层环路。第二层是指,一个广播信息经过两个交换机的时候会不断恶性循环的产生广播,造成环路 而第三层环路则是原路由于意外不能工作,造成路由通告错误,形成一个恶性循环 例子:网络192.168.0.0/24--路由1--路由2 正常192.168.0.0/24网络被路由1通告到路由2,当网络出问题不能达到的时候,路由1把192.168.0.0/24路由信息删除,但是路由2通告给了路由1,让路由1误以为路由2的那边能达到192.168.0.0/24网络,结果造成恶性循环(例子建立在RIP,IGRP等路由协议下,只有这两个协议会造成第三层环路)
归并操作(merge)，也叫归并算法，指的是将两个顺序序列合并成一个顺序序列的方法。
如　设有数列{6，202，100，301，38，8，1}
初始状态：6,202,100,301,38,8,1
第一次归并后：{6,202},{100,301},{8,38},{1}，比较次数：3；
第二次归并后：{6,100,202,301}，{1,8,38}，比较次数：4；
第三次归并后：{1,6,8,38,100,202,301},比较次数：4；
总的比较次数为：3+4+4=11；
逆序数为14；
归并操作的工作原理如下：
第一步：申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列
第二步：设定两个指针，最初位置分别为两个已经排序序列的起始位置
第三步：比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置
重复步骤3直到某一指针超出序列尾
将另一序列剩下的所有元素直接复制到合并序列尾
归并排序是稳定的排序.即相等的元素的顺序不会改变.如输入记录 1(1) 3(2) 2(3) 2(4) 5(5) (括号中是记录的关键字)时输出的 1(1) 2(3) 2(4) 3(2) 5(5) 中的2 和 2 是按输入的顺序.这对要排序数据包含多个信息而要按其中的某一个信息排序,要求其它信息尽量按输入的顺序排列时很重要。归并排序的比较次数小于快速排序的比较次数，移动次数一般多于快速排序的移动次数。
归并排序排序
（速度仅次于快速排序，为稳定排序算法，一般用于对总体无序，但是各子项相对有序的数列，应用见2011年普及复赛第3题“瑞士轮”的标程）
归并排序求逆序对数
具体思路是，在归并的过程中计算每个小区间的逆序对数，进而计算出大区间的逆序对数（也可以用树状数组来求解）
scala代码：
objectMainextendsApp{
    varreverse_pairs = 0//逆序数
    defmsort[T](cmp:(T, T) => Boolean)(l:List[T]):List[T] = {
        defmerge(l1:List[T], l2:List[T]):List[T]=(l1, l2)match{
            case(Nil, _) => l2
            case(_, Nil) => l1
            case(x::left1, y::left2) =>
                if(cmp(x, y))
                    x::merge(left1, l2)
                else{
                    reverse_pairs += l1.length
                    y::merge(l1, left2)
                }
        }
        valn = l.length / 2
        if(n == 0)
            return l
        else{
            val(l1, l2) = l.splitAt(n)
            merge(msort(cmp)(l1), msort(cmp)(l2))
        }
    }
    println(msort((x:Int, y:Int) => x<y)(List(5, 4, 3, 2, 7,6 )))
    println(reverse_pairs)
}
#include<cstdio>
const int MAXN=200005;
int n, a[MAXN], temp[MAXN];
long long ans;
void count(int l, int r)
{    
    if(r == l) return ;//结束条件
    int m = (l + r) >> 1;    count(l, m);
    count(m + 1, r);//二分查找
    int i = l, j = m + 1, k = l;
    while(j <= r || i <= m)    {
        if(j > r || (i <= m && a[i] < a[j]))
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++], ans += m - i + 1;    }
    for(i = l; i <= r; i++)        a[i] = temp[i];}
int main()
{    scanf("%d", &n);
    for(int i = 1; i <= n; i++)
        scanf("%d", &a[i]);        count(1, n);//调用函数
    printf("%lld", ans);//输出
    return 0;
}
归并排序原理
归并排序具体工作原理如下（假设序列共有n个元素）：
将序列每相邻两个数字进行归并操作（merge)，形成floor(n/2+n%2)个序列，排序后每个序列包含两个元素
将上述序列再次归并，形成floor(n/4)个序列，每个序列包含四个元素
重复步骤2，直到所有元素排序完毕
示例代码
Swift语言

//归并排序
func mergeSort(_ arr: inout [Int]) {
    var gap = 1;
    while gap < arr.count {
        mergePass(&arr, gap: gap);
        
        gap *= 2;
    }
}

//分解合并序列，gap表示子序列的元素个数
func mergePass(_ arr: inout [Int], gap: Int) {
    var i = 0;
    let count = arr.count;
    
    while i + 2 * gap - 1 < count {
        mergeArray(&arr, low: i, mid: i + gap - 1, high: i + 2 * gap - 1);
        
        i += 2 * gap;
    }
    
    //合并剩余的序列
    if i + gap - 1 < count {
        mergeArray(&arr, low: i, mid: i + gap - 1, high: count - 1);
    }
}

//合并两个序列
func mergeArray(_ arr: inout [Int], low: Int, mid: Int, high: Int) {
    
    var i = low;
    var j = mid + 1;
    var k = 0;
    
    var array = Array<Int>(repeating: 0, count: high - low + 1);
    
    while i <= mid && j <= high {
        if arr[i] < arr[j] {
            array[k] = arr[i];
            i += 1;
            k += 1;
        } else {
            array[k] = arr[j];
            j += 1;
            k += 1;
        }
    }
    
    while i <= mid {
        array[k] = arr[i];
        i += 1;
        k += 1;
    }
    
    while j <= high {
        array[k] = arr[j];
        j += 1;
        k += 1;
    }
    
    //将排序好的序列复制回原数组
    k = 0;
    for i in low...high {
        arr[i] = array[k];
        
        k += 1;
    }
}


var array = [2, 5, 8, 9, 10, 4, 3, 16, 1, 7, 8];
mergeSort(&array);
print(array);

Go语言
func mergeSort(r []int) []int {
    length := len(r)   
    if length <= 1 {
        return r 
    }   
    num := length / 2
    left := mergeSort(r[:num])   
    right := mergeSort(r[num:])   
    return merge(left, right)
}
func merge(left, right []int) (result []int) {   
    l, r := 0, 0   
    for l < len(left) && r < len(right) {
        if left[l] < right[r] {         
            result = append(result, left[l])         
            l++      
        } else {         
            result = append(result, right[r])         
            r++      
        }   
    }   
    result = append(result, left[l:]...)   
    result = append(result, right[r:]...)   
    return
}
Java语言
package MergeSort;
public class MergeSort {   
    public static int[] mergeSort(int[] nums, int l, int h) {
        if (l == h)
            return new int[] { nums[l] };
        
        int mid = l + (h - l) / 2;
        int[] leftArr = mergeSort(nums, l, mid); //左有序数组
        int[] rightArr = mergeSort(nums, mid + 1, h); //右有序数组
        int[] newNum = new int[leftArr.length + rightArr.length]; //新有序数组
        
        int m = 0, i = 0, j = 0; 
        while (i < leftArr.length && j < rightArr.length) {
            newNum[m++] = leftArr[i] < rightArr[j] ? leftArr[i++] : rightArr[j++];
        }
        while (i < leftArr.length)
            newNum[m++] = leftArr[i++];
        while (j < rightArr.length)
            newNum[m++] = rightArr[j++];
        return newNum;
    }
    public static void main(String[] args) {
        int[] nums = new int[] { 9, 8, 7, 6, 5, 4, 3, 2, 10 };
        int[] newNums = mergeSort(nums, 0, nums.length - 1);
        for (int x : newNums) {
            System.out.println(x);
        }
    }
}
C#语言
public static void Sort(int[] a, int f, int e)
{
    if (f < e)
    {
        int mid = (f + e) / 2;
        Sort(a, f, mid);
        Sort(a, mid + 1, e);
        MergeMethid(a, f, mid, e);
    }
}
private static void MergeMethid(int[] a, int f, int mid, int e)
{
    int[] t = new int[e - f + 1];
    int m = f, n = mid + 1, k = 0;
    while(n <= e && m <= mid)
    {
        if (a[m] > a[n]) t[k++] = a[n++];
        else t[k++] = a[m++];
    }
    while (n < e + 1) t[k++] = a[n++];
    while (m < mid + 1) t[k++] = a[m++];
    for (k = 0, m = f; m < e + 1; k++, m++) a[m] = t[k];
}
Python语言
def MergeSort(lists):
    if len(lists) <= 1:
        return lists
    num = int( len(lists) / 2 )
    left = MergeSort(lists[:num])
    right = MergeSort(lists[num:])
    return Merge(left, right)
def Merge(left,right):
    r, l=0, 0
    result=[]
    while l<len(left) and r<len(right):
        if left[l] <= right[r]:
            result.append(left[l])
            l += 1
        else:
            result.append(right[r])
            r += 1
    result += list(left[l:])
    result += list(right[r:])
    return result
print MergeSort([1, 2, 3, 4, 5, 6, 7, 90, 21, 23, 45])
C语言
#include <stdlib.h>
#include <stdio.h>

void Merge(int sourceArr[],int tempArr[], int startIndex, int midIndex, int endIndex)
{
    int i = startIndex, j=midIndex+1, k = startIndex;
    while(i!=midIndex+1 && j!=endIndex+1)
    {
        if(sourceArr[i] > sourceArr[j])
            tempArr[k++] = sourceArr[j++];
        else
            tempArr[k++] = sourceArr[i++];
    }
    while(i != midIndex+1)
        tempArr[k++] = sourceArr[i++];
    while(j != endIndex+1)
        tempArr[k++] = sourceArr[j++];
    for(i=startIndex; i<=endIndex; i++)
        sourceArr[i] = tempArr[i];
}

//内部使用递归
void MergeSort(int sourceArr[], int tempArr[], int startIndex, int endIndex)
{
    int midIndex;
    if(startIndex < endIndex)
    {
        midIndex = startIndex + (endIndex-startIndex) / 2;//避免溢出int
        MergeSort(sourceArr, tempArr, startIndex, midIndex);
        MergeSort(sourceArr, tempArr, midIndex+1, endIndex);
        Merge(sourceArr, tempArr, startIndex, midIndex, endIndex);
    }
}

int main(int argc, char * argv[])
{
    int a[8] = {50, 10, 20, 30, 70, 40, 80, 60};
    int i, b[8];
    MergeSort(a, b, 0, 7);
    for(i=0; i<8; i++)
        printf("%d ", a[i]);
    printf("\n");
    return 0;
}
PHP语言
//merge函数将指定的两个有序数组(arr1,arr2)合并并且排序
//我们可以找到第三个数组,然后依次从两个数组的开始取数据哪个数据小就先取哪个的,然后删除掉刚刚取过///的数据
function al_merge($arrA,$arrB)
{
    $arrC = array();
    while(count($arrA) && count($arrB)){
        //这里不断的判断哪个值小,就将小的值给到arrC,但是到最后肯定要剩下几个值,
        //不是剩下arrA里面的就是剩下arrB里面的而且这几个有序的值,肯定比arrC里面所有的值都大所以使用
        $arrC[] = $arrA['0'] < $arrB['0'] ? array_shift($arrA) : array_shift($arrB);
    }
    return array_merge($arrC, $arrA, $arrB);
}
//归并排序主程序
function al_merge_sort($arr){
    $len = count($arr);
    if($len <= 1)
        return $arr;//递归结束条件,到达这步的时候,数组就只剩下一个元素了,也就是分离了数组
    $mid = intval($len/2);//取数组中间
    $left_arr = array_slice($arr, 0, $mid);//拆分数组0-mid这部分给左边left_arr
    $right_arr = array_slice($arr, $mid);//拆分数组mid-末尾这部分给右边right_arr
    $left_arr = al_merge_sort($left_arr);//左边拆分完后开始递归合并往上走
    $right_arr = al_merge_sort($right_arr);//右边拆分完毕开始递归往上走
    $arr = al_merge($left_arr, $right_arr);//合并两个数组,继续递归
    return $arr;
}
$arr = array(12, 5, 4, 7, 8, 3, 4, 2, 6, 4, 9);
print_r(al_merge_sort($arr));
Pascal语言
program　mergesort_1;
const maxn=7;
type
    arr=array[1..maxn] of integer;
var
    a,b,c:arr;
    i:integer;
procedure merge(r:arr; l,m,n:integer; var r2:arr);
    var
        i,j,k,p:integer;
    begin
        i:=l;
        j:=m+1;
        k:=l-1;
        while (i<=m) and (j<=n) do begin
            k:=k+1;
            if r[i]<=r[j] then begin
                r2[k]:=r[i];
                i:=i+1
            end
            else begin
                r2[k]:=r[j];
                j:=j+1;
            end
        end;
        if i<=m then for p:=i to m do begin
            k:=k+1;
            r2[k]:=r[p];
        end;
        if j<=n then for p:=j to n do begin
            k:=k+1;
            r2[k]:=r[p];
        end;
    end;
procedure mergesort(var r,r1:arr; s,t:integer);
    var
        k:integer; c:arr;
    begin
        if s=t then r1[s]:=r[s]
        else begin
            k:=(s+t)div2;
            mergesort(r,c,s,k);
            mergesort(r,c,k+1,t);
            merge(c,s,k,t,r1)
        end;
    end;
begin
    write('Enterdata:');
    for i:=1 to maxn do read(a[i]);
    mergesort(a,b,1,maxn);
    for i:=1 to maxn do write(b[i]:9);
    writeln;
end.
//============================================
program mergesort_2;
const max=100000;
var
    a,r:array[1..max] of longint;
    n,i:longint;
procedure msort(s,t:longint);
    var
        m,i,j,k:longint;
    begin
        if s=t then exit;
        m:=(s+t) div 2;
        msort(s,m);
        msort(m+1,t);
        i:=s;
        j:=m+1;
        k:=s;
        while (i<=m) and (j<=t) do begin
            if a[i]<a[j] then begin
                r[k]:=a[i];
                inc(i);
                inc(k);
            end
            else begin
                r[k]:=a[j];
                inc(j);
                inc(k);
            end;
        end;
        while i<=m do begin
            r[k]:=a[i];
            inc(i);
            inc(k);
        end;
        while j<=t do begin
            r[k]:=a[j];
            inc(j);
            inc(k);
        end;
        for i:=s to t do a[i]:=r[i];
    end;
begin
    readln(n);
    for i:=1 to n do read(a[i]);
    msort(1,n);
    for i:=1 to n do writeln(a[i]);
end.
Basic语言
Sub MergeSort(Array() As Integer, First As Integer, Last As Integer)
Dim mid As Integer = 0
If first<last Then
 mid = (first+last)\ 2
MergeSort(Array, first, mid);
MergeSort(Array, mid+1, last);
Merge(Array, first, mid, last);
End If
End Sub
/*
以下示例代码实现了归并操作。array[]是元素序列，其中从索引p开始到q位置，按照升序排列，同时，从(q+1)到r也已经按照升序排列，merge()函数将把这两个已经排序好的子序列合并成一个排序序列。结果放到array中。
*/
/**
* 0 <= p <= q < r, subarray array[p..q] and array[q+1..r] are already sorted.
* the merge() function merges the two sub-arrays into one sorted array.
*/
void Merge(int array[], int p, int q, int r)
{
    int i,k;
    int begin1,end1,begin2,end2;
    int* temp = (int*)malloc((r-p+1)*sizeof(int));
    begin1 = p;
    end1   = q;
    begin2 = q+1;
    end2   = r;
    k = 0;
    while((begin1 <= end1)&&( begin2 <= end2))
    {
        if(array[begin1] <= array[begin2]){ 
            temp[k] = array[begin1];
            begin1++;
        }
        else
        {
            temp[k] = array[begin2];
            begin2++;
        }
        k++;
    }
    while(begin1<=end1 || begin2<=end2)
    {
        if(begin1<=end1)
        {
            temp[k++] = array[begin1++];
        }
        if(begin2<=end2)
        {
            temp[k++] = array[begin2++];
        }
        }
        for (i = 0; i < =(r - p); i++)
            array[p+i] = temp[i];
    free(temp);
}
JavaScript语言
使用递归的代码如下。优点是描述算法过程思路清晰，缺点是使用递归，mergeSort()函数频繁地自我调用。长度为n的数组最终会调用mergeSort()函数 2n-1次，这意味着一个长度超过1500的数组会在Firefox上发生栈溢出错误。可以考虑使用迭代来实现同样的功能。
function　merge(left, right){
    var　result=[];
    while(left.length>0 && right.length>0){
        if(left[0]<right[0]){
        /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
            result.push(left.shift());
        }else{
            result.push(right.shift());
        }
    }
    return　result.concat(left).concat(right);
}
function　mergeSort(items){
    if(items.length == 1){
        return　items;
}
var　middle = Math.floor(items.length/2),
    left = items.slice(0, middle),
    right = items.slice(middle);
    return　merge(mergeSort(left), mergeSort(right));
}
非递归算法 （javaScript）
function mergePass(arr = [], temp = new Array(arr.length), N = arr.length, length = 1){ // 将每个元素看作是相邻的数组长度为1。
  let t; // 迭代深度。
  for (t = 0; Math.pow(2,t) < N; t++, length *= 2) { // 每次跳过的长度翻倍。
    const even = t%2 === 0; // 复用 arr 和 temp 来回赋值。
    for (let left = 0;  left < N; left += 2 * length) { // 左边数组起始位置 left 从0开始。
      const middle = left + length < N ? left + length : left; // 右边数组起始位置 middle 就是left + 一个数组长度length 但是不要超过 N 。
      const right = left + (2 * length) < N ? left + (2 * length) : N; // 右边界 right 就是 left + 两个数组长度。
      merge(even ? arr : temp, even ? temp : arr, left, middle, right); // 合并每两个相邻的数组。
    }
  }
  if(t % 2 === 0){
        return arr;//返回arr
    }
  return temp; // 返回 temp 。
}
function merge(arr, temp, left, middle, right){
  const leftEnd = middle - 1; // 通过右边数组的起始位置得到左边数组的结束位置。
  while (left <= leftEnd && middle < right) { // 如果‘指针’没有越界。
    if (arr[left] > arr[middle]) { // 如果左边数组第一个元素比右边数组第一个元素大。
      temp[left + middle - leftEnd -1] = arr[middle++]; // 将右边数组最小的放入有序数组 temp（初始值为空)。
    } else {
      temp[left + middle - leftEnd -1] = arr[left++]; // 将左边数组最小的放入有序数组 temp（初始值为空)。
    }
  }
  while(left > leftEnd && middle < right){ // 如果左边数组放完了，右边数组还有元素。
    temp[left + middle - leftEnd -1] = arr[middle++]; // 那么依次将右边数组剩余的元素放入 temp 。
  }
  while(left <= leftEnd && middle >= right){ // 如果右边数组放完了，左边数组还有元素
    temp[left + middle - leftEnd -1] = arr[left++]; // 那么依次将左边数组剩余的元素放入 temp 。
  }
}
非递归算法（C++）
#include<iostream>
#include<ctime>
#include<cstring>
#include<cstdlib>
using namespace std;
/**将a开头的长为length的数组和b开头长为right的数组合并n为数组长度，用于最后一组*/
void　Merge(int*　data,int　a,int　b,int　length,int　n){
　int　right;
　if(b+length-1 >= n-1)　right = n-b;
　else　right = length;
　int*　temp = new　int[length+right];
　int　i=0, j=0;
　while(i<=length-1 && j<=right-1){
    　if(data[a+i] <= data[b+j]){
    　    temp[i+j] = data[a+i];i++;
      }
    　else{
        temp[i+j] = data[b+j];
        j++;
      }
　}
　if(j == right){//a中还有元素，且全都比b中的大,a[i]还未使用
　  memcpy(temp + i + j, data + a + i, (length - i) * sizeof(int));
　}
  else if(i == length){
      memcpy(temp + i + j, data + b + j, (right - j)*sizeof(int));
  }
　memcpy(data+a, temp, (right + length) * sizeof(int));
　delete [] temp;
}
void　MergeSort(int*　data, int　n){
　int　step = 1;
　while(step < n){
    　for(int　i=0; i<=n-step-1; i+=2*step)
    　    Merge(data, i, i+step, step, n);
    //将i和i+step这两个有序序列进行合并
    //序列长度为step
    //当i以后的长度小于或者等于step时，退出
    　step*=2;//在按某一步长归并序列之后，步长加倍
　}
}
int　main(){
　int　n;
　cin>>n;
　int*　data = new　int[n];
　if(!data)　exit(1);
　int　k = n;
　while(k--){
　    cin>>data[n-k-1];
　}
　clock_t　s = clock();
　MergeSort(data, n);
　clock_t　e = clock();
　k=n;
　while(k--){
　    cout<<data[n-k-1]<<' ';
　}
　cout<<endl;
　cout<<"the algorithm used"<<e-s<<"miliseconds."<<endl;
　delete　data;
　return　0;
}

递归算法：
#include<iostream>
using namespace std;
void merge(int *data, int start, int mid, int end, int *result)
{
    int i, j, k;
    i = start;
    j = mid + 1;                        //避免重复比较data[mid]
    k = 0;
    while (i <= mid && j <= end)        //数组data[start,mid]与数组(mid,end]均没有全部归入数组result中去
    {
        if (data[i] <= data[j])         //如果data[i]小于等于data[j]
            result[k++] = data[i++];    //则将data[i]的值赋给result[k]，之后i,k各加一，表示后移一位
        else
            result[k++] = data[j++];    //否则，将data[j]的值赋给result[k]，j,k各加一
    }
    while (i <= mid)                    //表示数组data(mid,end]已经全部归入result数组中去了，而数组data[start,mid]还有剩余
        result[k++] = data[i++];        //将数组data[start,mid]剩下的值，逐一归入数组result
    while (j <= end)                    //表示数组data[start,mid]已经全部归入到result数组中去了，而数组(mid,high]还有剩余
        result[k++] = data[j++];        //将数组a[mid,high]剩下的值，逐一归入数组result

    for (i = 0; i < k; i++)             //将归并后的数组的值逐一赋给数组data[start,end]
        data[start + i] = result[i];    //注意，应从data[start+i]开始赋值
}
void merge_sort(int *data, int start, int end, int *result)
{
    if (start < end)
    {
        int mid = start + (end-start) / 2;//避免溢出int
        merge_sort(data, start, mid, result);                    //对左边进行排序
        merge_sort(data, mid + 1, end, result);                  //对右边进行排序
        merge(data, start, mid, end, result);                    //把排序好的数据合并
    }
}
void amalgamation(int *data1, int *data2, int *result)
{
    for (int i = 0; i < 10; i++)
        result[i] = data1[i];
    for (int i = 0; i < 10; i++)
        result[i + 10] = data2[i];
}
int main()
{
    int data1[10] = { 1,7,6,4,9,14,19,100,55,10 };
    int data2[10] = { 2,6,8,99,45,63,102,556,10,41 };
    int *result = new int[20];                              
    int *result1 = new int[20];
    amalgamation(data1, data2, result);
    for (int i = 0; i < 20; ++i)
        cout << result[i] << "  ";
    cout << endl;
    merge_sort(result, 0, 19, result1);
    for (int i = 0; i < 20; ++i)
        cout << result[i] << "  ";
    delete[]result;
    delete[]result1;
    return 0;
}
二路归并

Const
FI='in.txt';
FO='out.txt';
MaxN=10000;
Type
TIndex=Longint;
TDat=Array[0..MaxN]OfTIndex;
Var
N:TIndex;
Dat:TDat;
Tmp:TDat;
ProcedureMerge(L,Mid,R:TIndex);
Var
P1,P2:TIndex;
E1,E2:TIndex;
P:TIndex;
I:TIndex;
Begin
P1:=L;
P2:=Mid+1;
P:=L;
Repeat
If(Dat[P1]<=Dat[P2])Then
Begin
Tmp[P]:=Dat[P1];
Inc(P1);
Inc(P);
End
Else
Begin
Tmp[P]:=Dat[P2];
Inc(P2);
Inc(P);
End;
Until(P1=Mid+1)Or(P2=R+1);
If(P1=Mid+1)Then
Begin
E1:=P2;
E2:=R;
End
Else
Begin
E1:=P1;
E2:=Mid;
End;
ForI:=E1ToE2Do
Begin
Tmp[P]:=Dat[I];
Inc(P);
End;
End;
ProcedureSort(L,R:TIndex);
Var
Mid:TIndex=0;
Begin
Mid:=(L+R)Shr1;
If(L<Mid)Then
Sort(L,Mid);
If(Mid+1<R)Then
Sort(Mid+1,R);
Merge(L,Mid,R);
ForMid:=LToRDo
Dat[Mid]:=Tmp[Mid];
End;
ProcedureInit;
Var
I:TIndex;
Begin
FillChar(Dat,SizeOf(Dat),0);
Readln(N);
ForI:=1ToNDo
Read(Dat[I]);
End;
ProcedureMain;
Begin
Sort(1,N);
End;
ProcedureFinal;
Var
I:TIndex;
Begin
ForI:=1ToNDo
Write(Dat[I],'');
Writeln;
End;
Begin
Assign(Input,FI);
Assign(Output,FO);
Reset(Input);
Rewrite(Output);
Init;
Main;
Final;
Close(Input);
Close(Output);
End.

Delphi
归并排序完整源代码例子：
//合并子函数
procedureTForm1.MergePass(vardatas:arrayofInteger;left,mid,
right:Integer);
var
tmpArr:arrayofInteger;
arrLen:Integer;
i,k:Integer;
begin1,begin2,end1,end2:Integer;
begin
arrLen:=right-left+1;
SetLength(tmpArr,arrLen);
begin1:=left;
end1:=mid;
begin2:=mid+1;
end2:=right;
k:=0;
while((begin1<=end1)and(begin2<=end2))do
begin
if(datas[begin1]<datas[begin2])then
begin
tmpArr[k]:=datas[begin1];
Inc(begin1);
end
else
begin
tmpArr[k]:=datas[begin2];
Inc(begin2);
end;
inc(k);
end;
while(begin1<=end1)do
begin
tmpArr[k]:=datas[begin1];
Inc(begin1);
Inc(k);
end;
while(begin2<=end2)do
begin
tmpArr[k]:=datas[begin2];
Inc(begin2);
Inc(k);
end;
fori:=0to(right-left)do
begin
datas[left+i]:=tmpArr[i];
end;
end;
//排序主函数，left是数组左下标，0开始。right是数组右下标。
procedureTForm1.MergeSort(vardatas:arrayofInteger;left,right:Integer);
var
mid:Integer;
i:Integer;
begin
mid:=0;
if(left<right)then
begin
mid:=(right+left)div2;
showLog('中间索引：'+inttostr(mid));
MergeSort(datas,left,mid);
MergeSort(datas,mid+1,right);
MergePass(datas,left,mid,right);
showLog('--->'+getArrayString(datas));//显示数组中间状态
end;
end;
//调用方法：procedureTForm1.btn1Click(Sender:TObject);
var
inArr:array[0..9]ofInteger;
begin
CopyMemory(@inArr[0],@CTabls[0],SizeOf(Integer)*10);
showLog('输入数据：'+getArrayString(inArr));
MergeSort(inArr,0,High(inArr));
showLog('输出数据：'+getArrayString(inArr));
end;
归并排序比较占用内存，但却是一种效率高且稳定的算法。
改进归并排序在归并时先判断前段序列的最大值与后段序列最小值的关系再确定是否进行复制比较。如果前段序列的最大值小于等于后段序列最小值，则说明序列可以直接形成一段有序序列不需要再归并，反之则需要。所以在序列本身有序的情况下时间复杂度可以降至O(n)
TimSort可以说是归并排序的终极优化版本，主要思想就是检测序列中的天然有序子段（若检测到严格降序子段则翻转序列为升序子段）。在最好情况下无论升序还是降序都可以使时间复杂度降至为O(n)，具有很强的自适应性。
最好时间复杂度最坏时间复杂度平均时间复杂度空间复杂度稳定性传统归并排序O(nlogn)O(nlogn)O(nlogn)T(n)稳定改进归并排序
[1] 
O(n)O(nlogn)O(nlogn)T(n)稳定TimSortO(n)O(nlogn)O(nlogn)T(n)稳定
注：文献
[1] 
是一种改进的原地归并算法，空间复杂度为O(1)。在表格里的改进归并排序只是引入其预先判断的这一步，这样便可使传统归并排序时间复杂度降至O(n)。
定义
所谓归并排序是指将两个或两个以上有序的数列（或有序表），合并成一个仍然有序的数列（或有序表）。这样的排序方法经常用于多个有序的数据文件归并成一个有序的数据文件。归并排序的算法比较简单。
基本思想方法：
（1）假设已经有两个有序数列，分别存放在两个数组s，r中；并设i，j分别为指向数组的第一个单元的下标；s有n个元素，r有m个元素。
（2）再另设一个数组a，k指向该数组的第一个单元下标。
（3）算法分析（过程）：
proceduremerge(s,r,a,i,j,k);
begin
i1:=i;
j1:=j;
k1:=k;
while(i1<n)and(j1<m)do
ifs[i1]<=r[j1]then
begin
a[k]:=s[i1];
i1:=i1+1;
k:=k+1;
end
else
begin
a[k]:=r[j1];
j1:=j1+1;
k:=k+1;
end;
whilei1<=ndo
begin
a[k]:=s[i1];
i1:=i1+1;
k:=k+1;
end;
whilej1<=mdo
begin
a[k]:=r[j1];
j1:=j1+1;
k:=k+1;
end;
end;
完整的C++源代码
#include <iostream>

void Merge(int r[], int r1[], int s, int m, int t)
{
    int i = s;
    int j = m + 1;
    int k = s;
    while (i <= m && j <= t)
    {
        if (r[i] <= r[j])
            r1[k++] = r[i++];
        else
            r1[k++] = r[j++];
    }
    if (i <= m)
        while (i <= m)
            r1[k++] = r[i++];
    else
        while (j <= t)
            r1[k++] = r[j++];
    for (int n = s; n <= t; n++)
        r[n] = r1[n];
}

void MergeSort(int r[], int r1[], int s, int t)
{
    if (s < t)
    {
        int m = (s + t) / 2;
        MergeSort(r, r1, s, m);
        MergeSort(r, r1, m + 1, t);
        Merge(r, r1, s, m, t);
    }
}

int main()
{
    int r[8] = {10, 3, 5, 1, 9, 34, 54, 565}, r1[8];
    MergeSort(r, r1, 0, 7);
    for (int q = 0; q < 8; q++)
        std::cout << r[q] << std::ends;
    return 0;
}

归并排序的实现方法：
1.自底向上算法
#include<stdio.h>
#include<time.h>
voidMerge(int*a,intlow,intmid,inthigh){
inti=low,j=mid+1,k=0;
int*temp=(int*)malloc((high-low+1)*sizeof(int));
while(i<=mid&&j<=high)
a[i]<=a[j]?(temp[k++]=a[i++]):(temp[k++]=a[j++]);
while(i<=mid)
temp[k++]=a[i++];
while(j<=high)
temp[k++]=a[j++];
memcpy(a+low,temp,(high-low+1)*sizeof(int));
free(temp);
}
voidMergeSort(int*a,intn){
intlength;
for(length=1;length<n;length*=2){
inti;
for(i=0;i+2*length-1<=n-1;i+=2*length)
Merge(a,i,i+length-1,i+2*length-1);
if(i+length<=n-1)//尚有两个子文件，其中后一个长度小于length
　Merge(a,i,i+length-1,n-1);
}
}
intmain(){
intn;
cin>>n;
int*data=new
int[n];
if(!data)
exit(1);
intk=n;
while(k--){
cin>>data[n-k-1];
}
clock_ts=clock();
MergeSort(data,n);
clock_te=clock();
k=n;
while(k--){
cout<<data[n-k-1]<<'';
}
cout<<endl;
cout<<"thealgrothemused"<<e-s<<"miliseconds."<<endl;
deletedata;
return0;
}
2.自顶向下
voidMerge(intr[],intr1[],ints,intm,intt){
inti=s;
intj=m+1;
intk=s;
while(i<=m&&j<=t){
if(r[i]<=r[j])
r1[k++]=r[i++];
else
r1[k++]=r[j++];
}
while(i<=m)
r1[k++]=r[i++];
while(j<=t)
r1[k++]=r[j++];
for(intl=0;l<8;l++)
r[l]=r1[l];
}

voidMergeSort(intr[],intr1[],ints,intt){
if(s==t)
;
else{
intm=(s+t)/2;
MergeSort(r,r1,s,m);
MergeSort(r,r1,m+1,t);
Merge(r,r1,s,m,t);
}
}
NOIP2013 提高组火柴排队
#include<bits/stdc++.h>
using namespace std;
int c[1000005],t[1000005],mod=99999997;
long long cnt=0;
struct edge{
    int num,i;
}a[1000005],b[1000005];
void merge(int l,int r)
{
    if(l==r)
        return;
    int mid=(l+r)/2;
    merge(l,mid);
    merge(mid+1,r);
    int x=l,y=mid+1,tot=l;
    while(x<=mid&&y<=r)
        if(c[x]<=c[y])
            t[tot++]=c[x++];
        else
        {
             cnt+=(mid-x+1)%mod;
             cnt%=mod;
             t[tot++]=c[y++];
        }
    while(x<=mid)
        t[tot++]=c[x++];
    while(y<=r)
        t[tot++]=c[y++];
    for(int i=l;i<= r;++i)
        c[i]=t[i];
}
bool cmp(edge a,edge b)
{
    return a.num<b.num;
}
int main()
{
    int n;
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>a[i].num;
        a[i].i=i;
    }
    for(int i=1;i<=n;++i)
    {
        cin>>b[i].num;
        b[i].i=i;
    }
    sort(a+1,a+n+1,cmp);
    sort(b+1,b+n+1,cmp);
    for(int i=1;i<=n;++i)
        c[a[i].i]=b[i].i;
    merge(1,n);
    cout<<cnt<<endl;
    return 0;
}
本书围绕算法设计技术组织素材，对每种算法技术选择了多个典型范例进行分析。本书将直观性与严谨性完美地结合起来。每章从实际问题出发，经过具体、深入、细致的分析，自然且富有启发性地引出相应的算法设计思想，并对算法的正确性、复杂性进行恰当的分析、认证。
本书是近年来关于算法设计和分析的不可多得的优秀教材。本书覆盖的面较宽，凡属串行算法的经典论题都有涉及，并且论述深入有新意。全书共200多道丰富而精彩的习题是本书的重要组成部分，也是本书的突出特色之一。
[2]
以各种算法设计技术（如贪心法、分治策略、动态规划、网络流、近似算法、随机算法等）为主线来组织素材，突出了算法设计的思想和分析的基本原则，为从事实际问题的算法设计与分析工作提供了清晰的、整体的思路和方法。
本教材内容非常丰富，不但深入系统地阐述了算法设计与分析的理论，而且给出了大量的典型范例和参考文献。
本教材以算法为主线来处理算法与数据结构的关系。这种安排突出了算法设计的中心思想，避免了与数据结构课程在内容上的重复，更加适合于国内的教学计划。
本教材的叙述和选材非常适合教学。内容由浅入深，由具体到抽象，从算法设计技术与分析方法自然过渡到计算复杂性理论，选配了大量难度适当的练习，并给出求解范例。
第1章　引言：某些典型的问题
1.1　第一个问题：稳定匹配
1.2　五个典型问题
带解答的练习
练习
注释和进一步的阅读
第2章　算法分析基础
2.1　计算可解性
2.2　增长的渐近阶
2.3　用表和数组实现稳定匹配算法
2.4　一般运行时间的概述
2.5　更复杂的数据结构：优先队列
带解答的练习
练习
注释和进一步的阅读
第3章　图
3.1　基本定义与应用
3.2　图的连通性与图的遍历
3.3　用优先队列与栈实现图的遍历
3.4　二分性测试：宽度优先搜索的一个应用
3.5　有向图中的连通性
3.6　有向无圈图与拓扑排序
带解答的练习
练习
注释和进一步的阅读
第4章　贪心算法
4.1　区间调度：贪心算法领先
4.2　最小延迟调度：一个交换论证
4.3　最优高速缓存：一个更复杂的交换论证
4.4　一个图的最短路径
4.5　最小生成树问题
4.6　实现Kruskal算法：Unoin－Find数据结构
4.7　聚类
4.8　Huffman码与数据压缩
4.9　最小费用有向树：一个多阶段贪心
带解答的练习
练习
注释和进一步的阅读
第5章　分治策略
5.1　第一个递推式：归并排序算法
5.2　更多的递推关系
5.3　计数逆序
5.4　找最接邻近的点对
5.5　整数乘法
5.6　卷积与快速傅里叶变换
带解答的练习
练习
注释和进一步的阅读
第6章　动态规划
6.1　带权的区间调度：一个递归过程
6.2　动态规划原理：备忘录或者子问题迭代
6.3　分段的最小二乘：多重选择
6.4　子集和与背包：加一个变量
6.5　RNA二级结构：在区间上的动态规划
6.6　序列比对
6.7　通过分治策略在线性空间的序列比对
6.8　图中的最短路径
6.9　最短路径和距离向量协议
6.10　图中的负圈
带解答的练习
练习
注释和进一步的阅读
第7章　网络流
第8章　Ng与计算的难解性
第9章　一个超出
第10章　扩展易解性的界限
第11章　近似算法
第12章　局部搜索
第13章　随机算法
后记：永不停止运行的算法
索引
事实上，深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search.其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次.
举例说明之：下图是一个无向图，如果我们从A点发起深度优先搜索（以下的访问次序并不是唯一的，第二个点既可以是B也可以是C,D），则我们可能得到如下的一个访问过程：A->B->E（没有路了！回溯到A)->C->F->H->G->D（没有路，最终回溯到A,A也没有未访问的相邻节点，本次搜索结束）.




图

简要说明深度优先搜索的特点：每次深度优先搜索的结果必然是图的一个连通分量.深度优先搜索可以从多点发起.如果将每个节点在深度优先搜索过程中的"结束时间"排序（具体做法是创建一个list，然后在每个节点的相邻节点都已被访问的情况下，将该节点加入list结尾，然后逆转整个链表)，则我们可以得到所谓的"拓扑排序",即topological sort.
[1]
深度优先遍历图的方法是，从图中某顶点v出发：
（1）访问顶点v；
（2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；
（3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。　当然，当人们刚刚掌握深度优先搜索的时候常常用它来走迷宫.事实上我们还有别的方法，那就是广度优先搜索(BFS).
在我们遇到的一些问题当中，有些问题我们不能够确切的找出数学模型，即找不出一种直接求解的方法，解决这一类问题，我们一般采用搜索的方法解决。搜索就是用问题的所有可能去试探，按照一定的顺序、规则，不断去试探，直到找到问题的解，试完了也没有找到解，那就是无解，试探时一定要试探完所有的情况（实际上就是穷举）；
[2]
对于问题的第一个状态，叫初始状态，要求的状态叫目标状态。
搜索就是把规则应用于实始状态，在其产生的状态中，直到得到一个目标状态为止。
产生新的状态的过程叫扩展（由一个状态，应用规则，产生新状态的过程）
搜索的要点：（1）初始状态；
（2）重复产生新状态；
（3）检查新状态是否为目标，是结束，否转（2）；
[1]
如果搜索是以接近起始状态的程序依次扩展状态的，叫宽度优先搜索。
如果扩展是首先扩展新产生的状态，则叫深度优先搜索。
深度优先搜索
深度优先搜索用一个数组存放产生的所有状态。
（1） 把初始状态放入数组中，设为当前状态；
（2） 扩展当前的状态，产生一个新的状态放入数组中，同时把新产生的状态设为当前状态；
（3） 判断当前状态是否和前面的重复，如果重复则回到上一个状态，产生它的另一状态；
（4） 判断当前状态是否为目标状态，如果是目标，则找到一个解答，结束算法。
（5） 如果数组为空，说明无解。
对于pascal语言来讲，它支持递归，在递归时可以自动实现回溯（利用局部变量）所以使用递归编写深度优先搜索程序相对简单，当然也有非递归实现的算法。
[3]
搜索是人工智能中的一种基本方法，是一项非常普遍使用的算法策略，能够解决许许多多的常见问题，在某些情况下我们很难想到高效的解法时，搜索往往是可选的唯一选择。按照标准的话来讲：搜索算法是利用计算机的高性能来有目的的穷举一个问题的部分或所有的可能情况，从而求出问题的解的一种方法。
搜索虽然简单易学易于理解，但要掌握好并写出速度快效率高优化好的程序却又相当困难，总而言之，搜索算法灵活多变，一般的框架很容易写出，但合适的优化却要根据实际情况来确定。在搜索算法中，深度优先搜索（也可以称为回溯法）是搜索算法里最简单也最常见的，今天我们就从这里讲起，下面的内容假设读者已经知道最基本的程序设计和简单的递归算法。
所有的搜索算法从其最终的算法实现上来看，都可以划分成两个部分──控制结构和产生系统。正如前面所说的，搜索算法简而言之就是穷举所有可能情况并找到合适的答案，所以最基本的问题就是罗列出所有可能的情况，这其实就是一种产生式系统。
[2]
我们将所要解答的问题划分成若干个阶段或者步骤，当一个阶段计算完毕，下面往往有多种可选选择，所有的选择共同组成了问题的解空间，对搜索算法而言，将所有的阶段或步骤画出来就类似是树的结构（如图）。
从根开始计算，到找到位于某个节点的解，回溯法（深度优先搜索）作为最基本的搜索算法，其采用了一种“一只向下走，走不通就掉头”的思想（体会“回溯”二字），相当于采用了先根遍历的方法来构造搜索树。
上面的话可能难于理解，没关系，我们通过基本框架和例子来阐述这个算法，你会发现其中的原理非常简单自然。
·dfs(状态)
[3]
–if 状态 是 目标状态then
·dosomething
–else
·for 每个新状态
–if 新状态合法
»dfs(新状态)
·主程序：
·dfs(初始状态)
定义一个结构体来表达一个NODE的结构：
[2]
struct Node  {    int self; //数据     node *left; //左节点     node *right; //右节点  };
那么我们在搜索一个树的时候，从一个节点开始，能首先获取的是它的两个子节点。
[2] 
例如：
“
                A           B           C      D   E          F   G
”
A是第一个访问的，然后顺序是B和D、然后是E。然后再是C、F、G。那么我们怎么来保证这个顺序呢？
[3]
这里就应该用堆叠的结构，因为堆叠是一个先进后出的顺序。通过使用C++的STL，下面的程序能帮助理解：
“
    const int TREE_SIZE = 9; 
    std::stack<node*> visited, unvisited; 
    node nodes[TREE_SIZE]; 
    node* current; 
    for( int i=0; i<TREE_SIZE; i++) //初始化树 
        {    
            nodes[i].self = i;   
            int child = i*2+1;    
            if( child<TREE_SIZE ) //Left child       
            nodes[i].left = &nodes[child];    
            else nodes[i].left = NULL;    
            child++;    
            if( child<TREE_SIZE ) //Right child           
            nodes[i].right = &nodes[child];    
            else       nodes[i].right = NULL;
        }             
     unvisited.push(&nodes[0]); //先把0放入UNVISITED stack  
     while(!unvisited.empty()) //只有UNVISITED不空  
     {    
         current=(unvisited.top()); //当前应该访问的    
         unvisited.pop();      
         if(current->right!=NULL)     
         unvisited.push(current->right); // 把右边压入 因为右边的访问次序是在左边之后     
         if(current->left!=NULL)     
         unvisited.push(current->left);     
         visited.push(current);     
         cout<<current->self<<endl; 
      }
”
这道题来举例（迷宫）
1
1
1
1
0
1
0
1
0
1
0
1
0
1
1
1
记录起点为（1,1）找到所有的到（4,4）的路径.
pascal程序如下：
const
b:array[1..4,1..4]of integer=(（1,1,1,1）,(0,1,0,1）,(0,1,0,1）,(0,1,1,1）);
c:array[1..4,1..2]of -1..1=((0,1）,(0,-1）,（1,0),(-1,0));
var
a:array[1..16,1..2]of integer;
procedure print;
var
i,j:integer;
begin
for i:=1 to 4 do
begin
for j:=1 to 4 do
write(b[i,j]:3）;
writeln;
end;
writeln('--------------');
end;
procedure try(k:integer);
var
i:integer;
begin
if (a[k,1]=4）and(a[k,2]=4） then
begin
print;
exit;
end;
for i:=1 to 4 do
begin
a[k+1,1]:=a[k,1]+c[i,1];
a[k+1,2]:=a[k,2]+c[i,2];
if (a[k+1,1]>=1） and (a[k+1,1]<=4 )and (a[k+1,2]>=1） and (a[k+1,2]<=4） and
（b[a[k+1,1],a[k+1,2]]=1） then
begin
b[a[k+1,1],a[k+1,2]]:=2;
try(k+1）;
b[a[k+1,1],a[k+1,2]]:=1;
end;
end;
end;
begin
a[1,1]:=1;
a[1,2]:=1;
b[1,1]:=2;
try（1）;
end.
这个程序的意思就是：进行搜索一条路，直到不能走为止，换另一条路。
有限长序列可以通过离散傅里叶变换(DFT）将其频域也离散化




快速傅里叶变换

成有限长序列。但其计算量太大，很难实时地处理问题，因此引出了快速傅里叶变换(FFT). 1965年，Cooley和Tukey提出了计算离散傅里叶变换（DFT）的快速算法，将DFT的运算量减少了几个数量级。从此，对快速傅里叶变换（FFT）算法的研究便不断深入，数字信号处理这门新兴学科也随FFT的出现和发展而迅速发展。根据对序列分解与选取方法的不同而产生了FFT的多种算法，基本算法是基2DIT和基2DIF。FFT在离散傅里叶反变换、线性卷积和线性相关等方面也有重要应用。
快速傅氏变换（FFT），是离散傅氏变换的快速算法，它是根据离散傅氏变换的奇、偶、虚、实等特性，对离散傅立叶变换的算法进行改进获得的。它对傅氏变换的理论并没有新的发现，但是对于在计算机系统或者说数字系统中应用离散傅立叶变换，可以说是进了一大步。
设




快速傅里叶变换

x(n）为N项的复数序列，由DFT变换，任一X（m）的计算都需要N次复数乘法和N-1次复数加法，而一次复数乘法等于四次实数乘法和两次实数加法，一次复数加法等于两次实




快速傅里叶变换

数加法，即使把一次复数乘法和一次复数加法定义成一次“运算”（四次实数乘法和四次实数加法），那么求出N项复数序列的X（m），即N点DFT变换大约就需要N^2次运算。当N=1024点甚至更多的时候，需要N2=1048576次运算，在FFT中，利用WN的周期性和对称性，把一个N项序列（设N=2k,k为正整数），分为两个N/2项的子序列，每个N/2点DFT变换需要（N/2）^2次运算，再用N次运算把两个N/2点的DFT变换组合成一个N点的DFT变换。这样变换以后，总的运算次数就变成N+2*(N/2）^2=N+N^2/2。继续上面的例子，N=1024时，总的运算次数就变成了525312次，节省了大约50%的运算量。而如果我们将这种“一分为二”的思想不断进行下去，直到分成两两一组的DFT运算单元，那么N点的DFT变换就只需要Nlog2N次的运算，N在1024点时，运算量仅有10240次，是先前的直接算法的1%，点数越多，运算量的节约就越大，这就是FFT的优越性。
FFT的基本思想是把原始的N点序列，依次分解成一系列的短序列。充分利用DFT计算式中指数因子 所具有的对称性质和周期性质，进而求出这些短序列相应的DFT并进行适当组合，达到删除重复计算，减少乘法运算和简化结构的目的。此后，在这思想基础上又开发了高基和分裂基等快速算法，随着数字技术的高速发展，1976年出现建立在数论和多项式理论基础上的维诺格勒傅里叶变换算法(WFTA）和素因子傅里叶变换算法。它们的共同特点是，当N是素数时，可以将DFT算转化为求循环卷积，从而更进一步减少乘法次数，提高速度。
FFT算法很多，根据实现运算过程是否有指数因子WN可分为有、无指数因子的两类算法。
有指数因子的算法
经典库利-图基算法 当输入序列的长度N不是素数(素数只能被1而它本身整除）而是可以高度分解的复合数，即N=N1N2N3…Nr时，若N1=N2=…=Nr=2，N=2则N点DFT的计算可分解为N=2×N/2，即两个N/2点DFT计算的组合，而N/2点DFT的计算又可分解为N/2=2×N/4，即两个N/4点DFT计算的组合。依此类推，使DFT的计算形成有规则的模式，故称之为以2为基底的FFT算法。同理，当N=4时，则称之为以4为基底的FFT算法。当N=N1·N2时，称为以N1和N2为基底的混合基算法。
在这些算法中，基2算法用得最普遍。通常按序列在时域或在频域分解过程的不同，又可分为两种：一种是时间抽取FFT算法（DIT），将N点DFT输入序列x(n)、在时域分解成2个N/2点序列而x1(n)和x2(n)。前者是从原序列中按偶数序号抽取而成，而后者则按奇数序号抽取而成。DIT就是这样有规律地按奇、偶次序逐次进行分解所构成的一种快速算法。
分裂基算法(RSFFT) 1984年由P．杜哈美尔和H．赫尔曼等导出的一种比库利图基算法更加有效的改进算法，其基本思想是在变换式的偶部采用基2算法，在变换式的奇部采用基4算法。优点是具有相对简单的结构，非常适用于实对称数据，对长度N=2能获得最少的运算量(乘法和加法），所以是选用固定基算法中的一种最佳折衷算法。
计算离散傅里叶变换的快速方法，有按时间抽取的FFT算法和按频率抽取的FFT算法。前者是将时域信号序列按偶奇分排，后者是将频域信号序列按偶奇分排。它们都借助于的两个特点：一是周期性；二是对称性，这里符号*代表其共轭。这样，便可以把离散傅里叶变换的计算分成若干步进行，计算效率大为提高。
时间抽取算法 　令信号序列的长度为N(2的幂），可以将时域信号序列x(n)分解成两部分，一是偶数部分x（2n），另一是奇数部分x（2n+1），于是信号序列x(n）的离散傅里叶变换可以用两个N/2抽样点的离散傅里叶变换来表示和计算。考虑到和离散傅里叶变换的周期性，式⑴可以写成
⑶其中（4a）（4b）由此可见，式⑷是两个只含有N/2个点的离散傅里叶变换，G(k）仅包括原信号序列中的偶数点序列，H(k）则仅包括它的奇数点序列。虽然k=0，1，2，…，N-1，但是G(k）和H(k）的周期都是N/2，它们的数值以N/2周期重复。
因为于是由式⑶和式⑷得到（5a）（5b)
因此，一个抽样点数为N 的信号序列x(n）的离散傅里叶变换，可以由两个 N/2抽样点序列的离散傅里叶变换求出。依此类推，这种按时间抽取算法是将输入信号序列分成越来越小的子序列进行离散傅里叶变换计算，最后合成为N点的离散傅里叶变换。
通常用图1中蝶形算法的信号流图来表示式⑸的离散傅里叶变换运算。例如，N=8=2的抽样点的信号序列x(n）的离散傅里叶变换，可用如图2所示的FET算法的信号流图来计算。
①　N=2点的离散傅里叶变换的计算全由蝶形运算组成，需要M级运算，每级包括N/2个蝶形运算，总共有 个蝶形运算。所以，总的计算量为次复数乘法运算和N log2N次复数加法运算。
②　FFT算法按级迭代进行，计算公式可以写成
⑹N抽样点的输入信号具有N个原始数据x0(n），经第一级运算后，得出新的N个数据x1(n），再经过第二级迭代运算，又得到另外N个数据x2(n），依此类推，直至最后的结果x(k)=xM(k)=X(k）在逐级迭代计算中，每个蝶形运算的输出数据存放在原来存贮输入数据的单元中，实行所谓“即位计算”，这样可以节省大量存放中间数据的寄存器。
③　蝶形运算中加权系数随迭代级数成倍增加。由图2可以看出系数的变化规律。对于N=8,M=3情况，需进行三级迭代运算。在第一级迭代中，只用到一种加权系数；蝶形运算的跨度间隔等于1。在第二级迭代中，用到两种加权系数即、；蝶形运算的跨度间隔等于2。在第三级迭代中，用到4种不同的加权系数即、、、；蝶形运算的跨度间隔等于4。可见，每级迭代的不同加权系数的数目比前一级迭代增加一倍；跨度间隔也增大一倍。
④　输入数据序列x(n）需重新排列为x(0）、x⑷、x⑵、x⑹、x⑴、x⑸、x⑶、x⑺，这是按照二进制数的码位倒置所得到的反序数，例如N=8中数“1”的二进制数为“001”，将其码位倒转变为“100”，即为十进制数“4”。
频率抽取算法　按频率抽取的 FFT算法是将频域信号序列X(k）分解为奇偶两部分，但算法仍是由时域信号序列开始逐级运算，同样是把N点分成N/2点计算FFT，可以把直接计算离散傅里叶变换所需的N次乘法缩减到次。
在N=2的情况下，把N点输入序列x(n）分成前后两半
⑺
时间序列x1(n）±x2(n）的长度为N/2，于是N点的离散傅里叶变换可以写成
（8a)
（8b)
频率信号序列X（2l）是时间信号序列x1(n)+x2(n）的N/2点离散傅里叶变换，频率信号序列X（2l+1）是时间信号序列【x1(n)-x2(n）】的N/2点离散傅里叶变换，因此，N点离散傅里叶变换的计算，通过两次加（减）法和一次乘法，从原来序列获得两个子序列，所以，频率抽取算法也具有蝶形运算形式。以2为基数的FFT基本蝶形运算公式为
⑼
其计算量完全和时间抽取算法一样，即只需次乘法运算和Nlog2N次加（减）法运算。图3 表示N=8=2点的离散傅里叶变换的信号流图。由图可见，它以三级迭代进行即位计算，输入数据是按自然次序存放，使用的系数也是按自然次序，而最后结果则以二进制反序存放。
实际上，频率抽取算法与时间抽取算法的信号流图之间存在着转置关系，如将流图适当变形，可以得出多种几何形状。
除了基2的FFT算法之外，还有基4、基8等高基数的FFT算法以及任意数为基数的FFT算法。
计算量小的显著的优点，使得FFT在信号处理技术领域获得了广泛应用，结合高速硬件就能实现对信号的实时处理。例如，对语音信号的分析和合成，对通信系统中实现全数字化的时分制与频分制(TDM/FDM)的复用转换，在频域对信号滤波以及相关分析，通过对雷达、声纳、振动信号的频谱分析以提高对目标的搜索和跟踪的分辨率等等，都要用到FFT。可以说FFT的出现，对数字信号处理学科的发展起了重要的作用。
何振亚著：《数字信号处理的理论与应用》下册，人民邮电出版社，北京，1983。
程乾生著：《数字信号处理》，北京大学出版社，北京，2003。
E.O.布里汉著，柳群译：《快速傅里叶变换》，上海科学技术出版社，1979。（E. O. Brigham,TheFast Fourier Transform,Prentice Hall,Englewood Cliffs,New Jersey,1974.）v
若关键字为k，则其值存放在f(k)的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。
若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：
· 计算哈希函数所需时间
· 关键字的长度
· 哈希表的大小
· 关键字的分布情况
· 记录的查找频率
1.直接寻址法：取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
2. 数字分析法：分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
3. 平方取中法：当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。
[1]
例：我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示
关键字
内部编码
内部编码的平方值
H(k)关键字的哈希地址
KEYA
11052501
122157778355001
778
KYAB
11250102
126564795010404
795
AKEY
01110525
001233265775625
265
BKEY
02110525
004454315775625
315
[1]
4. 折叠法：将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
5. 随机数法：选择一随机函数，取关键字的随机值作为散列地址，即H(key)=random(key)其中random为随机函数,通常用于关键字长度不等的场合。
6. 除留余数法：取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词。
[2]
1. 开放寻址法：Hi=(H(key) + di) MOD m,i=1,2，…，k(k<=m-1），其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
1.1. di=1,2,3，…，m-1，称线性探测再散列；
1.2. di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k<=m/2）称二次探测再散列；
1.3. di=伪随机数序列，称伪随机探测再散列。
2. 再散列法：Hi=RHi(key),i=1,2，…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
3. 链地址法（拉链法）
4. 建立一个公共溢出区
散列表的查找过程基本上和造表过程相同。一些关键码可通过散列函数转换的地址直接找到，另一些关键码在散列函数得到的地址上产生了冲突，需要按处理冲突的方法进行查找。在介绍的三种处理冲突的方法中，产生冲突后的查找仍然是给定值与关键码进行比较的过程。所以，对散列表查找效率的量度，依然用平均查找长度来衡量。
查找过程中，关键码的比较次数，取决于产生冲突的多少，产生的冲突少，查找效率就高，产生的冲突多，查找效率就低。因此，影响产生冲突多少的因素，也就是影响查找效率的因素。影响产生冲突多少有以下三个因素：
1. 散列函数是否均匀；
2. 处理冲突的方法；
3. 散列表的装填因子。
散列表的装填因子定义为：α= 填入表中的元素个数 / 散列表的长度
α是散列表装满程度的标志因子。由于表长是定值，α与“填入表中的元素个数”成正比，所以，α越大，填入表中的元素较多，产生冲突的可能性就越大；α越小，填入表中的元素较少，产生冲突的可能性就越小。
实际上，散列表的平均查找长度是装填因子α的函数，只是不同处理冲突的方法有不同的函数。
了解了hash基本定义，就不能不提到一些著名的hash算法，MD5 和 SHA-1 可以说是目前应用最广泛的Hash算法，而它们都是以 MD4 为基础设计的。那么他们都是什么意思呢?
这里简单说一下：
⑴ MD4
MD4(RFC 1320）是 MIT 的 Ronald L. Rivest 在 1990 年设计的，MD 是 Message Digest 的缩写。它适用在32位字长的处理器上用高速软件实现--它是基于 32 位操作数的位操作来实现的。
⑵ MD5
MD5(RFC 1321）是 Rivest 于1991年对MD4的改进版本。它对输入仍以512位分组，其输出是4个32位字的级联，与 MD4 相同。MD5比MD4来得复杂，并且速度较之要慢一点，但更安全，在抗分析和抗差分方面表现更好
⑶ SHA-1 及其他
SHA1是由NIST NSA设计为同DSA一起使用的，它对长度小于264的输入，产生长度为160bit的散列值，因此抗穷举（brute-force）性更好。SHA-1 设计时基于和MD4相同原理，并且模仿了该算法。
那么这些Hash算法到底有什么用呢?
Hash算法在信息安全方面的应用主要体现在以下的3个方面：
⑴文件校验
我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测出数据传输中的信道误码，但却不能防止对数据的恶意破坏。
MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。
⑵数字签名
Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。
⑶ 鉴权协议
如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。
MD5、SHA1的破解
2004年8月17日，在美国加州圣芭芭拉召开的国际密码大会上，山东大学王小云教授在国际会议上首次宣布了她及她的研究小组的研究成果——对MD5、HAVAL－128、MD4和RIPEMD等四个著名密码算法的破译结果。2005年2月宣布破解SHA-1密码。
以上就是一些关于hash以及其相关的一些基本预备知识。那么在emule里面他具体起到什么作用呢?
大家都知道emule是基于P2P （Peer-to-peer的缩写，指的是对等连接的软件）， 它采用了"多源文件传输协议”（MFTP，the Multisource FileTransfer Protocol）。在协议中，定义了一系列传输、压缩和打包还有积分的标准，emule 对于每个文件都有md5-hash的算法设置，这使得该文件独一无二，并且在整个网络上都可以追踪得到。
什么是文件的hash值呢?
MD5-Hash-文件的数字文摘通过Hash函数计算得到。不管文件长度如何，它的Hash函数计算结果是一个固定长度的数字。与加密算法不同，这一个Hash算法是一个不可逆的单向函数。采用安全性高的Hash算法，如MD5、SHA时，两个不同的文件几乎不可能得到相同的Hash结果。因此，一旦文件被修改，就可检测出来。
当我们的文件放到emule里面进行共享发布的时候，emule会根据hash算法自动生成这个文件的hash值，他就是这个文件唯一的身份标志，它包含了这个文件的基本信息，然后把它提交到所连接的服务器。当有他人想对这个文件提出下载请求的时候， 这个hash值可以让他人知道他正在下载的文件是不是就是他所想要的。尤其是在文件的其他属性被更改之后（如名称等）这个值就更显得重要。而且服务器还提供了，这个文件当前所在的用户的地址，端口等信息，这样emule就知道到哪里去下载了。
一般来讲我们要搜索一个文件，emule在得到了这个信息后，会向被添加的服务器发出请求，要求得到有相同hash值的文件。而服务器则返回持有这个文件的用户信息。这样我们的客户端就可以直接的和拥有那个文件的用户沟通，看看是不是可以从他那里下载所需的文件。
对于emule中文件的hash值是固定的，也是唯一的，它就相当于这个文件的信息摘要，无论这个文件在谁的机器上，他的hash值都是不变的，无论过了多长时间，这个值始终如一，当我们在进行文件的下载上传过程中，emule都是通过这个值来确定文件。
那么什么是userhash呢?
道理同上，当我们在第一次使用emule的时候，emule会自动生成一个值，这个值也是唯一的，它是我们在emule世界里面的标志，只要你不卸载，不删除config，你的userhash值也就永远不变，积分制度就是通过这个值在起作用，emule里面的积分保存，身份识别，都是使用这个值，而和你的id和你的用户名无关，你随便怎么改这些东西，你的userhash值都是不变的，这也充分保证了公平性。其实他也是一个信息摘要，只不过保存的不是文件信息，而是我们每个人的信息。
那么什么是hash文件呢?
我们经常在emule日志里面看到，emule正在hash文件，这里就是利用了hash算法的文件校验性这个功能了，文章前面已经说了一些这些功能，其实这部分是一个非常复杂的过程，在ftp,bt等软件里面都是用的这个基本原理，emule里面是采用文件分块传输，这样传输的每一块都要进行对比校验，如果错误则要进行重新下载，这期间这些相关信息写入met文件，直到整个任务完成，这个时候part文件进行重新命名，然后使用move命令，把它传送到incoming文件里面，然后met文件自动删除，所以我们有的时候会遇到hash文件失败，就是指的是met里面的信息出了错误不能够和part文件匹配，另外有的时候开机也要疯狂hash，有两种情况一种是你在第一次使用，这个时候要hash提取所有文件信息，还有一种情况就是上一次你非法关机，那么这个时候就是要进行排错校验了。
关于hash的算法研究，一直是信息科学里面的一个前沿，尤其在网络技术普及的今天，他的重要性越来越突出，其实我们每天在网上进行的信息交流安全验证，我们在使用的操作系统密钥原理，里面都有它的身影，特别对于那些研究信息安全有兴趣的朋友，这更是一个打开信息世界的钥匙，他在hack世界里面也是一个研究的焦点。
一般的线性表、树中，记录在结构中的相对位置是随机的即和记录的关键字之间不存在确定的关系，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较”的基础上，查找的效率与比较次数密切相关。理想的情况是能直接找到需要的记录，因此必须在记录的存储位置和它的关键字之间建立一确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。因而查找时，只需根据这个对应关系f找到给定值K的像f(K）。若结构中存在关键字和K相等的记录，则必定在f(K）的存储位置上，由此不需要进行比较便可直接取得所查记录。在此，称这个对应关系f为哈希函数，按这个思想建立的表为哈希表（又称为杂凑法或散列表）。
哈希表不可避免冲突（collision）现象：对不同的关键字可能得到同一哈希地址 即key1≠key2，而hash(key1)=hash(key2）。具有相同函数值的关键字对该哈希函数来说称为同义词（synonym）。因此，在建造哈希表时不仅要设定一个好的哈希函数，而且要设定一种处理冲突的方法。可如下描述哈希表：根据设定的哈希函数H(key）和所选中的处理冲突的方法，将一组关键字映象到一个有限的、地址连续的地址集（区间）上并以关键字在地址集中的“象”作为相应记录在表中的存储位置，这种表被称为哈希表。
对于动态查找表而言，1) 表长不确定；2）在设计查找表时，只知道关键字所属范围，而不知道确切的关键字。因此，一般情况需建立一个函数关系，以f(key）作为关键字为key的录在表中的位置，通常称这个函数f(key）为哈希函数。（注意：这个函数并不一定是数学函数）
哈希函数是一个映象，即：将关键字的集合映射到某个地址集合上，它的设置很灵活，只要这个地址集合的大小不超出允许范围即可。
现实中哈希函数是需要构造的，并且构造的好才能使用的好。
用途：加密，解决冲突问题。
用途很广，比特精灵中就使用了哈希函数，你可以自己看看。
具体可以学习一下数据结构和算法的书。
（著名的ELFhash算法）
[3]
int ELFhash(char*key)
{
    unsigned long h=0;
    while(*key)
    {
        h = (h << 4) + *key++;
        unsigned long g = h & 0xF0000000L;
        if(g)
            h ^= g >> 24;
        h &= ~g;
    }
    return h % MOD;
}
强连通分量Kosaraju算法
Kosaraju算法可以说是最容易理解，最常用的算法，其比较关键的部分是同时应用了原图G和反图GT。步骤1：先用对原图G进行深搜生成树，步骤2：然后任选一棵树对其进行深搜(注意这次深搜节点A能往子节点B走的要求是EAB存在于反图GT)，能遍历到的顶点就是一个强连通分量。余下部分和原来的树一起组成一个新的树，继续步骤2直到 没有顶点为止。
改进思路：
当然，基本思路实现起来是比较麻烦的(因为步骤2每次对一棵树进行深搜时，可能深搜到其他树上去，这是不允许的，强连通分量只能存在单棵树中(由开篇第一句话可知))，我们当然不这么做，我们可以巧妙的选择第二深搜选择的树的顺序，使其不可能深搜到其他树上去。想象一下，如果步骤2是从森林里选择树，那么哪个树是不连通(对于GT来说)到其他树上的呢？就是最后遍历出来的树，它的根节点在步骤1的遍历中离开时间最晚，而且可知它也是该树中离开时间最晚的那个节点。这给我们提供了很好的选择，在第一次深搜遍历时，记录时间i离开的顶点j，即numb[i]=j。那么，我们每次只需找到没有找过的顶点中具有最晚离开时间的顶点直接深搜(对于GT来说)就可以了。每次深搜都得到一个强连通分量。
隐藏性质:
分析到这里，我们已经知道怎么求强连通分量了。但是，应当注意到第二次深搜选择树的顺序有一个特点。它就是：如果把求出来的每个强连通分量收缩成一个点，并且用求出每个强连通分量的顺序来标记收缩后的节点，那么这个顺序其实就是强连通分量收缩成点后形成的有向无环图的拓扑序列。为什么呢？首先，应该明确搜索后的图一定是有向无环图呢？废话，如果还有环，那么环上的顶点对应的所有原来图上的顶点构成一个强连通分量，而不是构成环上那么多点对应的独自的强连通分量了。然后就是为什么是拓扑序列，我们在改进分析的时候，不是先选的树不会连通到其他树上（对于反图GT来说），也就是后选的树没有连通到先选的树，也即先出现的强连通分量收缩的点只能指向后出现的强连通分量收缩的点。那么拓扑序列不是理所当然的吗？这就是Kosaraju算法的一个隐藏性质。
代码思路
step1：对原图G进行深度优先遍历，记录每个节点的离开时间。
step2：选择具有最晚离开时间的顶点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量。
step3：如果还有顶点没有删除，继续step2，否则算法结束。
实现代码（C++）
#include<iostream>
#include<cstring>
using namespace std;
const int MAXN=110;
int n;
bool flag[MAXN];//访问标志数组
int belg[MAXN];//存储强连通分量,其中belg[i]表示顶点i属于第belg[i]个强连通分量
int numb[MAXN];//结束时间标记,其中numb[i]表示离开时间为i的顶点
AdjTableadj[MAXN],radj[MAXN];//邻接表,逆邻接表
//用于第一次深搜,求得numb[1..n]的值
voidVisitOne(int cur,int &sig)
{
    flag[cur]=true;
    for(int i=1;i<=adj[cur][0];++i)
        if(false==flag[adj[cur][i]])
            VisitOne(adj[cur][i],sig);
    numb[++sig]=cur;
}
//用于第二次深搜,求得belg[1..n]的值
voidVisitTwo(int cur,intsig)
{
    flag[cur]=true;
    belg[cur]=sig;
    for(int i=1;i<=radj[cur][0];++i)
        if(false==flag[radj[cur][i]])
            VisitTwo(radj[cur][i],sig);
}
//Kosaraju算法,返回为强连通分量个数
int Kosaraju_StronglyConnectedComponent()
{
    int i,sig;
    //第一次深搜
    memset(flag+1,0,sizeof(bool)*n);
    for(sig=0,i=1;i<=n;++i)
        if(false==flag[i])
            VisitOne(i,sig);
    //第二次深搜
    memset(flag+1,0,sizeof(bool)*n);
    for(sig=0,i=n;i>0;--i)
        if(false==flag[numb[i]])
            VisitTwo(numb[i],++sig);
    return sig;
}

强连通分量Tarjan算法
Tarjan算法思路不难理解，因为任何一个强连通分量，必定是对原图的深度优先搜索树的子树。那么其实只要确定每个强连通分量的子树的根，然后根据这些根从树的最低层开始，一个一个的拿出强连通分量即可。那么剩下的问题就只剩下如何确定强连通分量的根和如何从最低层开始拿出强连通分量了。
那么如何确定强连通分量的根，在这里我们维护两个数组，一个是indx[1..n]，一个是mlik[1..n]，其中indx[i]表示顶点i开始访问时间，mlik[i]为与顶点i邻接的顶点未删除顶点j的mlik[j]和mlik[i]的最小值(mlik[i]初始化为indx[i])。这样，在一次深搜的回溯过程中，如果发现mlik[i]==indx[i]那么，当前顶点就是一个强连通分量的根，为什么呢？因为如果它不是强连通分量的根，那么它一定是属于另一个强连通分量，而且它的根是当前顶点的祖宗，那么存在包含当前顶点的到其祖宗的回路，可知mlik[i]一定被更改为一个比indx[i]更小的值。
至于如何拿出强连通分量，如果当前节点为一个强连通分量的根，那么它的强连通分量一定是以该根为根节点的(剩下节点)子树。在深度优先遍历的时候维护一个堆栈，每次访问一个新节点，就压入堆栈。这样，由于当前节点是这个强连通分量中最先被压入堆栈的，那么在当前节点以后压入堆栈的并且仍在堆栈中的节点都属于这个强连通分量。可以用反证法证明这个做法的正确性。假设一个节点在当前节点压入堆栈以后压入并且还存在，同时它不属于该强连通分量，那么它一定属于另一个强连通分量，但当前节点是它的根的祖宗，那么这个强连通分量应该在此之前已经被拿出。
实现代码（pascal）
代码中数组dfn为上述indx，low为mlik
type inf=record
x,next:longint;
end;
var dfn,low,stk,hash,nar:array[1..10000] of longint;//stk为栈，nar[i]记录i所对应的强连通分量编号
e:array[1..50000] of inf;//邻接链表存图
flag,vis:array[1..10000] of boolean;//flag记录是否在栈中，vis记录是否遍历过
n,m,i,u,v,top,cnt,ant:longint;//cnt是记录时间的指针，ant是记录强连通分量编号的指针
procedure dfs(i:longint);//Tarjan求强连通分量
var u:longint;
begin
  inc(cnt);//记录时间
  dfn[i]:=cnt;
  low[i]:=cnt;//更新dfn与low
  vis[i]:=true;//表示i已经被遍历过
  inc(top);
  stk[top]:=i;
  flag[i]:=true;//表示i在栈中
  u:=hash[i];
  while u<>0 do
  begin
    if not vis[e[u].x] then
    begin
      dfs(e[u].x);//先遍历子树后更新low
      low[i]:=min(low[i],low[e[u].x]);
    end
    else if flag[e[u].x] then 
      low[i]:=min(low[i],low[e[u].x]);
      u:=e[u].next;
    end;
    if low[i]=dfn[i] then//表明i为一个强连通分量的根节点
    begin
      inc(ant);
      while stk[top]<>i do//弹栈记录强连通分量
      begin
        nar[stk[top]]:=ant;
        flag[stk[top]]:=false;
        stk[top]:=0;
        dec(top);
      end;
      nar[stk[top]]:=ant;
      flag[stk[top]]:=false;
      stk[top]:=0;
      dec(top);
    end;
end;
实现代码（C++）
int low[N],dfn[N];
bool instack[N];
stack<int>st;
struct LIST
{
    int v;
    LIST *next;
};
LIST *head[N]={NULL};
void tarjan(int v)
{
    dfn[v]=low[v]=time++;
    st.push(v);
    instack[v]=true;
    for(LIST *p=head[v];p!=NULL;p=p->next)
        {    
        if(!dfn[p->v])
                {
            tarjan(p->v);
            low[v]=min(low[v],low[p->v]);
        }
        else if(instack[p->v])
                    low[v]=min(low[v],dfn[p->v]);
    }
    if(dfn[v]==low[v])
        {
        cout<<"{ ";
        do
                {
            v=st.top();
            st.pop();
            instack[v]=false;
            cout<<v<<' ';
        }while(dfn[v]!=low[v]);
        cout<<"}"<<endl;
    }
}
强连通分量Gabow算法
Gabow算法其实就是Tarjan算法的变形，我们观察一下，只是它用第二个堆栈来辅助求出强连通分量的根，而不是Tarjan算法里面的indx[]和mlik[]数组。那么，我们说一下如何使用第二个堆栈来辅助求出强连通分量的根。
我们使用类比方法，在Tarjan算法中，每次mlik[i]的修改都是由于环的出现(不然，mlik[i]的值不可能变小)，每次出现环，在这个环里面只剩下一个mlik[i]没有被改变(深度最低的那个)，或者全部被改变，因为那个深度最低的节点在另一个环内。那么Gabow算法中的第二堆栈变化就是删除构成环的节点，只剩深度最低的节点，或者全部删除，这个过程是通过出栈来实现，因为深度最低的那个顶点一定比前面的先访问，那么只要出栈一直到栈顶那个顶点的访问时间不大于深度最低的那个顶点。其中每个被弹出的节点属于同一个强连通分量。那有人会问：为什么弹出的都是同一个强连通分量？因为在这个节点访问之前，能够构成强连通分量的那些节点已经被弹出了，这个对Tarjan算法有了解的都应该清楚，那么Tarjan算法中的判断根我们用什么来代替呢？想想，其实就是看看第二个堆栈的顶元素是不是当前顶点就可以了。
其实Tarjan算法和Gabow算法其实是同一个思想的不同实现，但是，Gabow算法更精妙，时间更少(不用频繁更新mlik[])。
代码思路
步骤1:找一个没有被访问过的节点v，goto step2(v)。否则，算法结束。
步骤2(v):
将v压入堆栈stk1[]和stk2[]
对于v所有的邻接顶点u：
1) 如果没有访问过，则step2(u)
2) 如果访问过，但没有删除，维护stk2[](处理环的过程)
如果stk2[]的顶元素=v，那么输出相应的强连通分量
实现代码（C++）
#include<iostream>
using namespace std;
const intMAXN=110;
typedef int AdjTable[MAXN];//邻接表类型
int n;
int int m[MAXN];//标记进入顶点时间
int belg[MAXN];//存储强连通分量,其中belg[i]表示顶点i属于第belg[i]个强连通分量
int stk1[MAXN];//辅助堆栈
int stk2[MAXN];//辅助堆栈
AdjTablead j[MAXN];//邻接表
//深搜过程,该算法的主体都在这里
void Visit(intcur,int&sig,int&scc_num)
{
  int i;

  int m[cur]     = ++sig;
  stk1[++stk1[0]] = cur;
  stk2[++stk2[0]] = cur;

  for(i=1;i<=adj[cur][0];++i)
    {
    if(0==intm[adj[cur][i]])
        {
      Visit(adj[cur][i],sig,scc_num);
    }
        else if(0==belg[adj[cur][i]]) 
        {
      while(intm[stk2[stk2[0]]]>intm[adj[cur][i]])
        --stk2[0];
    }
  }
  if (stk2[stk2[0]]==cur)
    {
    --stk2[0];++scc_num;
    do
        {
      belg[stk1[stk1[0]]]=scc_num;
    }while(stk1[stk1[0]--]!=cur);
  }
}
//Gabow算法,求解belg[1..n],且返回强连通分量个数,
int Gabow_StronglyConnectedComponent()
{
  int i,sig,scc_num;

  memset(belg+1,0,sizeof(int)*n); 
  memset(intm+1,0,sizeof(int)*n);
  sig=0;scc_num=0;stk1[0]=0;stk2[0]=0;
  for(i=1;i<=n;++i)
    {
    if(0==intm[i])
      Visit(i,sig,scc_num);
  }

  return scc_num;
}
Pascal
procedure tarjan(r:longint);
var x,i,j:longint;
begin
  inc(timez);time[r]:=timez;low[r]:=timez;
  inc(top);zh[top]:=r;
  for i:=p1[r]top2[r] do
  begin
    j:=e[i].y;
    iftime[j]=0thentarjan(j);
    iflow[j]<low[r]thenlow[r]:=low[j];
  end;
  if time[r]=low[r] then
    repeat
      x:=zh[top];
      num[x]:=r; low[x]:=n+1;//这句话千万别忘了
      dec(top);
    until x = r;
end;
Kosaraju算法的第二次深搜隐藏了一个拓扑性质，而Tarjan算法和Gabow算法省略了第二次深搜，所以，它们不具有拓扑性质。Tarjan算法用堆栈和标记，Gabow用两个堆栈（其中一个堆栈的实质是代替了Tarjan算法的标记部分）来代替Kosaraju算法的第二次深搜，所以只用一次深搜，效率比Kosaraju算法要高。
在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得
的 w(T) 最小，则此 T 为 G 的最小生成树。

最小生成树其实是最小权重生成树的简称。
[1]

生成树和最小生成树有许多重要的应用。
例如：要在n个城市之间铺设光缆，主要目标是要使这 n 个城市的任意两个之间都可以通信，但铺设光缆的费用很高，且各个城市之间铺设光缆的费用不同，因此另一个目标是要使铺设光缆的总费用最低。这就需要找到带权的最小生成树。
[1]
最小生成树说明
最小生成树性质：设G=(V，E）是一个连通网络，U是顶点集V的一个非空真子集。若(u，v）是G中一条“一个端点在U中（例如：u∈U），另一个端点不在U中的边（例如：v∈V-U），且（u，v）具有最小权值，则一定存在G的一棵最小生成树包括此边（u，v）。
最小生成树证明
为方便说明，先作以下约定：
①将集合U中的顶点看作是红色顶点，②而V-U中的顶点看作是蓝色顶点，③连接红点和蓝点的边看作是紫色边，④权最小的紫边称为轻边（即权重最"轻"的边）。于是，MST性质中所述的边（u，v）就可简称为轻边。
用反证法证明MST性质：
假设G中任何一棵MST都不含轻边（u，v）。则若T为G的任意一棵MST，那么它不含此轻边。
根据树的定义，则T中必有一条从红点u到蓝点v的路径P，且P上必有一条紫边（u'，v'）连接红点集和蓝点集，否则u和v不连通。当把轻边（u，v）加入树T时，该轻边和P必构成了一个回路。删去紫边（u'，v'）后回路亦消除，由此可得另一生成树T'。
T'和T的差别仅在于T'用轻边（u，v）取代了T中权重可能更大的紫边（u'，v'）。因为w(u，v）≤w(u'，v'），所以
w(T')=w(T)+w(u，v)-w(u'，v'）≤w(T)
即T'是一棵比T更优的MST，所以T不是G的MST，这与假设矛盾。
所以，MST性质成立。
[1]
求MST的一般算法可描述为：针对图G，从空树T开始，往集合T中逐条选择并加入n-1条安全边（u，v），最终生成一棵含n-1条边的MST。
当一条边（u，v）加入T时，必须保证T∪{(u，v)}仍是MST的子集，我们将这样的边称为T的安全边。
最小生成树Prim算法简述
1).输入：一个加权连通图，其中顶点集合为V，边集合为E；
2).初始化：Vnew= {x}，其中x为集合V中的任一节点（起始点），Enew= {},为空；
3).重复下列操作，直到Vnew= V：
a.在集合E中选取权值最小的边<u, v>，其中u为集合Vnew中的元素，而v不在Vnew集合当中，并且v∈V（如果存在有多条满足前述条件即具有相同权值的边，则可任意选取其中之一）；
b.将v加入集合Vnew中，将<u, v>边加入集合Enew中；
4).输出：使用集合Vnew和Enew来描述所得到的最小生成树。
[1]
最小生成树Kruskal算法简述
假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。
[1]
最小生成树伪代码
GenerieMST(G){//求G的某棵MST
T〈-￠； //T初始为空，是指顶点集和边集均空
while T未形成G的生成树 do{
找出T的一条安全边（u，v）；//即T∪{(u，v)}仍为MST的子集
T=T∪{(u，v)}； //加入安全边，扩充T
}
return T； //T为生成树且是G的一棵MST
}
注意：
下面给出的两种求MST的算法均是对上述的一般算法的求精，两算法的区别仅在于求安全边的方法不同。
为简单起见，下面用序号0，1，…，n-1来表示顶点集，即是：
V(G)={0，1，…，n-1}，
G中边上的权解释为长度，并设T=(U，TE）。
最小生成树C语言代码
#include<stdio.h>
　#include<stdlib.h>
　#include<iostream.h>
　#defineMAX_VERTEX_NUM20
　#defineOK1
　#defineERROR0
　#defineMAX1000
　typedefstructArcell
　{
　doubleadj;
　}Arcell,AdjMatrix[MAX_VERTEX_NUM][MAX_VERTEX_NUM];
　typedefstruct
　{
　charvexs[MAX_VERTEX_NUM];//节点数组
　AdjMatrixarcs;//邻接矩阵
　intvexnum,arcnum;//图的当前节点数和弧数
　}MGraph;
　typedefstructPnode//用于普利姆算法
　{
　charadjvex;//节点
　doublelowcost;//权值
　}Pnode,Closedge[MAX_VERTEX_NUM];//记录顶点集U到V-U的代价最小的边的辅助数组定义
　typedefstructKnode//用于克鲁斯卡尔算法中存储一条边及其对应的2个节点
　{
　charch1;//节点1
　charch2;//节点2
　doublevalue;//权值
　}Knode,Dgevalue[MAX_VERTEX_NUM];
　
　
//-------------------------------------------------------------------------------
　intCreateUDG(MGraph&G,Dgevalue&dgevalue);
　intLocateVex(MGraphG,charch);
　intMinimum(MGraphG,Closedgeclosedge);
　voidMiniSpanTree_PRIM(MGraphG,charu);
　voidSortdge(Dgevalue&dgevalue,MGraphG);
　
　
//-------------------------------------------------------------------------------
　intCreateUDG(MGraph&G,Dgevalue&dgevalue)//构造无向加权图的邻接矩阵
　{
　inti,j,k;
　cout<<"请输入图中节点个数和边/弧的条数：";
　cin>>G.vexnum>>G.arcnum;
　cout<<"请输入节点：";
　for(i=0;i<G.vexnum;++i)
　cin>>G.vexs[i];
　for(i=0;i<G.vexnum;++i)//初始化数组
　{
　for(j=0;j<G.vexnum;++j)
　{
　G.arcs[i][j].adj=MAX;
　}
　}
　cout<<"请输入一条边依附的定点及边的权值："<<endl;
　for(k=0;k<G.arcnum;++k)
　{
　cin>>dgevalue[k].ch1>>dgevalue[k].ch2>>dgevalue[k].value;
　i=LocateVex(G,dgevalue[k].ch1）;
　j=LocateVex(G,dgevalue[k].ch2）;
　G.arcs[i][j].adj=dgevalue[k].value;
　G.arcs[j][i].adj=G.arcs[i][j].adj;
　}
　returnOK;
　}
　intLocateVex(MGraphG,charch)//确定节点ch在图G.vexs中的位置
　{
　inta;
　for(inti=0;i<G.vexnum;i++)
　{
　if(G.vexs[i]==ch)
　a=i;
　}
　returna;
　}
　voidMiniSpanTree_PRIM(MGraphG,charu)//普利姆算法求最小生成树
　{
　inti,j,k;
　Closedgeclosedge;
　k=LocateVex(G,u);
　for(j=0;j<G.vexnum;j++)
　{
　if(j!=k)
　{
　closedge[j].adjvex=u;
　closedge[j].lowcost=G.arcs[k][j].adj;
　}
　}
　closedge[k].lowcost=0;
　for(i=1;i<G.vexnum;i++)
　{
　k=Minimum(G,closedge);
　cout<<"("<<closedge[k].adjvex<<","<<G.vexs[k]<<","<<closedge[k].lowcost<<")"<<endl;
　closedge[k].lowcost=0;
　for(j=0;j<G.vexnum;++j)
　{
　if(G.arcs[k][j].adj<closedge[j].lowcost)
　{
　closedge[j].adjvex=G.vexs[k];
　closedge[j].lowcost=G.arcs[k][j].adj;
　}
　}
　}
　}
　intMinimum(MGraphG,Closedgeclosedge)//求closedge中权值最小的边，并返回其顶点在vexs中的位置
　{
　inti,j;
　doublek=1000;
　for(i=0;i<G.vexnum;i++)
　{
　if(closedge[i].lowcost!=0&&closedge[i].lowcost<k)
　{
　k=closedge[i].lowcost;
　j=i;
　}
　}
　returnj;
　}
　voidMiniSpanTree_KRSL(MGraphG,Dgevalue&dgevalue)//克鲁斯卡尔算法求最小生成树
　{
　intp1,p2,i,j;
　intbj[MAX_VERTEX_NUM];//标记数组
　for(i=0;i<G.vexnum;i++)//标记数组初始化
　bj[i]=i;
　Sortdge(dgevalue,G);//将所有权值按从小到大排序
　for(i=0;i<G.arcnum;i++)
　{
　p1=bj[LocateVex(G,dgevalue[i].ch1）];
　p2=bj[LocateVex(G,dgevalue[i].ch2）];
　if(p1!=p2）
　{
　cout<<"("<<dgevalue[i].ch1<<","<<dgevalue[i].ch2<<","<<dgevalue[i].value<<")"<<endl;
　for(j=0;j<G.vexnum;j++)
　{
　if(bj[j]==p2）
　bj[j]=p1;
　}
　}
　}
　}
　voidSortdge(Dgevalue&dgevalue,MGraphG)//对dgevalue中各元素按权值按从小到大排序
　{
　inti,j;
　doubletemp;
　charch1,ch2;
　for(i=0;i<G.arcnum;i++)
　{
　for(j=i;j<G.arcnum;j++)
　{
　if(dgevalue[i].value>dgevalue[j].value)
　{
　temp=dgevalue[i].value;
　dgevalue[i].value=dgevalue[j].value;
　dgevalue[j].value=temp;
　ch1=dgevalue[i].ch1;
　dgevalue[i].ch1=dgevalue[j].ch1;
　dgevalue[j].ch1=ch1;
　ch2=dgevalue[i].ch2;
　dgevalue[i].ch2=dgevalue[j].ch2;
　dgevalue[j].ch2=ch2;
　}
　}
　}
　}
　intmain()
　{
　inti,j;
　MGraphG;
　charu;
　Dgevaluedgevalue;
　CreateUDG(G,dgevalue);
　cout<<"图的邻接矩阵为："<<endl;
　for(i=0;i<G.vexnum;i++)
　{
　for(j=0;j<G.vexnum;j++)
　cout<<G.arcs[i][j].adj<<"";
　cout<<endl;
　}
　cout<<"=============普利姆算法===============\n";
　cout<<"请输入起始点：";
　cin>>u;
　cout<<"构成最小代价生成树的边集为：\n";
　MiniSpanTree_PRIM(G,u);
　cout<<"============克鲁斯科尔算法=============\n";
　cout<<"构成最小代价生成树的边集为：\n";
　MiniSpanTree_KRSL(G,dgevalue);
return0；
　}
最小生成树Kruskal算法 - pascal语言
program didi;
var
a:array[0..100000] of record
s,t,len:longint;
end;
fa,r:array[0..10000] of longint;
n,i,j,x,y,z:longint;
tot,ans:longint;
count,xx:longint;
procedure quick(l,r:longint);
var
i,j,x,y,t:longint;
begin
i:=l; j:=r;
x:=a[(l+r) div 2].len;
repeat
while x>a[i].len do inc(i);
while x<a[j].len do dec(j);
if i<=j then
begin
y:=a[i]; a[i]:=a[j]; a[j]:=y;
inc(i);dec(j);
end;
until i>j;
if i<r then quick(i,r);
if l<j then quick(l,j);
end;
function find(x:longint):longint;
begin
if fa[x]=x then exit(x);
fa[x]:=find(fa[x]);{路径压缩}
exit(fa[x]);
end;
procedure union(x,y:longint);{启发式合并}
var
t:longint;
begin
x:=find(x);
y:=find(y);
if r[x]>r[y] then
begin
t:=x; x:=y; y:=t;
end;
if r[x]=r[y] then inc(r[x]);
fa[x]:=y;
end;
begin
readln(xx,n);
for i:=1 to xx do fa[i]:=i;
for i:=1 to n do
begin
read(x,y,z);
inc(tot);
a[tot].s:=x;
a[tot].t:=y;
a[tot].len:=z;
end;
quick（1,tot);{将边排序}
ans:=0;
count:=0;
i:=0;
while count<=x-1 do{count记录加边的总数}
begin
inc(i);
with a[i] do
if find(s)<>find(t) then
begin
union(s,t);
ans:=ans+len;
inc(count);
end;
end;
write(ans);
end.
最小生成树Prim算法 - pascal语言
var
m,n:set of 1..100;
s,t,min,x,y,i,j,k,l,sum,p,ii:longint;
a:array[1..100,1..100]of longint;
begin
readln(p);
for ii:=1 to p do
begin
k:=0; sum:=0;
fillchar(a,sizeof(a),255);
readln(x);
m:=[1];
n:=[2..x];
for i:=1 to x do
begin
for j:=1 to x do
begin
read(a[i,j]);
if a[i,j]=0
then a[i,j]:=maxlongint;
end;
readln;
end;
for l:=1 to x-1 do
begin
min:=maxlongint;
for i:=1 to x do
if i in m
then begin
for j:=1 to x do
begin
if (a[i,j]<min)and(j in n)
then begin
min:=a[i,j];
s:=i;
t:=j;
end;
end;
end;
sum:=sum+min;
m:=m+[t];
n:=n-[t];
inc(k);
end;
writeln(sum);
end;
end.
最小生成树C++模板
//maxe保存了最大边数
structedge
{
intu,v,w;

booloperator<(constedge&b)const
{
returnthis->w>b.w;
}
}e[maxe];

//并查集相关
intf[maxn];

inlinevoidinit()
{
for(inti=0;i<maxn;i++)f[i]=i;
}

intfind(intx)
{
if(f[x]==x)returnx;
elsereturnf[x]=find(f[x]);
}

//主算法
intkruskal(intn,intm)
{
//n:点数,m:边数
//所有边已经预先储存在e数组里
sort(e,e+m);
init();

intans=0;
for(inti=0;i<m;i++)
{
intu=e[i].u,v=e[i].v,w=e[i].w;
if(find(u)==find(v))continue;
f[find(u)]=find(v);
ans+=w;
}

returnans;
}
英文：random walk




随机游走
定义：随机游走，概念接近于布朗运动，是布朗运动的理想数学状态。
核心概念：任何无规则行走者所带的守恒量都各自对应着一个扩散运输定律。
无规则行走与扩散定律
随机游走无规则行走
无规则行走在任意尺度上都具有相似结构。例如一个在二维（d=2）格子上游动，每一定时间以相同概率移动到其相邻位置，其轨迹即二维随机轨迹，同样可以扩展到三维。举个例子，你取2 个硬币一个1 分，一个5 分。你每五秒，将2 个硬币掷一次，1 分硬币用于左右移动标记，5 分硬币用于前后移动标记，绘出路径就是你的二维无规则行走。假如你走了1000 步那么你回到起点的方式M0 有多少种？那么么必须正反面各500 次。即，对一个特定投币序列将投出正面的序号列出清单，清单包括500 个不同的整数这个量为：1000！/500！，而任意两张清单只在元素存在换序的差异，则实际上并无区别所以必须除以可能的置换数500!,M0=1000！/(500×500！)，“！”表示阶乘。回到原点的概率P0=M0/ M，这个概率满足二项分布。




斯特林公式
对于所有M 种可能可以用斯特林公式进行计算，通过计算我们知道回到起点的概率很低。
要想找出第1000 步后你走了多远，你可以列出1000 次投币的结果序列然后对所有（x1000）的2次方 求平均，得到1000 步后的均方位置；这显然太复杂，好在还有另外的方法。我们可以将所有2的N次方 种可能行走一一配对，每一配对由相同的x（N-1 ）；{（N-1)为x的下脚标}的两个可能性相等的行走组成，只是最后一步不同。N 步随机性走的均方位移比N－1 步大a的2次方，后者又比N－2 步大a的2次方，均方位移=Na的2次方。a 为格子间隔，每一个格子点上游动的可能方向有2d 个（d 是格子维数）单位时间内游动的方差为D=a2/(2d)t ，D 为扩散系数（一些参考书中也用字母K 表示，




醉酒人的无规则行走
a后面的2为次方，后面凡数字在字母后面都表示指数）。对于一维无规则行走的均方位移随时间线性增加2Kt，扩散常数D=a2/(2Δt)。这个逻辑可以推广到二维和三维。

也许行走若干个步后他会回到出发点，但这样的概率非常小。他离开酒吧的距离满足扩散定律。
(a)二维无规则行走；
(b)当步骤更多，步幅更低时二维无规则行走；
(c)三维无规则行走。
随机游走扩散定律
扩散以一个初始分布释放大量的无规则行走，观察他们的密度，就会得到分布函数。
1855 年法国生理学家Fick 提出了描述扩散规律的基本公式— 菲克定律，在一维（如x 方向扩散的）粒子流密度（即单位时间内在单位截面上扩散的粒子流）J N 与粒子数密度梯度dc/dx成正比。扩散通量J=－D×(dc/dx)，称为菲克定律又称扩散第一定律。进一步消掉J，找出浓度随时间的变化关系dc/dt=D(d2c/dx2)其中2都是上角标，称为菲克第二定律；在高等教材中可以写成偏导的形式d 换成ә。
任何单次步骤不会遵从扩散定律，但只要等待足够长的时间和步骤，便可精确预测无规则行走。布朗运动就是无规则行走这一现象的宏观观察。通过扩散定律我们将布朗运动的微观参数（步长a 和间隔时间Δt）与宏观实验可观测量（扩散常数D）建立了联系。然而一个方程无法解出两个未知量，测量K 不足以得到a 和Δt。这意味着还需要其他能够说明摩擦与扩散定量联系的公式。
扩散定律是跨学科的普适定律
对无规则行走的数学处理使用了过于简化的假设，扩散定律是普适的，只要给定独立随机行走的某种分布，它就不依赖于具体的模型。涨落是随机的、混沌的，无规则行走的结果就是扩散，这包括物质扩散、动量扩散、热量扩散等。这也意味着结晶学、天文学、生物学、气象学、流体力学、经济学都将用到扩散定律。扩散定律是普适的，在这里我们作为一个结论而接受下来，具体的一系列数学证明过程给予舍弃。感兴趣的朋友可以参见任何一本物理化学教材或分形教材。
[1]
扩散定律与守恒量
扩散是一个随机涨落的过程，在本科一年级的物理课程已经提及一个落体最终会达到取决于摩擦的“末速度”。以悬浮颗粒来考虑摩擦，颗粒虽然受随机碰撞，仍获得了一个净漂移速度。v=f/ζ ，ζ=2m/Δt ，其中ζ是黏性摩擦系数，与扩散系数一样可以实验测量。摩擦源于物理实体与周围热致扰动的流体随机碰撞。每一种颗粒当置于不同的溶剂中时都会有相应特征D（扩散系数）和ζ。球体的黏性摩擦系数与尺寸间存在简单关系，ζ=6πηR 斯托克斯（stokes）公式；R 是颗粒半径，η是常数称为流体黏度（水的黏度为10－3kg/ms）。
由于有效步长a 和Δt 无法观察，要想证实扩散与粘滞仅仅是热运动的两个方面，我们还需要第三个关系。爱因斯坦注意到a 和Δt 的关系，按照推到理想气体定律的思路：(a/Δt)2=kBT/m，联合起来就构成爱因斯坦第一扩散公式：ζD=kBT。越小的颗粒受到摩擦阻力越小，但扩散系数会更大，更容易扩散。ζD 的乘积提供了一个可证伪的预言来检验“热即分子的无规则运动”；这个预言提出不久就立刻被佩兰（Jeans Perrin）和其他人的实验所证实。任何无规则行走携带的守恒量都各自对应一个扩散定律。
[1]
随机游走理想状态
无规则行走只是布朗运动的理想状态。
在很多系统都存在不同类型的无规则行走，他们都具有相似结构。单个的随机事件我们不可预测，但随机大量的群体行为，却是精确可知的，这就是概率世界的魅力，在偶然中隐含着必然。随机性造成了低尺度下的差异性，但在高尺度下又表现为共同的特征的相似性。按照概率的观点“宇宙即是所有随机事件概率的总和”。
随机游走相关研究
椭球体布朗运动相关研究
虽然无规则行走导致的扩散满足以上的方程并有普适性，但假如这样的“无规则行走”某个方向，并不是完全随机呢？以前面提到的投硬币为例子，一个1 分，一个5 分，其中1 分硬币破损使得正反面概率不相等，并且随机若干步后，将1 分和5 分硬币所代表的方向对调；那么二维的无规则行走路径必然发生改变。
当年爱因斯坦的论文是探讨球形颗粒的布朗运动，我们知道球形颗粒的旋转并不影响他的平移，旋转的非球形例子却会影响它的平移。实际中，大量布朗运动的颗粒都是非球形的，所以更多的模型不得不考虑随机转动问题。其实即使对球形颗粒在黏性流体中，也要考虑随机转动产生的转动摩擦系数对扩散的影响。
[2]
宾夕法尼亚大学的网站报道，研究人员用数字视屏显微镜观察水中悬浮椭




椭球体在水中的布朗运动

球体的随机旋转和移动。球形颗粒扩散分布将随时间逐渐变宽，为高斯型浓度分布；而椭球颗粒不满足高斯分布。随着布朗运动的深入研究，越来越多的实验表明布朗运动颗粒的行为与爱因斯坦一个世纪前的假设不同。
2005 年10 月的物理评论快报，提到现在实验室可以跟踪布朗运动颗粒的测量精度达到微秒和纳米的尺度。科学家们也发现活细胞的许多基本过程由布朗运动所驱动。试验结果描述布朗运动的方程式偏离标准理论的，实际的布朗运动要比理想化的无规则行走要复杂。
标准的无规则行走，色彩标记显示出椭球的耦合方向和位移，并清楚的表明椭球的扩散其长轴比其短轴扩散更快。
随机游走观点的缺憾
布朗运动是分形的典型例子，理想状态下的布朗运动是高斯正态分布，当然更多的布朗运动研究细节我们不做探讨。任何事物都不是孤立的，都是相互作用、相互联系的。用还原论观点将系统一个个隔离是对事物的理想化，是在一定程度上精确定量描述系统，当然这也是认识事物必经的步骤，但是有缺陷的。
哥德尔不完备定理，以及认识主体对客体的反映永远存在这不完备性。我观赞同哥本哈根学派的主张“自然科学不是自然界本身，而是人和自然界间关系的一部分，因而依赖人”。无论用还原论还是整体论都是用抽象去阐明物质的特性，这些抽象在任何时候仅仅是近似地、有条件的把握了物质的本质，不是世界的全部。布朗运动研究的历史，具有典型性，有点像整个科学研究史的缩影。人对事物的认识总是渐进的，不断深入的，随着认识深入会发现各种模型都是理想化的条件。这种认识永远无法走向事物的绝对认识，因为孤立的事物是不存在的，所有的系统都是宇宙整体的一部分。
随机游走与P2P
许多系统都有类似无规则行走的例子。例如：P2P (Peer-to-Peer 对等计算，




P2P 搜索中Random Walk 搜索方法搜索信息的扩散

简称P2P)搜索中Random Walk 搜索方法在随机漫步中，请求者发出K 个查询请求给随机挑选的K 个相邻节点。然后每个查询信息在以后的漫步过程中直接与请求者保持联系，询问是否还要继续下一步。如果请求者同意继续漫步，则又开始随机选择下一步漫步的节点，否则中止搜索又开始随机选择下一步漫步的节点，否则中止搜索又开始随机选择下一步漫步的节点，否则中止搜索。
[3]
随机游走与高分子
高分子的形状类似于无规则行走，把高分子想象成由N 个单元排成的长串。每个单元都由一个完全柔软的铰链与下一个单元相连，就像一串回形针。热平衡时，这些铰链全部处于随机选取的角度，高分子每一时刻的形状都会不同，每一时刻都是一个无规则行走。如果合成的高分子由不同数量的单元组成，线团尺寸的增加正比于其摩尔质量的平方根。
如果单元间存在着强烈的相互吸引力，高分子将不再采取无规则行走构象而是密堆成一个球体，例如血清球蛋白。可以通过比较高分子的体积和假设所有密堆占的最小体积，将高分子分为“紧密型”和“舒展型”。即使高分子不坍缩为团，单体也并非真正处于任何位置，两个单体不可能占据空间同一点，这是自回避现象。这样标度指数（线团尺寸的增加正比于其摩尔质量的指数）就由0.5 变为其他值，所以这个值往往略大一点。不管精确值是什么，高分子运动的复杂性可涌现出简单的标度关系。
梅尔（B.Maier）和雷德勒尔(J.Radler)首先构建了一个带正电的表面并让他吸附带负电荷的单链DNA 然后对被吸附的DNA 分子不断变化的构象进行连续快照(DNA 带有荧光染色)。DNA 分子可以是自交叉的但每次出现这种情况都是一个消耗结合能的过程，在交叉点处那条带负电的链并不与带正电的表面接触，而是被强迫与另一条带负电的链接触。因此我们可以认为线团尺寸遵从二维无规自回避行走标度律，标度指数为0.75。一旦结合在平面上，DNA 链就开始各种蜿蜒构象间的变化，梅尔和雷德勒尔计算出了高分子链的回转半径与首末端距离的均方有关，标度指数0.79 接近于理论的0.75。
[2]
随机游走与金融市场
股票市场由无数的亚单元即投资者构成。每个投资者为个人经验、感情和不完全信息所左右，其决策立足于其他投资的的决策以及汇总的信息中的随机事件，在经济学上研究这样的决策叫做博弈论（game theory）。当然单个投资者的行为不可预测，但长期来看，股票价格作某种带漂移的无规则行走。驱动这个行走的包括投资者的突发奇想、自然灾难、公司倒闭、以及其他不可预知的新闻事件。
为什么行走会是随机？假如一个分析员发现12 月末股价会上扬，到1 月初在下跌，一旦这种规律被市场参与者得知自然人们会选择这段时间内抛出股票，这一行为导致了股票下跌，消除了这种效应的可能。股票的公平原则即要求公开信息资源，使得一个投资者没有更多战胜其他投资者的有用信息。在信息完全公开的情况下长时间的股票曲线应该近似于一维无规则行走。
任何无规则行走者所带的守恒量都各自对应着一个扩散运输定律。比如粒子数守恒对应物质扩散，能量守恒对应热传导定律，热传导定律可以看成另一条菲克型定律。
互联网用户在上网时，往往有类似的网络行为：输入网址，浏览页面，然后顺着页面的链接不断打开新的网页。随机游走模型就是针对浏览网页的用户行为建立的抽象概念模型。之所以要建立这个抽象概念模型，是因为包括PageRank算法在内的很多链接分析算法都是建立在随机游走模型基础上的。
在最初阶段，用户打开浏览器浏览第1 个网页，假设我们有一个虚拟时钟用来计时，此时可以设定时间为1，用户在看完网页后，对网页内某个链接指向的页面感兴趣，于是点击该链接，进入第2 个页面，此时虚拟时钟再次计时，时钟走向字2，如果网页包含了k 个出链，则用户从当前页面跳转到任意一个链接所指向页面的概率是相等的。
用户不断重复以上过程，在相互有链接指向的页面之间跳转。如果对于某个页面所包含的所有链接，用户都没有兴趣继续浏览，则可能会在浏览器中输入另外一个网址，直接到达该网页，这个行为称为远程跳转（Teleporting）。假设互联网中共有m 个页面，则用户远程跳转到任意一个页面的概率也是相等的，即为1/m。随机游走模型就是一个对直接跳转和远程跳转两种用户浏览行为进行抽象的概念模型。
[4]
哈维茨（Hurwiez）创立的机制设计理论中“激励相容”是指：在市场经济中，每个理性经济人都会有自利的一面，其个人行为会按自利的规则行为行动；如果能有一种制度安排，使行为人追求个人利益的行为，正好与企业实现集体价值最大化的目标相吻合，这一制度安排，就是“激励相容”。现代经济学理论与实践表明，贯彻“激励相容”原则，能够有效地解决个人利益与集体利益之间的矛盾冲突，使行为人的行为方式、结果符合集体价值最大化的目标，让每个员工在为企业“多做贡献中成就自己的事业，即个人价值与集体价值的两个目标函数实现一致化。
参与者理性实现个体利益最大化的策略，与机制设计者所期望的策略一致，从而使参与者自愿按照机制设计者所期望的策略采取行动。
产生“相互抱怨”的企业都有一个共同的特点，即激励机制的缺失或扭曲。论资排辈、岗位僵死、固定的工资、平均的福利等现象在一些企业“普遍存在，企业对个人的考核主要是根据资历、学历、职务或职称来确定。这种情况下，鼓励了员工片面地追求高学历、高职务、高职称，忙于应付各种考核，把相当一部分精力放在满足这些指标上，而忽视了实际能力的培养和发展。造成的结果是劳动报酬与劳动贡献发生偏离，影响着员工的工作态度，甚至出现怠工、出工不出力、出力不出活现象。解决问题的途径就是要设计合理的激励机制及手段，要将劳动贡献与报酬直接挂钩，淡化资历、学历、职称等对收入的影响，破除惟学历、资历、身价等条条框框，不拘一格选拔人才、使用人才、培养人才。激励手段中要将个人的收入更多地以货币收入的形式出现，尽量抑制个人对非货币收入的动机，使个人与集体的两个目标函数一致起来，使两者的价值追求”相容“，为实现个人与企业的”双赢“打下良好的制度基础。
就实际情况而言，许多企业“存在着激励不相容问题，在具体工作中表现为，企业认为职工”没有集体观念“、”个人得失看得太重“、”没有长远发展的眼光“等，另一方面，个人则认为企业”没有为个人的发展提供足够的空间“、”制度设计不合理，抑制个人才能的发挥“、”劳动成果没有得到相应的报酬与认可“等等。这些现实的矛盾与冲突，根本原因就在于激励相容机制的缺失，使得企业与个人在实现各自价值的过程目标函数产生了异化，进而表现出了企业与个人的”相互抱怨“，并造成”墙内开花墙外香“的现象。那么，如何才能设计出个人与企业价值的激励相容机制，从而实现两者价值最大化的”双赢“之道呢？
为员工提供发展路径
大多数企业员工的薪酬待遇是随着个人管理地位的提高而增加的，也就是说，对于从事具体业务的人而言，要想收入提高，就需谋得较高的管理职位。这种实质上收入分配的职务化，导致了员工个人发展路径的盲目化。一些员工本身优势在于专业项，但为了更高的物质收入，不得不把相当一部分精力从钻研业务中抽出来，去谋“职”、求“位”。为员工设计多渠道的职业发展路径就可以有效地解决这个问题。20世纪初，美国在一些企业实施的“双阶梯激励机制”，是为了给组织中的专业技术人员提供与管理人员平等的职业发展机会而设计的一种职业生涯系统和激励机制。在这种机制下，专业技术人员的职业生涯可以有两条平等的路径：一条是管理职业生涯路径，一条是技术职业生涯路径，走技术阶梯人员能够与管理人员享有平等的发展机会和发展层级。这样，一方面可以鼓励那些在业务技术上有优势和潜力的员工专心走业务技术的道路，为企业“业务的创新与发展做出特有的贡献，另一方面，在一定程度上有效地扭转了员工把进入管理层作为惟一的职业发展道路的局面，为员工个人职业生涯打开更多的通道，为员工提供了”海阔凭鱼跃，天高任鸟飞“的自由发展空间。
凝聚优秀人才
没有良好的企业文化，员工与企业“很难做到真正意义上的休戚相关。实践表明，企业仅仅靠条条框框的”条例“、”规章“、”制度“是不能有效地解决组织运行中的诸多问题，尤其是不能使设计良好的公司治理结构发挥出应有的作用，而企业文化作为各种规章制度发挥作用的根基，作为可以使人心服的”软件“，在人力资源潜能的调动中具有重要的作用。要在管理中贯彻”以人为本“的思想。强调对人性的理解和尊重，按人性的规律对人进行管理，将企业的经营思想、价值理念、行为方式等整合到员工的思想和工作中去，促使每个员工的积极性得以充分释放。
只有充分尊重劳动成果、激发个人潜能的制度设计，才是有效的、激励相容的制度。企业在设计激励相容机制时，要真正做到岗有所需、人有所值，实现人力资源配置最优化，切实把人力资源变为人力资本，保证企业价值实现的同时，能够使员工自身的优势和特长得到充分发挥，促进整体素质的提高、知识的升华和价值的实现。惟有如此，才能真正实现个人与企业“价值的”双赢“。
探索培训方法
不可否认的是，许多企业“的培训还只是停留在”头痛医头，脚痛医脚“的应付工作性阶段。变革这种陈旧的培训理念与方法，就要坚持以人为本的理念，遵循人才培养规律与人才成长的内在规律，探索新型的培训方法。在培训方式上，把长期培训与短期培训、全员培训与个别培训、理论培训与实践培训、适应性培训与前瞻性培训、脱产学习与在岗学习、请进来与走出去等多方面相结合。在培训内容上，既要注重对具体业务知识的培训，又要突出对新知识、新理论、新技能、新方法的培训，同时还要注意加强对员工的整体素质、思维方式、创新能力的培训。要使培训工作制度化，根据各企业”的具体情况，在广泛征求员工意见建议的基础上，制定相应的年度培训方案与计划，从应付性的培训中走出来，既要培养岗位能手、业务骨干，又要培养善于分析问题、解决问题的专家型、管理型人才；既要培养员工的基本知识、业务知识，又要培训员工的整体素质，使员工从内心深处感受到培训是对自己进一步发展的积累，是企业“给个人提供的一种无形而高价的”福利“。
目标冲突与激励相容
来自军队的启示
在战争中，将军与士兵的目标既有一致的地方，也有相异之处。打赢战争，减少伤亡，是将军与士兵的共同愿望。相异之处在于目标的排序：将军以赢得战争为第一，减少伤亡为第二，而士兵则以自身安全为第一，赢得战争为第二。此类问题也存在于企业或其它类型的组织中，例如在目标排序上，经营者阶层视企业生存和长期发展为第一目标，将员工收入和脑体力支出列为其次，而员工的目标排序则与此相反，将自己收入的提高和安逸甚至是“偷懒”视为第一，将企业长期发展视为第二。军队是一个特殊的组织，存在于其中的目标冲突及解决办法，于企业或其它类型的组织也不无启迪。
一支军队作为一个整体，在战争中只有人人向前，英勇善战，不避艰险，不畏牺牲，才能赢得胜利，减少伤亡。只有这样，才能从总体上既满足将军的目的，也符合士兵的愿望。因此，从战争的总体目标出发，人人都应该奋勇向前才是。但从士兵的角度看，一马当先或奋勇向前则意味着自己不伤即亡，若伤亡在即，胜利于我何益？况且作为个体，士兵只能控制自己的战斗行为：如果我往前冲，别人向后撤，则我亡人存；如果我往后撤，别人也往后撤，全员皆退，那就要比比脚下的功夫，看谁撤得快。所以作为个体，一个理性的选择是：他人在前我在后，他人先冲我后上；他人迟疑不前，我就悄悄地开溜；如果大家都想溜，我就捷足先溜。如果人人都持定这样的想法，则兵将均亡，满盘皆输，个人的理性选择招致了集体的灾难。 为解决这一矛盾，军队开出的药方与其它组织并无二致，赏罚并用或规范地说，是正激励与负激励措施相结合，差异只在于表现形式不同。
正激励
战前及战争中的鼓动作用是非常重要的。我国古代作战最讲求士气的调动，就是说除了战争的硬件条件外，还要注重软件建设，即重视战争主体——人的作用，所谓“一鼓作气”说的就是这个道理。在兵家泰斗毛泽东的政治军事思想体系中，人在战争中的作用被提升到了一个极为重要的地位，如战争胜利愿景的描绘，军队中设立政治委员，支部建在连上，强调政治思想工作，强调政治宣传的作用，注重政治思想觉悟的提高，战前动员大会，爱国主义教育，战前忆苦和讨伐声势的营造……，凡此种种，无不在他运筹帷幄的战争艺术中，被发挥得淋漓尽致。解放战争中，有经验的老兵通过《白毛女》戏剧的演出，就能够嗅出大战在即的味道。
战后奖励的形式更多，如表彰英雄，按功行赏，加官晋级，抚慰战争遗孤等等。军队中的各级长官都或多或少地享有一些特权，从某种程度上说，这些特权也扮演着正激励的作用。因为升迁与否，是与战争绩效紧密挂钩的，况且，升迁之后，在战争中伤亡的可能性就会大大降低。这与士兵减少伤亡，打赢战争的目标排序是吻合的。
负激励
体罚、打骂是一种较为常见的负激励形式。古代军队中的割耳、鞭笞、差遣苦役……，现代军队中的批评、教育、警告、记过、关禁闭等，都是负激励措施。夺命是负激励的最高形式，古今中外的军队都设有不同形式的督战队，对逃逸和开小差的士兵，都无一例外地施以夺命的极刑。所以，开溜的想法是断不可有的，只能奋勇向前；左右都是一死，何不来得壮烈些，或许还会荫福家人。
“置之死地而后生”，是一种将正负最高激励形式都演绎到极限的一种战法。它为全军模拟了一种死期逼近的环境，生机只在奋勇向前。但此法的适用条件较为苛刻，一旦失败，战争成本较高。古者，有马谡失街亭，迫使诸葛亮罢兵的战例。今者，有抗日战争中的南京卫戍司令唐生智，战前请樱，信誓旦旦，试与南京共存亡。为表示背水一战、自断退路的决心，他将渡船全部销毁，让原来两艘可容七八百人的轮渡开赴汉口，同时指示江北的胡宗南第一军和江南悒江门外的宋希濂36师：若有人私渡，军法处置。岂料战事未几，唐生智却突然向各路守军发出撤退命令，自己也背弃了与南京共存亡的誓言，于1937年12月12日晚8许，乘坐为他保留的最后一条小汽艇北渡长江逃窜，成为中华民族的罪人。“置之死地而后生”的战法原理既适用于组织，也适用于个人。有人考托福，不惜大事张扬，搞得全单位人人知晓，既拉开了一种不成功决无退路的架式，也巧逼单位提供种种备考的便利，可谓一举两得；也有的人，遮遮掩掩，生怕考不好辱没了声名，无颜面对父老乡亲。相比较之下，前者将鼓足风帆，一路向前，而后者则欲步趑趄，甚至中途见弃。
人们通常认为，军服或为草绿，或为米黄，或为迷彩，只是一种便于伪装的保护色而已。其实，军服也是一种区别敌友的标志。在战败之际，不同的服饰使溃散之敌暴露在光天化日之下，有利于对方识别、清剿。不胜则败，不进则亡，军服在溃败之际也发挥着一种负激励的作用。
军队作战只是一个极端的例子。在现实经济生活中此类现象可谓举目皆是，我们手中可以“驭人”的武器——正激励和负激励——也始终没有发生变化。不论我们在人生的舞台上扮演什么样的角色，领导者，老板、经理，中层干部，为人夫或为人妻，为人父母或为人师长，概莫能外，只是激励的形式和程度不同而已。
对于组织或企业而言，军队例证的启示意义在于：1.某些强制性的负激励措施，如行政部门处罚和政府管制等，是必要的；2.作战中士兵少打枪、不瞄准乱开枪或脚底抹油——开溜等行为，与现代企业组织团队作业中有人偷懒、怠工等消极行为，多有相似之处，因此运用正、负激励手段，以期奖勤罚懒，也始终是企业“将领”使役“士兵”的不二法门。3.在战争中，极刑是对官兵的最高惩罚，而企业充其量只能将员工“开除”，从表面上看两者相去甚远，但若施用得当，也会创造异曲同工的效果。极刑于生者而言，意味着已经无路可退，只能选择奋勇向前；被开除的人若就业机会较多，开除就不会起到警训作用，因此，设置一定的再就业障碍就显得十分必要。在西方国家，前任雇主的推荐信往往是再就业时的敲门砖，若前雇主的评价较低，寻找下一份工作时就会遇到障碍。这种非正式的制度安排，很值得我们借鉴。
对于一个字符串变量，例如"adereegfbw",它的子串就是像"ader"这样可以从中找到的连续的字符串。字符串"adereegfbw"本身也属于它本身最长的子串。
ab的子串：a、b、ab和一个空子串共4个即（2+1+1）个，abc的子串：a、 b、 c、 ab、 bc 、abc和一个空子串 共（3+2+1+1）个，
所以若字符串的长度为n,则子串的个数就是[n*(n+1)/2]+1个，"software"中非空子串的个数就是8+7+....+1=36个。
对于一个字符串变量，例如"adereegfbw",它的子串就是像"ader"这样可以从中找到的连续的字符串。字符串"adereegfbw"本身也属于它本身最长的子串。
ab的子串：a、b、ab和一个空子串共4个即（2+1+1）个，abc的子串：a、 b、 c、 ab、 bc 、abc和一个空子串 共（3+2+1+1）个，
所以若字符串的长度为n,则子串的个数就是[n*(n+1)/2]+1个，"software"中非空子串的个数就是8+7+....+1=36个。
在C语言中， 数组
[2] 
属于构造数据类型。一个数组可以分解为多个数组元素，这些数组元素可以是基本数据类型或是构造类型。因此按数组元素的类型不同，数组又可分为数值数组、字符数组、指针数组、结构数组等各种类别。
关于可变长数组（VLA）的问题：原来的C89标准中是不允许可变长数组出现的，但是在C99标准中，加入了对VLA的支持
[3] 
，但是支持的编译器不多，而且由于栈溢出的安全问题，没有太多的人敢用这个可变长数组，所以在C11标准中又把它规定为可选实现的功能了
[4] 
。
如果有过用其它语言编程的经历，那么想必会熟悉数组的概念。由于有了数组，可以用相同名字引用一系列变量，并用数字（索引）来识别它们。在许多场合，使用数组可以缩短和简化程序，因为可以利用索引值设计一个循环，高效处理多种情况。数组有上界和下界，数组的元素在上下界内是连续的。因为 Visual Basic对每一个索引值都分配空间，所以不要不切实际声明一个太大的数组。
此处数组是程序中声明的变量数组。它们不同于控件数组，控件数组是在设计时通过设置控件的 Index 属性规定的。变量数组总是连续的；与控件数组不同的是，不能从一个数组的中部加载或卸载数组元素。
一个数组中的所有元素具有相同的数据类型（在C、C++、Java、pascal中都这样。但也并非所有涉及数组的地方都这样，比如在Visual Foxpro中的数组就并没这样的要求）。当然，当数据类型为 Variant 时，各个元素能够包含不同种类的数据（对象、字符串、数值等等）。可以声明任何基本数据类型的数组，包括用户自定义类型和对象变量。
如果要用户输入的是一个数组，一般是用一个循环，但是在输入前也需要固定数组的大小。
compact跟变长数组没有太大的关系，也应该用不到变长数组。因为一般的传数组到函数中就是传数组的地址和元素的个数的，那只是一个提示，不是要求。
原型可以这样写（假设数组的元素是type）：
int compact(type *Array,int Count)
数组类型说明 在C语言中使用数组必须先进行类型说明。
数组说明的一般形式为：类型说明符 数组名 [常量表达式]，……； 其中，类型说明符是任一种基本数据类型或构造数据类型。数组名是用户定义的数组标识符。方括号中的常量表达式表示数据元素的个数，也称为数组的长度。
数组就是一次性定义相同数据类型的一组变量数组定义。
数组举例
int a[10]; 说明整型数组a，有10个元素。若要表示第10个元素，则使用a[9]。第一个则是a[0]。
float b[10],c[20]; 说明实型数组b，有10个元素，实型数组c，有20个元素。
char ch[20]; 说明字符数组ch，有20个元素。
数组特点
1.数组是相同数据类型的元素的集合。
2.数组中的各元素的存储是有先后顺序的，它们在内存中按照这个先后顺序连续存放在一起。
3.数组元素用整个数组的名字和它自己在数组中的顺序位置来表示。例如，a[0]表示名字为a的数组中的第一个元素，a[1]代表数组a的第二个元素，以此类推。
对于VB的数组，表示数组元素时应注意：
1下标要紧跟在数组名后，而且用圆括号括起来（不能用其他括号）。
2下标可以是常量，变量，或表达式，但其值必须是整数（如果是小数将四舍五入为整数)。
3下标必须为一段连续的整数，其最小值成为下界，其最大值成为上界。不加说明时下界值默认为1。
数组与结构或类中的字段的区别
数组中的所有元素都具有相同类型（这一点和结构或类中的字段不同，它们可以是不同类型）。数组中的元素存储在一个连续性的内存块中，并通过索引来访问（这一点也和结构和类中的字段不同，它们通过名称来访问）。
[1]
数组类型
数组元素并非只能是基元数据类型，还可以是结构、枚举或类。
[1]
数组栈内存
在方法中定义的一些基本类型的变量和对象的引用变量都在方法的栈内存中分配，当在一段代码中定义一个变量时，java就在栈内存中为这个变量分配内存空间，当超出变量的作用域后，java会自动释放掉为该变量所分配的内存空间。
数组堆内存
堆内存用来存放由new运算符创建的对象和数组，在堆中分配的内存，由java虚拟机的自动垃圾回收器来管理。在堆中创建了一个数组或对象后，同时还在栈内存中定义一个特殊的变量。让栈内存中的这个变量的取值等于数组或者对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量，引用变量实际上保存的是数组或对象在堆内存中的地址（也称为对象的句柄），以后就可以在程序中使用栈的引用变量来访问堆中的数组或对象。
[5]
数组与结构或类中的字段的区别
数组中的所有元素都具有相同类型(这一点和结构或类中的字段不同，它们可以是不同类型)。数组中的元素存储在一个连续性的内存块中，并通过索引来访问(这一点也和结构和类中的字段不同，它们通过名称来访问)。
[1]
声明固定大小的数组
有三种方法声明固定大小的数组，用哪一种方法取决于数组应有的有效范围：
（1）建立公用数组，在模块的声明段用 Public语句声明数组。
（2）建立模块级数组，在模块的声明段用 Private语句声明数组。
（3）建立局部数组，在过程中用 Private语句声明数组。
设定上下界
声明数组时，在数组名之后跟一个用括号括起来的上界。
上界不得超过 Long数据类型的范围（-2,147,483,648 到 2,147,483,647）。
例如，下列数组声明可出现、在模块的声明段：
Dim Counters （14） As Integer '15 个元素。
Dim Sums （20） As Double '21 个元素。
为建立公用数组，直接用 Public 取代 Dim。
Public Counters （14） As Integer
Public Sums （20） As Double
在过程之中同样的声明使用 Dim：
Dim Counters （14） As Integer
Dim Sums （20） As Double
第一个声明建立了一个有 15 个元素的数组，其索引号从 0 到 14。
第二个声明建立了一个有 21 个元素的数组，其索引号从 0 到 20。缺省的下界为 0。
为了规定下界，用关键字 To 显式提供下界（为 Long数据类型）：
Dim Counters （1 To 15） As Integer
Dim Sums （100 To 120） As String
在前述声明中，Counters 的索引值范围从 1 到 15，而 Sums 的索引值范围从 100 到 120。
包含其它数组的数组
有可能建立 Variant数据类型数组，并与不同数据类型的数组共居一处。
以下代码建立两个数组，一个包含整数，而另一个包含 字符串。然后声明第三个 Variant 数组，并将整数和字符串数组放置其中：
Private Sub Command1_Click ()
Dim intX As Integer 声明计数器变量。
声明并放置整数数组。
Dim countersA （5） As Integer
For intX = 0 To 4
countersA (intX) = 5
Next intX
声明并放置字符串数组。
Dim countersB （5） As String
For intX = 0 To 4
countersB (intX) = "hello"
Next intX
Dim arrX （2） As Variant 声明拥有两个成员的新数组。
arrX （1） = countersA () 将其它数组移居到数组。
arrX （2） = countersB ()
MsgBox arrX （1） （2） 显示每一个数组的成员。
MsgBox arrX （2） （3）
End Sub
php数组的定义、调用和修改
array() 创建数组，带有键和值。如果在规定数组时省略了键，则生成一个整数键，这个 key 从 0 开始，然后以 1 进行递增
[6] 
。
要用 array() 创建一个关联数组，可使用 => 来分隔键和值。
语法　　array(key => value)　　参数key可选。规定 key，类型是数值或字符串。如果未设置，则生成整数类型的 key。　　value必需。规定值。　　<h3><font color="#CC6600">输出aaaaaabbbbbb</font></h3>　　<?php　　$array = array("key1" => "aaaaaa", 2 => "bbbbbb"); //数组的创建　　echo $array["key1"]; //输出aaaaaa　　echo $array[2]; //输出bbbbbb　　?>
数组遍历数组
C#提供了foreach语句来遍历数组的所有元素。
[7]
例如：
using System;　
using System.Collections.Generic;　
using System.Linq;　
using System.Text;　
using System.Threading.Tasks;
namespace shuzhu2　
{　
class Program　
{　
static void Main(string[] args)　{

　int[] pins = { 1, 2, 4, 5 ,9,7,13};　
foreach (int pin in pins)　
{　Console.WriteLine(pin);　
}
}
}
运行结果：1
　     2　
        4　
        5　
        9　
        7　
        13
数组多维数组
有时需要追踪记录数组中的相关信息。
例如，为了追踪记录计算机屏幕上的每一个像素，需要引用它的 X、Y坐标。这时应该用多维数组存储值。
可用 Visual Basic 声明多维数组。
例如，下面的语句声明了一个过程内的 10 × 10 的二维数组。
Static MatrixA （9,9） As Double
可用显式下界来声明两个维数或两个维数中的任何一个：
Static MatrixA （1 To 10,1 To 10） As Double
可以将所有这些推广到二维以上的数组。例如：
Dim MultiD （3,1 To 10,1 To 15）
这个声明建立了三维数组，大小为 4 × 10 × 15。元素总数为三个维数的乘积，为 600。
注意
在增加数组的维数时，数组所占的存储空间会大幅度增加，所以要慎用多维数组。使用 Variant 数组时更要格外小心，因为他们需要更大的存储空间。
数组用循环操作数组
可以用 For循环嵌套有效的处理多维数组。例如，在 MatrixA 中基于每个元素在数组中的位置为其赋值：
Dim I As Integer,J As Integer
Static MatrixA（1 To 10,1 To 10） As Double
For I = 1 To 10
For J = 1 To 10
MatrixA (I,J) = I * 10 + J
Next J
Next I
数组一维数组
定义
一维数组是最简单的数组，其逻辑结构是线性表。要使用一维数组，需经过定义、初始化和应用等过程。
数组声明
在数组的声明格式里，“数据类型”是声明数组元素的数据类型，可以是java语言中任意的数据类型，包括简单类型和结构类型。“数组名”是用来统一这些相同数据类型的名称，其命名规则和变量的命名规则相同。
数组声明之后，接下来便是要分配数组所需要的内存，这时必须用运算符new，其中“个数”是告诉编译器，所声明的数组要存放多少个元素，所以new运算符是通知编译器根据括号里的个数，在内存中分配一块空间供该数组使用。利用new运算符为数组元素分配内存空间的方式称为动态分配方式。
举例：
int[]x; //声明名称为x的int型数组
x=new int[10]; //x数组中包含有10个元素，并为这10个元素分配内存空间
在声明数组时，也可以将两个语句合并成一行，格式如下：
数据类型[]数组名= new 数据类型[个数];
利用这种格式在声明数组的同时，也分配一块内存供数组使用。如上面的例子可以写成：
int[]x = new int [10];
等号左边的int[]x相当于定义了一个特殊的变量x，x的数据类型是一个对int型数组对象的引用，x就是一个数组的引用变量，其引用的数组元素个数不定。等号右边的new int[10]就是在堆内存中创建一个具有10个int型变量的数组对象。int[]x = new int [10];就是将右边的数组对象赋值给左边的数组引用变量。
[5]
数组二维数组
定义
前面介绍的数组只有一个下标，称为一维数组， 其数组元素也称为单下标变量。在实际问题中有很多量是二维的或多维的， 因此C语言允许构造多维数组。多维数组元素有多个下标， 以标识它在数组中的位置，所以也称为多下标变量。本小节只介绍二维数组，多维数组可由二维数组类推而得到。二维数组类型说明的一般形式是：
类型说明符数组名[常量表达式1][常量表达式2]…；
其中常量表达式1表示第一维下标的长度，常量表达式2 表示第二维下标的长度。例如：
int a[3][4]; 说明了一个三行四列的数组，数组名为a，其下标变量的类型为整型。该数组的下标变量共有3×4个，即：
a[0][0],a[0][1],a[0][2],a[0][3]
a[1][0],a[1][1],a[1][2],a[1][3]
a[2][0],a[2][1],a[2][2],a[2][3]
二维数组在概念上是二维的，即是说其下标在两个方向上变化， 下标变量在数组中的位置也处于一个平面之中， 而不是象一维数组只是一个向量。但是，实际的硬件存储器却是连续编址的， 也就是说存储器单元是按一维线性排列的。如何在一维存储器中存放二维数组，可有两种方式：一种是按行排列， 即放完一行之后顺次放入第二行。另一种是按列排列， 即放完一列之后再顺次放入第二列。在C语言中，二维数组是按行排列的。在如上中，按行顺次存放，先存放a[0]行，再存放a[1]行，最后存放a[2]行。每行中有四个元素也是依次存放。由于数组a说明为
int类型，该类型占两个字节的内存空间，所以每个元素均占有两个 字节（图中每一格为一字节）。
数组三维数组
三维数组，是指维数为三的数组结构。三维数组是最常见的多维数组，由于其可以用来描述三维空间中的位置或状态而被广泛使用。
三维数组就是维度为三的数组，可以认为它表示对该数组存储的内容使用了三个独立参量去描述，但更多的是认为该数组的下标是由三个不同的参量组成的。
数组这一概念主要用在编写程序当中，和数学中的向量、矩阵等概念有一定的差别，主要表现：在数组内的元素可以是任意的相同数据类型，包括向量和矩阵。
对数组的访问一般是通过下标进行的。在三维数组中，数组的下标是由三个数字构成的，通过这三个数字组成的下标对数组的内容进行访问。
元素的表示方法
二维数组的元素也称为双下标变量，其表示的形式为：数组名[下标][下标]
其中下标应为整型常量或整型表达式。例如：a[3][4] 表示a数组三行四列的元素。
下标变量和数组说明在形式中有些相似，但这两者具有完全不同的含义。数组说明的方括号中给出的是某一维的长度，即可取下标的最大值； 而数组元素中的下标是该元素在数组中的位置标识。前者只能是常量， 后者可以是常量，变量或表达式。
一个学习小组有5个人，每个人有三门课的考试成绩。求全组分科的平均成绩和各科总平均成绩。
课程 成绩姓名Math　C　DBASE
张　80　75　92
王　61　65　71
李　59　63　70
赵　85　87　90
周　76　77　85
可设一个二维数组a[5][3]存放五个人三门课的成绩。再设一个一维数组v[3]存放所求得各分科平均成绩，设变量l为全组各科总平均成绩。编程如下：
void main()
{
int i,j,s=0,l,v[3],a[5][3];
printf("input score\n");
for(i=0;i<3;i++){
for(j=0;j<5;j++)
{ scanf("%d",&a[j][i]);
s=s+a[j][i];}
v[i]=s/5;
s=0;
}
l=(v[0]+v[1]+v[2])/3;
printf("math:%d\nc languag:%d\ndbase:%d\n",v[0],v[1],v[2]);
printf("total:%d\n",l);
}
程序中首先用了一个双重循环。在内循环中依次读入某一门课程的各个学生的成绩，并把这些成绩累加起来， 退出内循环后再把该累加成绩除以5送入v之中，这就是该门课程的平均成绩。外循环共循环三次，分别求出三门课各自的平均成绩并存放在v数组之中。退出外循环之后，把v[0],v[1],v[2]相加除以3即得到各科总平均成绩。最后按题意输出各个成绩。
初始化
二维数组初始化也是在类型说明时给各下标变量赋以初值。二维数组可按行分段赋值，也可按行连续赋值。例如对数组a[5][3]：
1.按行分段赋值可写为static int a[5][3]={{80,75,92},{61,65,71},{59,63,70},{85,87,90},{76,77,85}};
2.按行连续赋值可写为static int a[5][3]={{80,75,92,61,65,71,59,63,70,85,87,90,76,77,85 }};
这两种赋初值的结果是完全相同的。
void main()
{
int i,j,s=0,l,v[3];
static int a[5][3]={ {80,75,92},{61,65,71},{59,63,70},
{85,87,90},{76,77,85} };
for(i=0;i<3;i++)
{ for(j=0;j<5;j++)
s=s+a[j];
v=s/5;
s=0;
}
l=(v[0]+v[1]+v[2])/3;
printf("math:%d\nc languag:%d\ndbase:%d\n",v[0],v[1],v[2]);
printf("total:%d\n",l);
}
初始化的额外说明
对于二维数组初始化赋值还有以下说明：
1.可以只对部分元素赋初值，未赋初值的元素自动取0值。
例如：static int a[3][3]={,,}; 是对每一行的第一列元素赋值，未赋值的元素取0值。赋值后各元素的值为：1 0 02 0 03 0 0
static int a [3][3]={{0,1},{0,0,2},}; 赋值后的元素值为 0 1 00 0 23 0 0
2.如对全部元素赋初值，则第一维的长度可以不给出。
例如：static int a[3][3]={1,2,3,4,5,6,7,8,9}; 可以写为：static int a[][3]={1,2,3,4,5,6,7,8,9};
分解
数组是一种构造类型的数据。二维数组可以看作是由一维数组的嵌套而构成的。设一维数组的每个元素都又是一个数组， 就组成了二维数组。当然，前提是各元素类型必须相同。
根据这样的分析，一个二维数组也可以分解为多个一维数组。C语言允许这种分解有二维数组a[3][4]，可分解为三个一维数组，其数组名分别为a[0],a[1],a[2]。对这三个一维数组不需另作说明即可使用。这三个一维数组都有4个元素，例如：一维数组a[0]的元素为a[0][0],a[0][1],a[0][2],a[0][3]。最后必须强调的是，a[0],a[1],a[2]不能当作下标变量使用，它们是数组名，不是一个单纯的下标变量。
数组字符数组
用来存放字符量的数组称为字符数组。
字符数组类型说明的形式与前面介绍的数值数组相同。例如：char c[10]; 由于字符型和整型通用，也可以定义为int c[10]但这时每个数组元素占2个字节的内存单元。
字符数组也可以是二维或多维数组，例如：char c[5][10]；即为二维字符数组。
字符数组也允许在类型说明时作初始化赋值。例如：static char c[10]={`c`,` `,`p`,`r`,o`,g`,r`,`a`,`m`};赋值后各元素的值为：数组C c[0]c[1]c[2]c[3]c[4]c [5]c[6]c[7]c[8]c[9]其中c[9]未赋值，由系统自动赋予0值。
当对全体元素赋初值时也可以省去长度说明。例如：static char c[]={`c`,` `,`p`,`r`,`o`,`g`,`r`,`a`,`m`};这时C数组的长度自动定为9。
main()
{
int i,j;
char a[][5]={{'B','A','S','I','C',},{'d','B','A','S','E'}};
for(i=0;i<=1;i++)
{
for(j=0;j<=4;j++)
printf("%c",a[j]);
printf("\n");
}
}
本例的二维字符数组由于在初始化时全部元素都赋以初值， 因此一维下标的长度可以不加以说明。字符串在C语言中没有专门的字符串变量， 通常用一个字符数组来存放一个字符串。在2.1.4节介绍字符串常量时，已说明字符串总是以'\0'作为串的结束符。因此当把一个字符串存入一个数组时， 也把结束符'\0'存入数组，并以此作为该字符串是否结束的标志。有了'\0'标志后，就不必再用字符数组的长度来判断字符串的长度了。
C语言允许用字符串的方式对数组作初始化赋值。例如：
static char c[]={'c',' ','p','r','o','g','r','a','m'}; 可写为：
static char c[]={"C program"}; 或去掉{}写为：
static char c[]="C program";
用字符串方式赋值比用字符逐个赋值要多占一个字节， 用于存放字符串结束标志'\0'。上面的数组c在内存中的实际存放情况为：C program'\0'是由C编译系统自动加上的。由于采用了'\0'标志，所以在用字符串赋初值时一般无须指定数组的长度， 而由系统自行处理。在采用字符串方式后，字符数组的输入输出将变得简单方便。除了上述用字符串赋初值的办法外，还可用scanf函数和printf函数一次性输入输出一个字符数组中的字符串， 而不必使用循环语句逐个地输入输出每个字符。
void main()
{
static char c[]="BASIC\ndBASE";
printf("%s\n",c);
} printf("%s\n",c);
注意在本例的printf函数中，使用的格式字符串为“%s”， 表示输出的是一个字符串。而在输出表列中给出数组名则可。不能写为：printf("%s",c[]);
void main()
{
char st[15];
printf("input string:\n");
scanf("%s",st);
printf("%s\n",st);
} char st[15];
本例中由于定义数组长度为15， 因此输入的字符串长度必须小于15，以留出一个字节用于存放字符串结束标志'\0'。应该说明的是，对一个字符数组，如果不作初始化赋值，则必须说明数组长度。还应该特别注意的是，当用scanf函数输入字符串时，字符串中不能含有空格，否则将以空格作为串的结束符。例如运行例4.8，当输入的字符串中含有空格时，运行情况为：input string:this is a book this 从输出结果可以看出空格以后的字符都未能输出。为了避免这种情况，可多设几个字符数组分段存放含空格的串。程序可改写如下：
Lesson
void main()
{
char st1[6],st2[6],st3[6],st4[6];
printf("input string:\n");
scanf("%s%s%s%s",st1,st2,st3,st4）;
printf("%s %s %s %s\n",st1,st2,st3,st4）;
}
本程序分别设了四个数组， 输入的一行字符的空格分段分别装入四个数组。然后分别输出这四个数组中的字符串。在前面介绍过，scanf的各输入项必须以地址方式出现，如 &a,&b等。但在例4.8中却是以数组名方式出现的，这是为什么呢?这是由于在C语言中规定，数组名就代表了该数组的首地址。整个数组是以首地址开头的一块连续的内存单元。如有字符数组char c[10]，在内存可表示如图4.2。设数组c的首地址为2000，也就是说c[0]单元地址为2000。则数组名c就代表这个首地址。因此在c前面不能再加地址运算符&。如写作scanf("%s",&c）；则是错误的。在执行函数printf("%s",c) 时，按数组名c找到首地址，然后逐个输出数组中各个字符直到遇到字符串终止标志'\0'为止。
数组元素是组成数组的基本单元。数组元素也是一种变量， 其标识方法为数组名后跟一个下标。下标表示了元素在数组中的顺序号。数组元素的一般形式为：数组名[下标] 其中的下标只能为整型常量或整型表达式。如为小数时，C编译将自动取整。例如，a[5],a[i+j],a[i++]都是合法的数组元素。数组元素通常也称为下标变量。必须先定义数组， 才能使用下标变量。在C语言中只能逐个地使用下标变量， 而不能一次引用整个数组。
初始化赋值的一般形式为：static类型说明符数组名[常量表达式]={值，值……值}； 其中static表示是静态存储类型， C语言规定只有静态存储数组和外部存储数组才可作初始化赋值（有关静态存储，外部存储的概念在第五章中介绍）。
在{ }中的各数据值即为各元素的初值， 各值之间用逗号间隔。例如：static int a[10]={ 0,1,2,3,4,5,6,7,8,9 }; 相当于a[0]=0;a[1]=1...a[9]=9;
1.数组的类型实际上是指数组元素的取值类型。对于同一个数组，其所有元素的数据类型都是相同的。
2.数组名的书写规则应符合标识符的书写规定。
3.数组名不能与其它变量名相同。
1.可以只给部分元素赋初值。当{ }中值的个数少于元素个数时，只给前面部分元素赋值。例如：static int a[10]={0,1,2,3,4};表示只给a[0]～a[4]5个元素赋值，而后5个元素自动赋0值。
2.只能给元素逐个赋值，不能给数组整体赋值。例如给十个元素全部赋1值，只能写为：static int a[10]={1,1,1,1,1,1,1,1,1,1};而不能写为：static int a[10]=1；（请注意：在C、C#语言中是这样，但并非在所有涉及数组的地方都这样，数据库是从1开始。）
3.若不给可初始化的数组赋初值，则全部元素均为0值。
4.假如给全部元素赋值，则在数组说明中， 可以不给出数组元素的个数。例如：static int a[5]={1,2,3,4,5};可写为：static int a[]={1,2,3,4,5};动态赋值可以在程序执行过程中，对数组作动态赋值。这时可用循环语句配合scanf函数逐个对数组元素赋值。
C语言提供了丰富的字符串处理函数， 大致可分为字符串的输入、输出、合并、修改、比较、转换、复制、搜索几类。使用这些函数可大大减轻编程的负担。用于输入输出的字符串函数， 在使用前应包含头文件"stdio.h" ； 使用其它字符串函数则应包含头文件"string.h"。
数组几个常用函数
下面介绍几个最常用的字符串函数：
1.字符串输出函数puts格式：puts （字符数组名） 功能：把字符数组中的字符串输出到显示器。即在屏幕上显示该字符串
#include"stdio.h"
main()
{
static char c[]="BASIC\ndBASE";
puts(c);
}
static char c[]="BASIC\ndBASE";
puts(c);
从程序中可以看出puts函数中可以使用转义字符， 因此输出结果成为两行。puts函数完全可以由printf函数取代。当需要按一定格式输出时，通常使用printf函数。
2.字符串输入函数gets格式：gets （字符数组名） 功能：从标准输入设备键盘上输入一个字符串。本函数得到一个函数值，即为该字符数组的首地址。
#include"stdio.h"
main()
{
char st[15];
printf("input string:\n");
gets(st);
puts(st);
}
可以看出当输入的字符串中含有空格时，输出仍为全部字符串。说明gets函数并不以空格作为字符串输入结束的标志， 而只以回车作为输入结束。这是与scanf函数不同的。
3.字符串连接函数strcat格式：strcat （字符数组名1，字符数组名2） 功能：把字符数组2中的字符串连接到字符数组1 中字符串的后面，并删去字符串1后的串标志“”。本函数返回值是字符数组1的首地址，而且需要字符串处理函数的包含头文件 #include"string.h" ，程序如下：
#include"string.h"
main()
{
static char st1[30]="My name is ";
int st2[10];
printf("input your name:\n");
gets(st2）;
strcat(st1,st2）;
puts(st1）;
}
static char st1[30]="My name is ";
int st2[10];
printf("input your name:\n");
gets(st2）;
strcat(st1,st2）;
本程序把初始化赋值的字符数组与动态赋值的字符串连接起来。要注意的是，字符数组1应定义足够的长度，否则不能全部装入被连接的字符串。
4.字符串拷贝函数strcpy格式：strcpy （字符数组名1，字符数组名2） 的功能：把字符数组2中的字符串拷贝到字符数组1中。串结束标志“”也一同拷贝。字符数名2， 也可以是一个字符串常量。这时相当于把一个字符串赋予一个字符数组。
#include"string.h"
main()
{
static char st1[15],st2[]="C Language";
strcpy(st1,st2）;
puts(st1）;printf("\n");
}
static char st1[15],st2[]="C Language";
strcpy(st1,st2）;
本函数要求字符数组1应有足够的长度，否则不能全部装入所拷贝的字符串。
5.字符串比较函数strcmp格式：strcmp（字符数组名1，字符数组名2） 功能：按照ASCII码顺序比较两个数组中的字符串，并由函数返回值返回比较结果。
字符串1=字符串2，返回值=0；
字符串1〉字符串2，返回值〉0；
字符串1〈字符串2，返回值〈0。
本函数也可用于比较两个字符串常量，或比较数组和字符串常量。
#include"string.h"
main()
{ int k;
static char st1[15],st2[]="C Language";
printf("input a string:\n");
gets(st1）;
k=strcmp(st1,st2）;
if(k==0) printf("st1=st2\n");
if(k>0) printf("st1>st2\n");
if(k<0) printf("st1<st2\n");
}
{ int k;
static char st1[15],st2[]="C Language";
printf("input a string:\n");
gets(st1）;
k=strcmp(st1,st2）;
if(k==0) printf("st1=st2\n");
if(k>0) printf("st1>st2\n");
if(k<0) printf("st1<st2\n");
}
本程序中把输入的字符串和数组st2中的串比较，比较结果返回到k中，根据k值再输出结果提示串。当输入为dbase时，由ASCII 码可知“dBASE”大于“C Language”故k〉0，输出结果“st1>st2”。
6.测字符串长度函数strlen格式：strlen（字符数组名） 功能：测字符串的实际长度（不含字符串结束标志‘’） 并作为函数返回值。
数组PHP 5 Array 函数
函数 描述
array() 创建数组。
array_change_key_case() 返回其键均为大写或小写的数组。
array_chunk() 把一个数组分割为新的数组块。
array_column() 返回输入数组中某个单一列的值。
array_combine() 通过合并两个数组（一个为键名数组，一个为键值数组）来创建一个新数组。
array_count_values() 用于统计数组中所有值出现的次数。
array_diff() 比较数组，返回两个数组的差集（只比较键值）。
array_diff_assoc() 比较数组，返回两个数组的差集（比较键名和键值）。
array_diff_key() 比较数组，返回两个数组的差集（只比较键名）。
array_diff_uassoc() 比较数组，返回两个数组的差集（比较键名和键值，使用用户自定义的键名 比较函数）。
array_diff_ukey() 比较数组，返回两个数组的差集（只比较键名，使用用户自定义的键名比较 函数）。
array_fill() 用给定的键值填充数组。
array_fill_keys() 用给定的指定键名的键值填充数组。
array_filter() 用回调函数过滤数组中的元素。
array_flip() 反转/交换数组中的键名和对应关联的键值。
array_intersect() 比较数组，返回两个数组的交集（只比较键值）。
array_intersect_assoc() 比较数组，返回两个数组的交集（比较键名和键值）。
array_intersect_key() 比较数组，返回两个数组的交集（只比较键名）。
array_intersect_uassoc() 比较数组，返回两个数组的交集（比较键名和键值，使用用户自定义的键名 比较函数）。
array_intersect_ukey() 比较数组，返回两个数组的交集（只比较键名，使用用户自定义的键名比较 函数）。
array_key_exists() 检查指定的键名是否存在于数组中。
array_keys() 返回数组中所有的键名。
array_map() 将用户自定义函数作用到给定数组的每个值上，返回新的值。
array_merge() 把一个或多个数组合并为一个数组。
array_merge_recursive() 递归地把一个或多个数组合并为一个数组。
数组JAVA Eclipse 的Array函数
import java.util.Arrays;//这一行的作用是载入Arrays模块
//import java.util.Array.prototype.indexOf　
public class shuzhu1 {
public static void main(String args[]) {　
int[] a={1,3,6,2,7,9};　
System.out.println("排序前的数组为：");　
System.out.println(Arrays.toString(a));//调用Arrays.toString将数组a的值　//转换为字符串并 显示出来　//调用Array.sort方法，对数组进行排序　
Arrays.sort(a);　
System.out .println("排序后的数组为：");　
//System.out.println(a+" ");若为此种写法，输出结果将出现乱码　
System.out.println(Arrays.toString(a));//调用Arrays.toString将数组a　//的值转换为字符串并 显示出来
图1显示了一网状 HPC 系统。在网状网络拓扑中，该结构支持通过缩短网络节点之间的物理和逻辑距离来加快跨主机的通信。




图1.HPC 网状网络拓扑

尽管网络拓扑、硬件和处理硬件在 HPC 系统中很重要，但是使系统如此有效的核心功能是由操作系统和应用软件提供的。
HPC 系统使用的是专门的操作系统，这些操作系统被设计为看起来像是单个计算资源。正如从图1和图2中可以看到的，其中有一个控制节点，该节点形成了 HPC 系统和客户机之间的接口。该控制节点还管理着计算节点的工作分配。
对于典型 HPC 环境中的任务执行，有两个模型：单指令/多数据 (SIMD) 和多指令/多数据 (MIMD)。SIMD在跨多个处理器的同时执行相同的计算指令和操作，但对于不同数据范围，它允许系统同时使用许多变量计算相同的表达式。MIMD允许HPC 系统在同一时间使用不同的变量执行不同的计算，使整个系统看起来并不只是一个没有任何特点的计算资源（尽管它功能强大），可以同时执行许多计算。
不管是使用 SIMD 还是 MIMD，典型 HPC 的基本原理仍然是相同的：整个HPC 单元的操作和行为像是单个计算资源，它将实际请求的加载展开到各个节点。HPC 解决方案也是专用的单元，被专门设计和部署为能够充当（并且只充当）大型计算资源。
高性能计算网格计算概述
网格对于高性能计算系统而言是相对较新的新增内容，它有自己的历史，并在不同的环境中有它自己的应用。网格计算系统的关键元素是网格中的各个节点，它们不是专门的专用组件。在网格中，各种系统常常基于标准机器或操作系统，而不是基于大多数并行计算解决方案中使用的严格受控制的环境。位于这种标准环境顶部的是应用软件，它们支持网格功能。
网格可能由一系列同样的专用硬件、多种具有相同基础架构的机器或者由多个平台和环境组成的完全异构的环境组成。专用计算资源在网格中并不是必需的。许多网格是通过重用现有基础设施组件产生新的统一计算资源来创建的。
不需要任何特别的要求就可以扩展网格，使进一步地使用节点变得比在典型HPC环境中还要轻松。有了HPC解决方案，就可以设计和部署基于固定节点数的系统。扩展该结构需要小心规划。而扩展网格则不用考虑那么多，节点数会根据您的需要或根据可用资源动态地增加和减少。




图2.网格网络架构

尽管有了拓扑和硬件，网格就可以以图1和图2中所示结构的相同结构为基础，但使用标准网络连接组件支持网格也是有可能的。甚至可以交叉常规网络边界，在WAN或互联网上合并计算资源，如图3所示。
作为执行模型和环境，网格还被设计成在操作和执行方面更具灵活性。尽管可以使用网格解决诸如HPC解决方案之类的计算任务，但网格可以更灵活，可以使用各种节点执行不同的计算、表达式和操作。网格并不只是一种没有任何特点的计算资源，可将它分布到各种节点中使用，并且一直运行到作业和操作都已完成。这使得网格在不同计算和组件的执行顺序对于剩余任务的连续执行不那么重要的地方变得更加实用。
利用这种可变长度灵活性和较孤立任务的网格解决方案的一个好例子是计算机合成电影和特技效果中的表演。在这里，生成的顺序并不重要。单帧或更大的多秒的片段可以彼此单独呈现。尽管最终目标是让电影以正确的顺序播放，但最后五分钟是否在最初的五分钟之前完成是无关紧要的；稍后可以用正确的顺序将它们衔接在一起。
网格与传统HPC解决方案之间的其他主要不同是：HPC解决方案设计用于提供特定资源解决方案，比如强大的计算能力以及在内存中保存大量数据以便处理它们的能力,另一方面，网格是一种分布式计算资源，这意味着网格可以根据需要共享任何组件，包括内存、CPU电源，甚至是磁盘空间。
因为这两个系统之间存在这些不同，因此开发出了简化该过程的不同编程模型和开发模型。
HPC解决方案的专用特性在开发应用程序以使用这种能力时提供了一些好处。大多数HPC系统将自己表现为单个计算资源，因此它成为一种编程责任，需要通过专用库来构建一个能够分布到整个资源中的应用程序。
HPC环境中的应用程序开发通常是通过专用库来处理，这极大简化了创建应用程序的过程以及将该应用程序的任务分配到整个HPC系统中的过程。
最流行的解决方案之一是消息传递接口(MPI)。MPI提供了一个创建工作的简化方法，使用消息传递在各个节点之间交换工作请求。作为开发过程的一部分，可能知道想要使用的处理器（在这里指单独节点，而非单独CPU）的数量。HPC环境中的劳动分工取决于应用程序，并且很显然还取决于HPC环境的规模。如果将进行的工作分配依赖于多个步骤和计算，那么HPC环境的并行和顺序特性将在网格的速度和灵活性方面起到重要作用。
图3.HPC功能图

一旦分配好工作，就可以给每个节点发送一条消息，让它们执行自己的那部分工作。工作被放入HPC单元中同时发送给每个节点，通常会期望每个节点同时给出结果作为响应。来自每个节点的结果通过MPI提供的另一条消息返回给主机应用程序，然后由该应用程序接收所有消息，这样工作就完成了。图3中显示了这种结构的一个示例。
执行模型通常是固定的，并且连续到完成某个单个应用程序。例如，如果将一项任务分配给256 个单元，而HPC系统中有64个节点，那么需要4个过程迭代来完成工作。工作通常是并行完成的，在整个应用程序完成之前，所有64个节点都仍将保持忙碌。在整个过程中，HPC系统充当一台机器。尽管消息已经被用来在多个计算节点中分配工作，但整个应用程序被有效地操作为一个单独的应用程序。
其他HPC库和接口的工作方式类似，具体的方式取决于开发用于HPC环境中的应用程序。无论什么时候，都可以将工作分配和执行看作一个单独的过程。尽管应用程序的执行可能要排队等候，但一旦应用程序开始运行，将立即在HPC系统的所有节点上执行该工作的各个组件。
为了处理多个同时发生的应用程序，多数HPC系统使用了一个不同应用程序在其中可以使用不同处理器/节点设置的系统。例如256个节点的HPC系统可以同时执行两个应用程序，如果每个应用程序都使用整个计算资源的一个子集的话。
高性能计算网格编程
网格的分布式（常常是非专用的）结构需要为工作的执行准备一个不同的模型。因为网格的这种特性，无法期望同时执行各种工作单元。有许多因素影响了工作的执行时间，其中包括工作分配时间以及每个网格节点的资源的有效功率。
因为各个节点中存在的不同之处和工作被处理的方式，网格使用了一个将网格节点的监视与工作单元的排队系统相结合的系统。该监视支持网格管理器确定各个节点上的当前负载。然后在分配工作时使用该信息，把要分配的工作单元分配给没有（或有少量）当前资源负载的节点。
图4.网格功能图

所以，整个网格系统基于一系列的队列和分布，通过在节点之间共享负载，在节点变得可用时将工作分配给队列中的每个节点，使网格作为一个整体得到更有效的使用。
响应和结果都同样地在网格控制器上进行排队，以便在处理完所有工作单元（及其结果）时将它们收集到应用程序的最终结果集中。图4中显示了这样一个示例。
网格模型允许使用各种级别的资源、工作单元规模和分配级别，而不只是HPC解决方案使用的执行模型提供的那些。大多数网格支持使用每个将被排队和分配的应用程序的各种工作单元同时执行多个工作请求。例如，可以在一些节点仍然在完成Job1上的工作时开始Job2上的工作，为了完成工作，两项作业以某种动态的方式使用相同数量的可用节点。
此过程的灵活特性不但允许以更动态更适应的方式执行工作，还允许网格与各种硬件和平台一起使用。即使网格中的某些节点比其他一些节点更快或更慢一些，也不再有任何关系；它们可以在自己（比较）空闲的时间完成工作，并且结果将被排队。其间，更快的系统可能被分配更多的工作并完成更多的工作单元。
出现这种不利现象是因为需要更繁重的管理费用来观察和监视各个节点，以便能够在节点间有效分配工作。在异构环境中，还必须考虑不同的平台，并开发跨支持环境兼容的应用程序。但在网格空间中，Web服务已简化了该过程，使分配工作变得更容易，不必担心这些不同。
在查看Web服务的效果之前，查看HPC和网格之间的会合区域，并了解这将如何影响不同的执行模型。
高性能计算会合区域
HPC 和网格环境之间存在一些类似之处，在许多方面，这二者都出现了一些会合和分歧，不同的团体利用了这两个系统的各自优点。许多网格环境已从HPC解决方案的扩展中产生，基于HPC环境中的工作，网格中使用的许多技术得到了优化和采用。
一些显而易见的类似之处是工作被分配到更小的单元和组件中的方式，以及各个工作节点之间的工作分配方式。在HPC环境中，这种劳动分配通常受到严格控制，并且是根据您的可用资源进行的。网格使用了一种更灵活的模型，该模型允许将工作分配给大小不标准的单元，因此可以在截然不同的网格节点数组之间分配工作。
尽管工作的分配方式上存在不同，但分配的基本原则仍然是相同的：先确定工作及其分配方式，然后相应地创建工作单元。例如，如果遇到计算问题，可以通过创建不同的参数集，利用将应用于每个节点的每个集合的变量来分配工作。
HPC 系统中使用的消息传递结构和系统也已开发并适用于网格系统。许多 HPC 消息传递库使用共享内存结构来支持节点之间的工作单元分配。
在网格中，共享的内存环境是不存在的。此外，工作是利用标准网络连接（通常使用TCP/IP）上发送的不同消息来分配的。系统的核心没有什么不同：交换包含工作参数的消息。只有交换信息的物理方法是不同的。
高性能计算Web 服务的影响
尽管平台独立 HPC 系统非常常见（比如 MPI，它支持多个平台和架构），但 HPC 解决方案并不能直接使用，并且许多使用仍然依赖于架构的统一。
典型网格的不同特性导致工作分配方式发生了变化。因为网格节点可能基于不同平台和架构，所以在不同公用和私用网络上，需要某种以平台为核心的交换工作和请求的方法，该方法使分配工作变得更容易，不必担心目标环境。
Web 服务基于开放标准，使用XML来分配和交换信息。该效果实质上将消除在平台和架构间共享信息的复杂性。可以编写一系列支持不同操作的Web服务，而不是编写跨网格执行的二进制应用程序，这些 Web 服务是为各种节点和平台量身订做的。部署Web服务的费用也比较低，这使得它们对于不使用专用计算节点的网格中的操作比较理想。
通过消除兼容性问题并简化信息分配方法，Web服务使网格的扩展变得更轻松。使用HPC解决方案，通常必须使用基于相同硬件的节点来扩展HPC环境的功能。而使用网格，特别是在使用Web服务时，系统几乎可以在任何平台上扩展。
网格和Web服务的其他问题是由于不再应用关闭的HPC系统和内部HPC系统而导致的常见分配和安全考虑事项。在WAN或公用网络上使用网络节点时尤为如此。对于HPC 解决方案，系统的安全可通过硬件的统一特性得到控制；对于某一位置上的所有机器，安全性更容易控制。
为了提高Web服务的互操作性，特别是在网格环境中，OASIS 团队开发了许多Web服务标准。这些标准都是通过其WS前缀来标识的。通用规范包含一些顶级 Web服务支持和全面保护规范，用于发现Web服务和选项以及信息交换（通过WS-Security）。
更深一层的标准提供了用来共享资源和信息的标准化方法（WS-Resource 和 WS-Resource Framework）、用来可靠地交换消息的标准化方法（WS-Reliable Messaging）、用于事件通知的标准化方法（WS-Notification），甚至是用于 Web 服务管理的标准化方法（WS-Distributed Management）。
出于安全考虑，可以 WS-Reliable Messaging 交换与WS-Security 标准包装在一起，这定义了用于身份验证、授权和消息交换加密的方法和过程。
通过将Web服务标准支持、安全规范和您自己的定制Web 服务组件结合在一起，可以构建一个使用多个平台和环境的高效网格。然后可以在LAN环境中使用应用程序，或者安全地通过公用网络提供与典型HPC解决方案同样强大的计算资源，但具有扩展的灵活性和对网格技术的标准支持。
高性能计算结束语
网格计算从技术上说是一种高性能计算机，但它在许多方面不同于传统的HPC 环境。大多数传统HPC技术都是基于固定的和专用的硬件，并结合了一些专门的操作系统和环境来产生高性能的环境。相比较而言，网格可以使用日用硬件、不同平台，甚至被配置成可以使用现有基础设施中的多余容量。
尽管存在一些不同，但两个系统也有许多相似之处，特别是查看跨节点的工作分工和分配时。在两种情况下，都可以使用Web服务来帮助支持系统操作。通过使用开放标准并允许支持更广范围的操作系统和环境，Web 服务和网格技术可能在高性能计算解决方案的功效和灵活性方面带来很大的不同。
[1]
各种高性能计算设施都要根据企业不同的需求选用，但所有高性能计算应用程序都必须经过特殊优化，这与传统数据中心要求不大一样。以下方式可以让HPC应用程序平台以最高的性能执行。
高性能计算选择适合的内存
有三种DIMM内存可用：UDIMM内存、RDIMM内存和LRDIMM内存。在处理较大型工作负载时，无缓冲DIMM(UDIMM)速度快、廉价但不稳定。寄存器式DIMM(RDIMM)内存稳定、扩展性好、昂贵，而且对内存控制器的电气压力小。它们同样在许多传统服务器上使用。降载DIMM(LRDIMM)内存是寄存器式内存的替代品，它们能提供高内存速度，降低服务器内存总线的负载，而且功耗更低。
高性能计算升级设施
HPC系统设计与传统数据中心基础设施设计的一大区别就是选择现成工具或定制系统。现成的系统只能在很小的范围内进行扩展，限制了未来增长。定制可以保持一个开放式的设计，让企业在将来获得更好的扩展功能。然而，额外的功能对于定制系统来说是一笔不小的代价，比购买现成系统要高得多。
高性能计算充分利用HPC
HPC应用程序设计与传统设计不同。开发者需要将信息流拆分为并行组。
高性能计算保持系统一致
当集群中出现不一致，HPC管理员可能会看到一些零星的异常货变化，影响应用程序性能。考虑到潜在的性能，IT部门需要实施策略来确认HPC系统中都运行着什么应用程序， 并想办法让配置同步。这些检查每季度应该进行，或者每年不少于两次。
高性能计算关注能耗
普通的服务器开销为每机柜30kw，这个数字还在不断上升。由于高密度，高效率数据中架构基础设施与冷却系统变得至关重要。
[2]
高性能计算(HighPerformanceComputing)是计算机科学的一个分支，主要是指从体系结构、并行算法和软件开发等方面研究开发高性能计算机的技术。
随着计算机技术的飞速发展，高性能计算机的计算速度不断提高，其标准也处在不断变化之中。
曙光CAE高性能计算平台

高性能计算简单来说就是在16台甚至更多的服务器上完成某些类型的技术工作负载。到底这个数量是需要8台，12台还是16台服务器这并不重要。在定义下假设每一台服务器都在运行自己独立的操作系统，与其关联的输入/输出基础构造都是建立在COTS系统之上。
简而言之，讨论的就是Linux高性能计算集群。
一个拥有20000台服务器的信息中心要进行分子动力学模拟无疑是毫无问题的，就好比一个小型工程公司在它的机房里运行计算流体动力学(CFD)模拟。解决工作负载的唯一限制来自于技术层面。接下来我们要讨论的问题是什么能直接加以应用。
量度(Metrics)
性能(Performance)，每瓦特性能(Performance/Watt)，每平方英尺性能(Performance/Squarefoot)和性能价格比(Performance/dollar)等，对于提及的20000台服务器的动力分子簇来说，原因是显而易见的。运行这样的系统经常被服务器的能量消耗(瓦特)和体积(平方英尺)所局限。这两个要素都被计入总体拥有成本(TCO)之列。在总体拥有成本(TCO)方面取得更大的经济效益是大家非常关注的。
议题的范围限定在性能方面来帮助大家理解性能能耗，性能密度和总体拥有成本(TCO)在实践中的重要性。
性能的定义
在这里把性能定义为一种计算率。例如每天完成的工作负载，每秒钟浮点运算的速度(FLOPs)等等。接下来要思考的是既定工作量的完成时间。这两者是直接关联的，速度=1/(时间/工作量)。因此性能是根据运行的工作量来进行测算的，通过计算其完成时间来转化成所需要的速度。
定量与定性
从定性的层面上来说这个问题很容易回答，就是更快的处理器，更多容量的内存，表现更佳的网络和磁盘输入/输出子系统。但当要在决定是否购买Linu集群时这样的回答就不够准确了。
对Linux高性能计算集群的性能进行量化分析。
为此介绍部分量化模型和方法技巧，它们能非常精确的对大家的业务决策进行指导，同时又非常简单实用。举例来说，这些业务决策涉及的方面包括：
购买---系统元件选购指南来获取最佳性能或者最经济的性能




Linux高性能计算集群模型

配置---鉴别系统及应用软件中的瓶颈
计划---突出性能的关联性和局限性来制定中期商业计划
Linux高性能计算集群模型包括四类主要的硬件组成部分。
(1)执行技术工作负载的计算节点或者服务器；
(2)一个用于集群管理，工作控制等方面的主节点；
(3)互相连接的电缆和高度普及的千兆以太网(GBE)；
(4)一些全局存储系统，像由主节点输出的NFS文件一样简单易用。
高性能计算机的衡量标准主要以计算速度(尤其是浮点运算速度)作为标准。高性能计算机是信息领域的前沿高技术，在保障国家安全、推动国防科技进步、促进尖端武器发展方面具有直接推动作用，是衡量一个国家综合实力的重要标志之一。
随着信息化社会的飞速发展，人类对信息处理能力的要求越来越高，不仅石油勘探、气象预报、航天国防、科学研究等需求高性能计算机，而金融、政府信息化、教育、企业、网络游戏等更广泛的领域对高性能计算的需求迅猛增长。
一个简单量化的运用模型
这样一个量化的运用模型非常直观。在一个集群上对既定的工作完成的时间大约等同于在独立的子系统上花费的时间：
e
1、时间(Time)=节点时间(Tnode)+电缆时间(Tfabric)+存储时间(Tstorage)
Time = Tnode + Tfabric + Tstorag
这里所说的时间(Time)指的是执行工作量的完成时间，节点时间(Tnode)是指在计算节点上花费的完成时间，电缆时间(Tfabric)是指在互联网上各个节点进行互联的完成时间，而存储时间(Tstorage)则是指访问局域网或全球存储系统的完成时间。
计算节点的完成时间大约等同于在独立的子系统上花费的时间：
2、节点时间(Tnode)=内核时间(Tcore) +内存时间(Tmemory)
这里所说的内核时间(Tcore)指的是在微处理器计算节点上的完成时间。而内存时间(Tmemory)就是指访问主存储器的完成时间。这个模型对于单个的CPU计算节点来说是非常实用的，而且能很容易的扩展到通用双插槽(SMP对称多处理)计算节点。为了使第二套模型更加实用，子系统的完成时间也必须和计算节点的物理配置参数相关联，例如处理器的速度，内存的速度等等。
计算节点
图示中的计算节点原型来认识相关的配置参数。图示上端的是2个处理器插槽，通过前端总线(FSB-front side bus)与内存控制中心(MCH)相连。这个内存控制中心(MCH)有四个存储信道。同时还有一个Infiniband HCA通过信道点对点串行(PCIe)连接在一起。
性能参数

像千兆以太网和串行接口(SATA)硬盘之类的低速的输入输出系统都是通过芯片组中的南桥通道(South Bridge)相连接的。在图示中，大家可以看到每个主要部件旁边都用红色标注了一个性能相关参数。这些参数详细的说明了影响性能(并非全部)的硬件的特性。它们通常也和硬件的成本直接相关。举例来说，处理器时钟频率(fcore)在多数工作负荷状态下对性能影响巨大。根据供求交叉半导体产额曲线原理，处理器速度越快，相应成本也会更高。
高速缓存存储器的体积也会对性能产生影响，它能减少主频所承载的工作负荷以提高其运算速度。处理器内核的数量(Ncores)同样会影响性能和成本。内存子系统的速度可以根据双列直插内存模块频率(fDIMM)和总线频率(fBus)进行参数化，它在工作负荷状态下也对性能产生影响。同样，电缆相互连接(interconnect fabric)的速度取决于信道点对点串行的频率。
而其他一些因素，比如双列直插内存模块内存延迟(DIMM CAS Latency)，存储信道的数量等都做为次要因素暂时忽略不计。
使用的性能参数
在图示中标明的6个性能参数中，保留四个和模型相关的参数。
首先忽略信道点对点串行的频率(fPCIe)，因为它主要影响的是电缆相互连接(interconnect fabric)速度的性能，这不在范围之列。
接下来注意一下双列直插内存模块频率(fDIMM)和总线频率(fBus)会由于内存控制中心(MCH)而限于固定比率。
使用的双核系统中，这些比率最具代表性的是4:5, 1:1, 5:4。一般情况下只会用到其中的一个。高速缓存存储器的体积非常重要。
在这个模型中保留这个参数。内核的数量(Ncores)和内核频率(fcore)也非常重要，保留这两个参数。
高性能计算(HPC)模型
这第二个模型的基本形式在计算机体系研究领域已经存在了很多年。
A普通模式是：
(3) CPI = CPI0 + MPI * PPM
这里的CPI指的是处理器在工作负荷状态下每执行一个指令的周期。CPI0是指内核CPI，MPI I则是指在工作负荷状态下高速缓存存储器每个指令失误的次数(注释：在高性能计算领域，MPI主要用于信息传递界面，在此处主要是指处理器构造惯例)，PPM是指以处理器时钟滴答声为单位对高速缓存存储器每个指令失误的次数的记录。第二和第三个方程式相互吻合。这第一个术语代表的是处理器，第二个术语代表的是内存。
可以直观的看到，假设每项工作下执行的P指令的工作负荷与代表处理器的频率的内核频率(每秒钟处理器运行周期的单位)再与方程式(3)相乘，就得到了方程式(4):
Tnode = (CPIo * P) * (1 / fcore) + (MPI * P) * PPM * (1 / fcore)
在这里要注意(CPIo * P)是以每项工作分配下处理器的运行周期为单位，对微处理器架构上运行的既定工作负荷通常是个恒量。因此把它命名为α。(处理器周期本身无法对时间进行测算，如果乘以内核的频率就可以得到时间的测算标准。因此Tnode在方程式(4)的右边)。
(MPI * P)也是同理。对于既定工作负荷和体系结构来说它也是个恒量，但它主要依赖于高速缓存存储器的体积。我们把它命名为M(MBcache)。而PPM是指访问主存的成本。对于既定的工作负荷来说，通常是个固定的数字C。PPM乘以内存频率和总线频率的比值(fcore / fBus)就从总线周期(bus cycles)转化成了处理器周期。因此PM = C * fcore / fBus。套入M(MBcache)就可以得到：
(5) Tnode = α * (1 / fcore) + M(MBcache) * (1 / fbus)
这个例子说明总线频率(bus frequency)也是个恒量，方程式(5)可以简化为方程式(6)：
(6) Tnode = α * (1 / fcore) + β
在这里Tcore = α * (1 / fcore)，而Tmemory = β(也就是公式2里的术语。我们把这些关键点关联在一起)。
首先在模型2里，公式5和公式6都有坚实的理论基础，因为经分析过它是如何从公式3推理而来(它主要应用于计算机体系理论)。其次，这个模型4个硬件性能参数的3个已经包括其中。还差一个参数就是内核数量(Ncores)。
用直观的方式来说明内核的数量，就是假设把N个内核看做是一个网络频率上运行的一个内核，称之为N*fcore。那么根据公式(6)我们大致可以推算出：
(7) Tcore ~ α / (N*fcore)
Tcore~ ( α / N) * (1 / fcore )
也可以把它写成：
(8) αN = ( α / N)
多核处理器的第一个字母Alpha可能是单核处理器的1/N次。
通过数学推算这几乎是完全可能的。
通常情况下我们是根据系统内核和总线频率(bus frequencies)来衡量计算机系统性能，如公式(5)所阐述的。但是公式(5)的左边是时间单位--这个时间单位指的是一项工作量的完成时间。这样就能更清楚的以时间为单位说明右侧的主系统参数。同时请注意内核的时钟周期τcore(是指每次内核运行周期所需的时间)也等同于(1 / fcore)。总线时钟(bus clock)周期也是同理。
(9) Tnode = αN * τcore + M(MBcache) * τBus
这个公式的转化也给了一个完成时间的模型，那就是2个基本的自变量τcore和τBus呈现出直线性变化。这对使用一个简单的棋盘式对照表对真实系统数据进行分析是有帮助的。
[3]
大家已逐渐认同这一观点，高性能计算机是价格在10万元以上的服务器。之所以称为高性能计算机，主要是它跟微机与低档PC服务器相比而言具有性能、功能方面的优势。高性能计算机也有高、中、低档之分，中档系统市场发展最快。从应用与市场角度来划分，中高档系统可分为两种，




曙光2000

一种叫超级计算机，主要是用于科学工程计算及专门的设计，如Cray T3E；另一种叫超级服务器，可以用来支持计算、事务处理、数据库应用、网络应用与服务，如IBM的SP和国产的曙光2000。
从市场的角度来讲，高性能计算机是高技术、高利润而且市场份额在不断扩大的一个产业。高性能计算机在政府部门、科研等领域的广泛应用，对增强一个国家的科技竞争力有着不可替代的作用。另外，美国和欧洲的经验已经证明，企业使用高性能计算机能够有效地提高生产率。
高性能计算机的发展趋势主要表现在网络化、体系结构主流化、开放和标准化、应用的多样化等方面。网络化的趋势将是高性能计算机最重要的趋势，高性能计算机的主要用途是网络计算环境中的主机。以后越来越多的应用是在网络环境下的应用，会出现数以十亿计的客户端设备，所有重要的数据及应用都会放在高性能服务器上，Client/Server模式会进入到第二代，即服务器聚集的模式，这是一个发展趋势。
网格（Gird）已经成为高性能计算的一个新的研究热点，是非常重要的新兴技术。网络计算环境的应用模式将仍然是Internet/Web，但5～10年后，信息网格模式将逐渐成为主流。在计算网格方面美国大大领先于其他国家。有一种观点认为，美国当前对于网格研究的支持可与其70年代对Internet研究的支持相比，10年后可望普及到国民经济和社会发展的各个领域。网格与Internet/Web的主要不同是一体化，它将分布于全国的计算机、数据、贵重设备、用户、软件和信息组织成一个逻辑整体。各行业可以在此基础上运行各自的应用网格。美国开始了STAR-TAP计划，试图将网格扩展到全世界。
在体系结构上，一个重要的趋势是超级服务器正取代超级计算机而成为高性能计算的主流体系结构技术。高性能计算机市场的低档产品将主要是SMP（Symmetric MultiProcessor，对称多处理机），中档产品是SMP、CC-NUMA（Cache Coherent-Non Uniform Memory Access，支持缓存一致性的非均匀内存访问）和机群，高档产品则将采用SMP或CC-NUMA节点的机群。在2001年左右，将会出现结合了NUMA（COMA和CC-NUMA）和机群体系结构优点的混合式结构，称之为Cluster-NUMA(C-NUMA)系统。可重构、可分区、可配置特性将变得越来越重要。此外还有一种新兴的称为多线程（Multithreading）体系结构将用于超级计算机中，它的代表是Tera公司的MTA系统，一台8 CPU的MTA已经成功地运行在圣地亚哥超级计算机中心。值得注意的是，所有厂家规划的高档系统都是机群，已经有厂家开始研究C-NUMA结构。
美国一直是世界上最重视高性能计算机、投入最多和受益最大的国家，其研究也领先于世界。美国能源部的加速战略计算ASCI计划，目标是构造100万亿次的超级计算机系统、软件和算法，在2004年真实地模拟核爆炸；白宫直属的HECC（High-End Computing and Computations）计划，对高性能计算的关键技术进行研发，并构建高性能基础设施；Petaflops计划开发构造千万亿次级系统的技术；最新的Ultrascale计划目标在2010年研制万万亿次级系统。日本计划将于2002年研制成40万亿次的并行向量机。欧洲的强项则主要体现在高性能计算机的应用方面。
总的来说，国外的高性能计算机应用已经具有相当的规模，在各个领域都有比较成熟的应用实例。在政府部门大量使用高性能计算机，能有效地提高政府对国民经济和社会发展的宏观监控和引导能力，包括打击走私、增强税收、进行金融监控和风险预警、环境和资源的监控和分析等等。
在发明创新领域，壳牌石油公司通过全球内部网和高性能服务器收集员工的创新建议，加以集中处理。其中产生了一种激光探测地下油床的新技术，为该公司发现了3亿桶原油。在设计领域，好利威尔公司和通用电气公司用网络将全球各地设计中心的服务器和贵重设备连于一体，以便于工程师和客户共同设计产品，设计时间可缩短100倍。对很多大型企业来说，采购成本是总成本的重要组成部分。
福特用高性能计算机构造了一个网上集市，通过网络连到它的3万多个供货商。这种网上采购不仅能降低价格，减少采购费用，还能缩短采购时间。福特估计这样做大约能节省80亿美元的采购成本。此外，制造、后勤运输、市场调查等领域也都是高性能计算机大显身手的领域。
高性能计算机能为企业创造的价值是非凡的，国外的企业和用户已经充分地认识到这一点。一个证明是，20世纪90年代中期以来，国外80%以上企业的信息主管在选购机器时考虑高性能计算机，而在20世纪90年代初，这个数字只有15%。
在国内这方面的宣传教育工作还很不够，没有让企业、政府和社会充分认识到高性能计算机的益处，从而导致了一些观念上的误解。以往一提起高性能计算机，人们马上就会联想到用于尖端科学计算的超级计算机。实际上，高性能计算机90%的用途是非科学计算的数据处理、事务处理和信息服务，它早已不是象牙塔里的阳春白雪。随着“网络计算”和“后PC时代”的到来，全世界将有数十亿的客户端设备，它们需要连到数百万台高性能服务器上。高性能计算机将越来越得到产业界的认同，成为重要的生产工具。
此外，人们一直以来还有这样一个认识误区，认为高性能计算机是面向高新产业和服务业的，而传统产业（尤其是制造业）并不需要使用。事实上，高性能计算机能够广泛应用于生物、信息、电子商务、金融、保险等产业，它同时也是传统产业（包括制造业）实现技术改造、提高生产率——“电子生产率”(e-productivity)和竞争力的重要工具。高性能计算已从技术计算（即科学计算和工程计算）扩展到商业应用和网络信息服务领域。的曙光2000-Ⅱ就瞄准了技术计算、商业应用和网络服务这3个领域的应用。
应该说，高性能计算机在国内的研究与应用已取得了一些成功，包括曙光2000超级服务器的推出和正在推广的一些应用领域，如航空航天工业中的数字风洞，可以减少实验次数，缩短研制周期，节约研制费用；利用高性能计算机做气象预报和气候模拟，对厄尔尼诺现象及灾害性天气进行预警，国庆50周年前，国家气象局利用国产高性能计算机，对北京地区进行了集合预报、中尺度预报和短期天气预报，取得了良好的预报结果；此外，在生物工程、生物信息学、船舶设计、汽车设计和碰撞模拟以及三峡工程施工管理和质量控制等领域都有高性能计算机成功应用的实例。
但是总的说来，高性能计算机在国内的应用还比较落后，主要原因在于装备不足、联合和配套措施不力及宣传教育力度不够。首先，国内高性能计算机的装机量明显不足。1997年世界高性能计算机的销售额美国约为220亿美元，中国约为7亿美元。美国的微机销售额约占世界市场的38%，高性能计算机占世界的34%，均高于其GDP所占世界份额（25%左右）。中国的微机销售额约占世界市场的3%，高于中国GDP的份额（2.6%）；但中国高性能计算机销售额所占世界份额仅为1%左右，低于GDP的份额。从另一个角度看，中国的微机市场接近美国的1/10，但中国的高性能计算机市场不到美国的1/30。
装备不足严重影响了高性能计算机应用的开发和人才的培养，这些反过来又影响了高性能计算机的使用和装备。值得庆幸的是，随着网络化和信息化工作的深入，国内社会已开始意识到高性能计算机的重要性。1999年，中国高性能计算机的市场销售额猛增了50%以上。
除了装备不足之外，我认为社会各行业、各层次的合作和配合不力也是阻碍高性能计算机应用发展的重要原因。应用市场的扩展关键要靠联合，在中国高性能计算机领域，系统厂商、应用软件厂商与最终用户和服务商之间并没有结成有效的战略联盟，形成优势互补的局面。我希望看到的是，曙光、联想、浪潮的服务器，运行着东大阿尔派、用友、同创等厂家的软件，在新浪网、8848网上为各行业的用户提供各种服务。国家正在实施一个“国家高性能计算环境”的计划，正朝着这方面努力。
国家863计划主题正在实施一个“国家高性能计算环境”的项目，计划到2000年年底在全国建设10个左右的高性能计算中心，这些中心将通过千兆位网络互连。目标就是尽量让全国用户免费共享全国的计算资源、信息资源和人才资源。这只是一个初期的项目，估计在2000年下半年会规划更大的项目。值得注意的是，已经规划的应用包括生物信息学、数字图书馆、科学数据库、科普数据库、汽车碰撞、船舶设计、石油油藏模拟、数字风洞、气象预报、自然资源考察和远程教育等领域。
2000年5月14～17日，国内将在北京组织一个“亚太地区高性能计算国际会议及展览”，届时全球二十几个国家和地区的代表以及国内外主流的服务器厂商将参加会议，会议计划围绕一些课题做特邀报告：美国工程院院士、Microsoft资深科学家Gordon Bell将讨论“后PC时代：当计算、存储和带宽都免费时，我们面临什么样的挑战？”，自由软件创始人Richard Stallman 将讨论“自由软件运动及GNU/Linux”，俄罗斯科学院院士Boris Babayan将介绍俄罗斯花了6年功夫新近发明的一种电脑芯片，据称它比Intel的Pentium Ⅲ和Itanium快几倍，而且具有安全、防病毒功能。
IBM深度计算研究所所长Pulley Blank将介绍“深蓝、基因蓝以及IBM的深度计算战略”。从会议的内容上我们能够看出，高性能计算的范围已超出了高端科学计算的领域。相信这次会议对国内高性能产业的发展将起到一定的推动作用。
此外，国家还有一个重大基础研究计划（也叫973项目）。高性能计算已经成为科技创新的主要工具，能够促成理论或实验方法不能取得的科学发现和技术创新。973项目中的很多项目（尤其是其中的“高性能软件”和“大规模科学计算”项目）都与高性能计算机有着密切的关系。
[4]
想象一下，你是科研机构里的实验狂人，要进行一个复杂的X射线转化运算或者为下一个实体实验进行电脑仿真模拟。如果使用普通PC，基本无法进行；如果使用一个普通的工作站，至少需要数周的时间；如果使用单位里的服务器集群，得出结果的运算时间并不长，但你需要很长的排队时间，因为它是公用的。但是，如果你拥有一台基于GPU运算的超级计算机，足不出户，只要在自己的桌面上，就可以轻松完成这项复杂工作，而所用的时间，甚至比实验室里的大块头服务器集群还要短。
对于国内用户来说，个人桌面超级运算不再是梦想。在其工作站业务迎来10周年之际，方正科技宣布将在中国市场推出具有超级计算能力的高性能工作站。其最新推出的旗舰机型美仑3400 2800，提供强大图形处理与高性能计算解决方案，采用全新英特尔“至强”处理器，搭载新一代NVIDIA Tesla GPU，能实现高性能的GPU超级运算，从而将工作站变身为桌面型超级计算机，满足专业用户的高性能计算需求。
对于国内用户来说，GPU（图形处理器）并不陌生，但对于GPU计算这一新兴运算方式，可能还不熟悉。简单来说，GPU计算即使用GPU（图形处理器）来执行通用科学与工程计算。目前的CPU最多只集成了4个内核，而GPU已经拥有数以百计的内核，在高密度并行计算方面拥有得天独厚的优势。方正科技推出的高性能计算工作站，使用CPU+GPU的异构计算模型，应用程序的顺序部分在CPU上运行，而计算密集型部分则由GPU来分担。这样，系统计算力得到淋漓尽致的释放，应用程序的运行速度能够提升1-2个数量级。
GPU计算的概念一经提出，就在高性能计算领域掀起了一场前所未有的风暴。在过去4年里，已经有累计1亿颗以上的GPU被三星、摩托罗拉等公司和哈佛、斯坦福等上百所高校研究机构应用于癌症的治疗和科研教学等多种领域。日本最快的超级电脑也采用了GPU计算这项技术。微软的WIN7已经融入GPU运算功能。而下游厂商如惠普、方正、联想等也一直积极紧跟技术潮流，积极研发GPU计算应用产品。NVIDIA的首席执行官黄仁勋曾大胆预言：“2009年是GPU引爆年，CPU+GPU的个人运算时代已经来临。”
方正科技将GPU计算应用带入中国，为国内教育科研院校和机构、各大企业打造了一款桌面型高性能计算工作站。该产品可广泛应用于生物信息及生命科学、流体动力学、大气和海洋建模、空间科学、电子设计自动化、图形成像等众多领域。相对于传统的服务器集群，方正科技推出的GPU超级计算机在性价比、占地空间、功耗等方面的优势是压倒性的。做一个简单的算术：某大学原来用的服务器集群拥有256颗AMD皓龙双核处理器核，构建成本是500万美元，由全校共同来使用；但如果换成4台方正美仑3400 2800高性能计算工作站，性能更优，成本只有1万美元，耗电能减少10倍以上，即使每个研究人员桌面配备一台仍然划算。
作为国内较早涉足工作站业务的民族厂商，方正科技在工作站领域的研发与开拓上已经走过了10个春秋，取得了不俗的成绩。其工作站负责人表示，在10周年这个具有强烈纪念意义的时间点上，推出基于全新计算方式的GPU超级计算机，表明方正科技工作站根植客户应用需求，紧跟技术潮流，不断推陈出新的决心。
中国在高端计算机的研制方面已经取得了较好的成绩，掌握了研制高端计算机的一些关键技术，参与高端计算机研制的单位已经从科研院所发展到企业界，有力地推动了高端计算的发展。随着中国信息化建设的发展，高性能计算的应用需求在深度和广度上都面临蓬勃发展。
高性能计算作为第三大科学方法和第一生产力的地位与作用被广泛认识，并开始走出原来的科研计算向更为广阔的商业计算和信息化服务领域扩展。更多的典型应用在电子政务、石油物探、分子材料研究、金融服务、教育信息化和企业信息化中得以展现。经过十年的发展，中国在高性能计算水平上已跻身世界先进水平。
企业界参与研制
国内做高性能计算的企业中有三家主力厂商，他们是曙光、联想和浪潮。863计划十几年来，曙光始终在研发过程中起着带头作用。高性能市场中，曙光高性能计算机销量已超过1000套，在国内应用是最广泛的。联想进入高性能市场比较晚，但是从其公司运作能力和市场化的能力看，虽然其遇到了一些困难，但是未来的发展潜力巨大。而浪潮以服务器起家，但在高性能方面，原来技术较弱，但是比较专一于高端商用市场，通过与大专院校的合作，发展比较快。
赛迪顾问分析师刘新在接受《中国电子报》记者采访时称，看国内高性能计算的前三名，曙光的整合计算、细分应用是其特点。由于具有长期的技术积淀，深厚的行业背景，鲜明的品牌形象，是国内三大品牌中商业化最成功的企业，但面临国内、国外的双向夹击，发展道路坎坷不平。而联想长期“贸工技”的战略使其可能会缺乏技术的积淀，做惯了PC设备供应和服务，在高性能计算领域显得底气不足，其主要市场策略依然延续PC模式，依靠低价等吸引用户是一大特色。而浪潮给人的感觉是在高性能方面有点缺乏技术实力和远见。
也许有人认为，高性能计算离我们的实际生活还很遥远，但是金融、电信、税务、能源、制造等行业中的很多企事业都已经开始应用高性能计算，而作为普通百姓的衣食住行，我们在刷卡购物、打电话、听天气预报、出门坐车时也已经在享受高性能计算所带来的准确与方便。
通过记者的采访，相关厂商一致认为，高性能计算走向普及已是大势所趋。这主要是由于商品化趋势使得大量生产的商品部件接近了高性能计算机专有部件，标准化趋势使得这些部件之间能够集成在一个系统中。
机群——未来高性能的发展方向
高性能计算机的主流体系结构收缩成了三种，即SM、CC-NUMA、Cluster。在产品上，只有两类产品具有竞争力：一是高性能共享存储系统；二是工业标准机群，包括以IA架构标准服务器为节点的PC机群和以RISC SMP标准服务器为节点的RISC机群。当前，对高性能计算机产业影响最大的就是“工业标准机群”了，这也反映了标准化在信息产业中的巨大杀伤力。工业标准机群采用量产的标准化部件构成高性能计算机系统，极大地提高了性能价格比，从科学计算开始逐渐应用到各个领域。
浪潮北京公司服务器产品经理丁昱对《中国电子报》记者说，事实上，中国机群发展进入了一个瓶颈期，多数稍具技术实力的厂商都可以设计出计算速度上万亿次的高性能计算机。可以说，在充足的资金前提下，设计一套进入全球前十名的高性能机群系统，并非难事。在科学计算方面，唯一的问题因素是资金。浪潮基于弹性部署理念的计算能力、数据通信、输入输出非单极优化的MABS体系结构，为高性能商用服务器系统实现技术突破奠定了理论基础。
曙光公司天潮系列产品经理曹振南告诉《中国电子报》记者，机群的优势主要体现在更高的性能价格比，机群系统已经成为高性能计算机的发展方向，世界上TOP500排行榜的高性能计算机系统绝大多数是机群系统；更高的可扩展性，机群系统可以通过原有预留的扩展接口进行无缝的扩展；更高的可管理性，通常管理一个机群系统要比管理一个小型机系统要简单得多；更高的系统鲁棒性(健壮或强壮)，机群系统都是采用了标准的硬件设备，容易采购，同时也较容易维护，有更多国内厂商支持；对应用系统的更多的支持，机群系统可以支持大量的操作系统并且可以支持多种操作系统，也支持32位和64位的软件系统，在机群系统上运行的软件是小型机系统的成百上千倍。
关键在应用
20世纪90年代以来，中国在高性能计算机的研制方面已经取得了较好的成绩，掌握了研制高性能计算机的一些关键技术，参与高性能计算机研制的单位已经从科研院所发展到企业界，有力地推动了高端计算的发展。中国的高性能计算环境已得到重大改善，总计算能力与发达国家的差距正逐步缩小。
随着曙光、神威、银河、联想、浪潮、同方等一批知名产品的出现，中国成为继美、日之后第三个具备高端计算机系统研制能力的国家，被誉为世界未来高性能计算市场的“第三股力量”。在国家相关部门的不断支持下，一批国产超级计算机相继面世，大量的高性能计算系统进入教育、科研、石油、金融等领域，尤其值得一提的是曙光4000A在全球TOP500中排名进入前十，并成功应用于国家网格主节点之一——上海超级计算中心。
但是，从总体上讲，中国高性能计算应用的研究与开发明显滞后于高性能计算机的发展，应用的并行度普遍在百十量级，应用到更大规模的很少(并非没有需求)。
浪潮丁昱告诉《中国电子报》记者，中国的高性能计算发展最大的障碍是品牌的障碍和应用的障碍。这和中国高性能发展起步较慢有关系。年限比较短，应用的经验比较少。但随着国内高性能计算的快速发展，这方面的缺陷会得到很大改善。但随着越来越多的用户开始采用高性能计算机，应用软件的发展后滞明显严重。另外，一些用户对传统RISC小型机存在使用习惯和品牌偏好，接受Linux机群需要厂商做大量的工作。
曙光曹振南在接受《中国电子报》记者采访时称，中国高端计算应用的研究与开发明显滞后于高端计算机的发展，应用到大规模的很少。高端应用软件的开发和高效并行算法的研究尚不能与高端计算机发展同步，在一定程度上存在为计算机“配”软件的思想。对应用的投入远远不够，应用研发的力量薄弱且分散，缺乏跨学科的综合型人才，从事高端应用软件研发的单位很少，没有良好的、相互交流的组织渠道等。还有就是政府在采购中依然选择国际品牌，缺乏对国产品牌的支持。
联想高性能服务器事业部总经理祝明发则认为，中国高性能计算生存的关键在应用。他谈到IBM、惠普、Sun等公司的高性能计算业务在商业市场的比例为90%，而中国的高性能计算在商业计算市场开拓方面仍存在很大差距。从来看，中国的联想、曙光、浪潮等厂家完全有能力做出运算速度达到40万亿次的超级计算机，但关键就是有没有找到应用需求。比如，在科学计算中独树一帜的向量计算，因为成本高、商用计算能力不强而仅停留在科学计算的狭窄领域。
[5]
提及摩尔定律，作为计算机发展的第一定律一直在引领IT产业的前行。不过随着多核技术的发展和应用，摩尔定律在面临挑战的同时，在某些领域已经被超越。例如在日益普及的高性能计算（HPC）中。那为何摩尔定律会首先在高性能计算领域被超越？这之中又隐含着怎样的产业趋势？
首先从代表全球高性能计算水平和趋势的全球高性能计算TOP500近几年性能发展的趋势看，无论是最大性能（全球排名第一的系统）、还是最小性能（全球排名最后）和平均性能，其发展曲线的速度是基本一致的。但与摩尔定律的发展曲线相比，则明显处于陡势的增长态势。这说明这两年来，高性能计算性能和应用的发展速度已经超越了摩尔定律。熟悉摩尔定律的人都知道，摩尔定律有三种解释。一种是集成电路芯片上所集成的电路的数目，每隔18个月就翻一番；第二种是微处理器的性能每隔18个月提高一倍，而价格下降一半；第三种解释是用一个美元所能买到的电脑性能，每隔18个月翻两番。这三种解释中业内引用最多的是第一种。但具体到高性能计算，笔者更愿意用第二或者第三种来解释。
按理说，随着高性能计算性能的不断提升和系统的日益庞大，高性能计算用户无论在初期的采购搭建系统，还是后期的使用中的成本都会大幅的增加，在经济危机的特殊时期，高性能计算如此大的TCO会导致用户的减少和整体性能的下降才对。但前不久发布的全球高性能计算TOP500证明，增长的势头未减，这除了市场和用户的需求外，更在于处理器厂商采用新的技术，在性能提升的同时，让用户以更低的成本享受到更高、更多的计算性能。从这个意义上看，摩尔定律在被延续的同时也正在被超越，即在高性能计算领域，用户性能/投入比远远大于摩尔定律。当然这主要得益于处理器制程、架构技术、多核技术、节能技术、软件优化和快速部署等。
例如从制程和核数上看，最新的全球高性能计算TOP500排名显示，45纳米已经占据了绝对的主流。而多核也达到了全球TOP500的2/3。从部署的速度看，AMD刚刚发布不久的6核就已经有两套进入TOP500中。而英特尔正式发布的新的Nehalem多核架构的高性能计算系统更有33套（基于这个处理器的系统）进入TOP500，其中有两套在TOP20里。快速的部署给用户带来的是最新技术和性能的获得。
当然对于用户而言，多核并非是关键，重要的是如何充分发挥多核的效能。这就需要相关的平台技术和软件优化。例如在高性能计算领域，业内都听说过“半宽板”这个标准。这个“半宽板”标准其实是英特尔在几年前提出的，半宽的小板在加高计算密度的同时，节约了很多复用的部件，在加强高性能计算的密度同时，配合散热的技术设计，可以提供更多的计算能力同时降低能耗。这就引出了一个新的发展方向，即高性能计算未来发展就是能耗更多被用于计算性能的提高，而不是散热。此外，就是SSD（固态硬盘），它可以在大幅提高高性能计算系统可靠性和I/O性能的同时，还可以降低功耗。而软件优化更是高性能计算中重中之重的部分，编译器、函数库以及MPI库，所有这些可以帮助ISV能够把多核处理器的计算性能充分发挥出来。
由此来看，在高性能计算领域，单纯的处理器已经不能满足市场和用户的需求，它们需要的是高性能计算平台级的解决技术及方案。这也是为什么在全球高性能计算TOP500开始引入能效的主要原因。
说到能效，笔者早就听说在业内有个与摩尔定律同样重要的“基辛格规则”。它是以处理器业界闻名的英特尔首席技术官帕特·基辛格名字命名的。该规则的主旨是今后处理器的发展方向将是研究如何提高处理器能效，并使得计算机用户能够充分利用多任务处理、安全性、可靠性、可管理性和无线计算方面的优势。如果说“摩尔定律”是以追求处理性能为目标，而“基辛格规则”则是追求处理器的能效，这规则至少在高性能计算领域已经得到了验证，而它由此带来的是摩尔定律的被超越，即用户将会在更短的周期，以更低的价格获得更高的能效。
人类从人力推算到高性能计算机，倾注了无数人大量的心血和努力。对于现代天气预报和气象研究工作，高性能计算机则占据了极其重要的位置。
气象工作离不开高性能计算机
随着社会经济的发展，政府、社会和公众对气象预报和服务提出了更高的要求，特别是一些特殊气象保障任务需要预报员提供定点、定时、定量的精细气象预报和服务。而对于现代天气预报而言，为确保其实施的实效性和运行的稳定性，必然要求建立在数值预报基础之上，但数值模式普遍具有计算规模巨大、高精度等特点，于是高性能计算机便成为了现代气象研究的中流砥柱。
数值天气预报水平的高低已成为衡量世界各国气象事业现代化程度的重要标志。美国国家大气研究中心与科罗拉多大学合作，采用了IBM蓝色基因超级计算机来仿真海洋、天气和气候现象，并研究这些现象对农业生产、石油价格变动和全球变暖等问题的影响。日本科学家研制成功了代号为“地球模拟器”的超级计算机，其主要目的就是要提供准确的全球性天气预报，使各个国家和地区更好地防御暴风雪、寒流和酷暑期的到来。
我国是一个幅员辽阔的国家，在气候上呈现多层次、多样性、多变性等特点，尤其是近几年洪涝、干旱等自然灾害比较严重，及时、准确的天气预报逐步受到重视，因此随着地区气象市场的逐步成熟，更高效率的高性能计算机成为了人们关注的对象。作为国产服务器第一品牌的曙光公司，一直以来就非常关注气象领域对高性能计算机的需求。
由于采用了软硬件一体化设计，曙光气象专用机在硬件平台上直接移植了在中尺度数值天气预报领域处于领先地位的NCA MM5系统，这套系统每天自动定时定点进行业务系统预报，从数据导入到气象绘图的整个流程自动完成，不需要人工干预；用户可以随时监控整个系统的运行，大大节约了操作的时间。甚至不需要任何计算机系统知识的培训，用户就可以快速掌握整个预报系统。而且该系统既可以作为业务预报系统，又可以作为气象研究和测试的平台，一机多用，用户可以根据自己的需要进行参数设定和算法调试。系统还提供了数据保存功能，使得用户可以对以往一个月内不满意的预报进行重新计算和分析，最大限度地满足了气象部门准确及时预报的需求。
气象工作离不开高性能计算机，而且每隔三四年就有一次主机的更新，速度还要提高一个数量级。在前10年，我们还只能选择国外品牌高性能计算机，而近几年以曙光为代表的高性能计算机已经明显提升了气象服务的综合实力。曙光机在我国气象领域取得了非常广泛的应用，大大促进了中国气象科技水平的提升，为老百姓的日常出行和众多国家重大工程提供了强有力的保障。从日常天气预报到大型气候研究、从陆地到海洋、从地面水文气象到太空天气等领域，都活跃着曙光高性能计算机的身影。
[6]
天河一号（TH-1）全称“天河一号超级计算机系统”，是一台由中国国防科大和天津滨海新区提供的异构超级计算机，名字“天河”意思为“银河”。天河一号的操作系统为银河麒麟。浪潮集团也参与了这一全球超级计算机的建设工作。
2010年10月，《2010中国高性能计算机TOP100排行榜》正式对外发布，经过技术升级优化后的“天河一号”超级计算机系统，以峰值性能每秒4700万亿次、LINPACK实测值持续性能每秒2507万亿次的性能再登榜首。升级优化后的“天河一号”，配备了14336颗至强X5670处理器、7168块基于Nvidia “Fermi”架构的Tesla M2050计算卡、2048颗国防科技大学研制的飞腾处理器以及5PB存储设备。
天河-1A峰值性能提高了3.89倍，持续性能提高了4.45倍，其运算速度与能效均达到当前国际领先水平。升级后的“天河一号”的实测性能是此前全球最快的超级计算机美洲虎的1.425倍。与诞生于一年前的“天河一号”一期系统相比，二期系统的峰值性能和持续性能分别提高了2.89倍和3.45倍。
其峰值速度为4700TFlops，持续速度为2566TFlops（LINPACK实测值），参加2010年11月世界超级计算机TOP500排名，位列世界第一。
[7]
根据2014年6月份TOP500的排名，中国国防科大开发的天河二号连续第三次位列世界第一，LINPACK实测速度33,862.7TFlop/s，理论峰值54,902.4TFlop/s。
[8]
二叉树是一个连通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一的父结点，和最多2个子结点。然而，没有足够的信息来区分左结点和右结点。如果不考虑连通性，允许图中有多个连通分量，这样的结构叫做森林。
[2-3]
二叉树是递归定义的，其结点有左右子树之分，逻辑上二叉树有五种基本形态：
[3]
(1)空二叉树——如图(a)；
[3]
(2)只有一个根结点的二叉树——如图(b)；
[3]
(3)只有左子树——如图(c)；
[3]
(4)只有右子树——如图(d)；
[3]
(5)完全二叉树——如图(e)。
[3]
注意：尽管二叉树与树有许多相似之处，但二叉树不是树的特殊情形。
[3]
二叉树类型
(1)完全二叉树——若设二叉树的高度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第h层有叶子结点，并且叶子结点都是从左到右依次排布，这就是完全二叉树。
[3]
(2)满二叉树——除了叶结点外每一个结点都有左右子叶且叶子结点都处在最底层的二叉树。
[1]
(3)平衡二叉树——平衡二叉树又被称为AVL树（区别于AVL算法），它是一棵二叉排序树，且具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。
[1]
二叉树辨析
二叉树是树的一种特殊情形，是一种更简单而且应用更加广泛的树。
[3]
树的结点（node）：包含一个数据元素及若干指向子树的分支；
[3]
孩子结点（child node）：结点的子树的根称为该结点的孩子；
[3]
双亲结点：B 结点是A 结点的孩子，则A结点是B 结点的双亲；
[3] 
、
兄弟结点：同一双亲的孩子结点； 堂兄结点：同一层上结点；
[3]
祖先结点: 从根到该结点的所经分支上的所有结点；
[3]
子孙结点：以某结点为根的子树中任一结点都称为该结点的子孙；
[3]
结点层：根结点的层定义为1；根的孩子为第二层结点，依此类推；
[3]
树的深度：树中最大的结点层；
[3]
结点的度：结点子树的个数；
[3]
树的度： 树中最大的结点度；
[3]
叶子结点：也叫终端结点，是度为 0 的结点；
[3]
分枝结点：度不为0的结点；
[3]
有序树：子树有序的树，如：家族树；
[3]
无序树：不考虑子树的顺序；
[3]
(1) 在非空二叉树中，第i层的结点总数不超过



 , i>=1；
[1]
(2) 深度为h的二叉树最多有



 个结点(h>=1)，最少有h个结点；
[1]
(3) 对于任意一棵二叉树，如果其叶结点数为N0，而度数为2的结点总数为N2，则N0=N2+1；
[1]
(4) 具有n个结点的完全二叉树的深度为



 （注：[ ]表示向下取整）；
[3]
(5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：
[1]
若I为结点编号则 如果I>1，则其父结点的编号为I/2；
[1]
如果2*I<=N，则其左孩子（即左子树的根结点）的编号为2*I；若2*I>N，则无左孩子；
[1]
如果2*I+1<=N，则其右孩子的结点编号为2*I+1；若2*I+1>N，则无右孩子；
[3]
(6)给定N个结点，能构成h(N)种不同的二叉树。
[3]
h(N)为卡特兰数的第N项。h(n)=C(2*n，n)/(n+1)。
[1]
(7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和J=I+2i
[1]
二叉树顺序存储方式
typenode=record
data:datatype
l,r:integer;
end;
vartr:array[1..n]ofnode;
二叉树链表存储方式
typebtree=^node；
node=record
data:datatye;
lchild,rchild:btree;
end;
遍历是对树的一种最基本的运算，所谓遍历二叉树，就是按一定的规则和顺序走遍二叉树的所有结点，使每一个结点都被访问一次，而且只被访问一次。由于二叉树是非线性结构，因此，树的遍历实质上是将二叉树的各个结点转换成为一个线性序列来表示。
[2]
设L、D、R分别表示遍历左子树、访问根结点和遍历右子树， 则对一棵二叉树的遍历有三种情况：DLR（称为先根次序遍历），LDR（称为中根次序遍历），LRD （称为后根次序遍历）。
[2]
二叉树先序遍历
首先访问根，再先序遍历左（右）子树，最后先序遍历右（左）子树，C语言代码如下：
[2]
void XXBL(tree *root){
    //DoSomethingwithroot
    if(root->lchild!=NULL)
        XXBL(root->lchild);
    if(root->rchild!=NULL)
        XXBL(root->rchild);
}
二叉树中序遍历
首先中序遍历左（右）子树，再访问根，最后中序遍历右（左）子树，C语言代码如下：
[3]
void ZXBL(tree *root)
{
    if(root->lchild!=NULL)
        ZXBL(root->lchild);
        //Do something with root
    if(root->rchild!=NULL)
        ZXBL(root->rchild);
}
二叉树后序遍历
首先后序遍历左（右）子树，再后序遍历右（左）子树，最后访问根，C语言代码如下：
[3]
void HXBL(tree *root){
    if(root->lchild!=NULL)
        HXBL(root->lchild);
    if(root->rchild!=NULL)
        HXBL(root->rchild);
        //Do something with root
}
二叉树层次遍历
即按照层次访问，通常用队列来做。访问根，访问子女，再访问子女的子女（越往后的层次越低）（两个子女的级别相同）。
[3]
线索二叉树(保留遍历时结点在任一序列的前驱和后继的信息)：若结点有左子树，则其lchild域指示其左孩子，否则令lchild域指示其前驱；若结点有右子树，则其rchild域指示其右孩子，否则令rchild指示其后继。还需在结点结构中增加两个标志域LTag和RTag。
[3] 
LTag=0时，lchild域指示结点的左孩子，LTag=1时，lchild域指示结点的前驱；RTag=0时，rchild域指示结点的右孩子，RTag=1时，rchild域指示结点的后继。以这种结点结构构成的二叉线索链表，链表作为二叉树的存储结构，叫做其中指向结点前驱和后继的指针叫做线索，加上线索的二叉树称为线索二叉树。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。若对二叉树进行中序遍历，则所得的线索二叉树称为中序线索二叉树，线索链表称为为中序线索链表。线索二叉树是一种物理结构。




线索二叉树的存储结构

在中序线索树找结点后继的规律是：若其右标志为1，则右链为线索，指示其后继，否则遍历其右子树时访问的第一个结点（右子树最左下的结点）为其后继；找结点前驱的规律是：若其左标志为1，则左链为线索，指示其前驱，否则遍历左子树时最后访问的一个结点（左子树中最右下的结点）为其前驱。
[1]
在后序线索树中找到结点的后继分三种情况：
[3]
若结点是二叉树的根，则其后继为空；若结点是其双亲的右孩子，或是其双亲的左孩子且其双亲没有右子树，则其后继即为双亲结点；若结点是其双亲的左孩子，且其双亲有右子树，则其后继为双亲右子树上按后序遍历列出的第一个结点。
[3]
范例二叉树：
[3]
A
[3]
B C
[3]
D E
[3]
此树的顺序结构为：ABCDE
[3]
int main()
{
    node* p = newnode;
    node* p = head;
    head = p;
    string str;
    cin >> str;
    creat(p, str, 0)//默认根结点在str下标0的位置
    return 0;
}
//p为树的根结点（已开辟动态内存）,str为二叉树的顺序存储数组ABCD##E或其他顺序存储数组，r当前结点所在顺序存储数组位置
void creat(node* p, string str, int r)
{
    p->data = str[r];
    if (str[r * 2 + 1] == '#' || r * 2 + 1 > str.size() - 1)p->lch = NULL;
    else
    {
        p->lch = newnode;
        creat(p->lch, str, r * 2 + 1);
    }
    if (str[r * 2 + 2] == '#' || r * 2 + 2 > str.size() - 1)p->rch = NULL;
    else
    {
        p->rch = newnode;
        creat(p->rch, str, r * 2 + 2);
    }
}
AOE网有向无环图
一个无环的有向图称作有向无环图(directed acyclic graph)，简称DAG图。假设以有向图表示一个工程的施工图或程序的数据流图，则图中不允许出现回路，如果出现回路，说明了某项活动以它自己为先决条件，显然是荒谬的，工程将无法进行。
[1]
AOE网拓扑排序
拓扑排序是一种对非线性结构的有向图进行线性化的重要手段。在给定的有向图G中，若顶点序列Vi1，Vi2，Vi3，....,Vin，。满足下列条件：若在有向图G中从顶点Vi，到顶点Vj有一条路径，则在序列中顶点Vi必在顶点Vj之前，便称这个序列为一个拓扑序列。求一个有向图拓扑序列的过程称为拓扑排序。　　拓扑排序的方法如下：　　(1)从图中选择一个入度为O的顶点并输出；　　(2)从图中删掉该顶点及其所有以该顶点为弧尾的弧。　　反复执行这两个步骤，直到所有的顶点都被输出，输出的序列就是这个无环有向图的拓扑序列。
如果在带权有向图中，用顶点表示事件，用有向边表示活动，边上的权值表示活动的开销，则此带权有向图称为边活动网(activity on edge network)，简称AOE网。AOE网是一个有向无环图。AOE网是用来描述由许多交叉活动组成的复杂计划和工程的方法，比如某工程的AOE网。
在工程中用边表示活动，边上的权表示完成这项活动所需要的时间，顶点表示某项活动的开始，顶点1称为源点（或起点），表示整个工程开始，顶点2称为汇点（或终点），表示整个工程的结束。用AOE网来估算工程的最短工期（完成整个工程至少需要多少时间）以及哪些活动是影响工程进展的关键。
[1] 





AOE网
AOE网几个术语
路径长度：路径上各活动持续时间的总和（即路径上所有权之和）。　　完成工程的最短时间：从工程开始点（源点）到完成点（汇点）的最长路径称为完成工程的最短时间。
关键路径：路径长度最长的路径称为关键路径。
（1）只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。
（2）只有在进入某点的各有向边所代表的活动都已结束，该顶点所代表的时事件才能发生。
关键路径（临界路径）：在AOE网络中从源点到汇点（结束顶点）的最长路径。关键路径上的活动为关键活动。
[2]
用关键字标识一个数据元素，查找时根据给定的某个值，在表中确定一个关键字的值等于给定值的记录或数据元素。在计算机中进行查找的方法是根据表中的记录的组织结构确定的。　　顺序查找也称为线形查找，从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。　　二分查找要求线形表中的结点按关键字值升序或降序排列，用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。　　分块查找也称为索引查找，把线形分成若干块，在每一块中的数据元素的存储顺序是任意的，但要求块与块之间须按关键字值的大小有序排列，还要建立一个按关键字值递增顺序排列的索引表，索引表中的一项对应线形表中的一块，索引项包括两个内容：① 键域存放相应块的最大关键字；② 链域存放指向本块第一个结点的指针。分块查找分两步进行，先确定待查找的结点属于哪一块，然后在块内查找结点。　　哈希表查找是通过对记录的关键字值进行运算，直接求出结点的地址，是关键字到地址的直接转换方法，不用反复比较。假设f包含n个结点，Ri为其中某个结点（1≤i≤n），keyi是其关键字值，在keyi与Ri的地址之间建立某种函数关系，可以通过这个函数把关键字值转换成相应结点的地址，有：addr(Ri)=H(keyi)，addr(Ri)为哈希函数。
顺序查找过程：从表中的最后一个记录开始，逐个进行记录的关键字与给定值进行比较，若某个记录的关键字与给定值相等，则查找成功，找到所查的记录；反之，若直到第一个记录，其关键字和给定值比较都不相等，则表明表中没有所查的记录，查找失败。　　算法描述为　　int Search(int d,int a[],int n)　　{　　/*在数组a[]中查找等于D元素，若找到，则函数返回d在数组中的位置，否则为0。其中n为数组长度*/　　int i ；　　/*从后往前查找*/　　for(i=n-1;a!=d;--i)　　return i ;　　/*如果找不到，则i为0*/　　}
二分查找又称折半查找，它是一种效率较高的查找方法。
【二分查找要求】：1.必须采用顺序存储结构2.必须按关键字大小有序排列。
【优缺点】折半查找法的优点是比较次数少，查找速度快，平均性能好;其缺点是要求待查表为有序表，且插入删除困难。因此，折半查找方法适用于不经常变动而查找频繁的有序列表。　　【算法思想】首先，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。　　重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。　　【算法复杂度】假设其数组长度为n，其算法复杂度为o（log（n））
下面提供一段二分查找实现的伪代码:
BinarySearch(max,min,des)
mid-des then　　max=mid-1　　else　　min=mid+1　　return max
折半查找法也称为二分查找法，它充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(log n)完成搜索任务。它的基本思想是，将n个元素分成个数大致相同的两半，取a[n/2]与欲查找的x作比较，如果x=a[n/2]则找到x，算法终止。如 果xa[n/2]，则我们只要在数组a的右 半部继续搜索x。
分块查找又称索引顺序查找，它是顺序查找的一种改进方法。　　方法描述：将n个数据元素"按块有序"划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须"按块有序"；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……。　　操作步骤：　　step1 先选取各块中的最大关键字构成一个索引表；　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。
1 基本原理
我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素"分类"，然后将这个元素存储在相应"类"所对应的地方。
但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了"冲突"，换句话说，就是把不同的元素分在了相同的"类"之中。后面我们将看到一种解决"冲突"的简便做法。
总的来说，"直接定址"与"解决冲突"是哈希表的两大特点。
2 函数构造
构造函数的常用方法（下面为了叙述简洁，设 h(k) 表示关键字为 k 的元素所对应的函数值）：
a) 除余法：
选择一个适当的正整数 p ，令 h(k ) = k mod p　　这里， p 如果选取的是比较大的素数，效果比较好。而且此法非常容易实现，因此是最常用的方法。
b) 数字选择法：
如果关键字的位数比较多，超过长整型范围而无法直接运算，可以选择其中数字分布比较均匀的若干位，所组成的新的值作为关键字或者直接作为函数值。
3冲突处理
线性重新散列技术易于实现且可以较好的达到目的。令数组元素个数为 S ，则当 h(k) 已经存储了元素的时候，依次探查 (h(k)+i) mod S , i=1,2,3…… ，直到找到空的存储单元为止（或者从头到尾扫描一圈仍未发现空单元，这就是哈希表已经满了，发生了错误。当然这是可以通过扩大数组范围避免的）。
4 支持运算
哈希表支持的运算主要有：初始化(makenull)、哈希函数值的运算(h(x))、插入元素(insert)、查找元素(member)。　　设插入的元素的关键字为 x ，A 为存储的数组。　　初始化比较容易，例如　　const empty=maxlongint; // 用非常大的整数代表这个位置没有存储元素　　p=9997; // 表的大小　　procedure makenull;　　var i:integer;　　begin　　for i:=0 to p-1 do　　A:=empty;　　End;
哈希函数值的运算根据函数的不同而变化，例如除余法的一个例子：　　function h(x:longint):Integer;　　begin　　h:= x mod p;　　end;
我们注意到，插入和查找首先都需要对这个元素定位，即如果这个元素若存在，它应该存储在什么位置，因此加入一个定位的函数 locate　　function locate(x:longint):integer;　　var orig,i:integer;　　begin　　orig:=h(x);　　i:=0;　　while (ix)and(A[(orig+i)mod S]empty) do　　inc(i);　　//当这个循环停下来时，要么找到一个空的存储单元，要么找到这个元　　//素存储的单元，要么表已经满了　　locate:=(orig+i) mod S;　　end;　　插入元素　　procedure insert(x:longint);　　var posi:integer;　　begin　　posi:=locate(x); //定位函数的返回值　　if A[posi]=empty then A[posi]:=x　　else error; //error 即为发生了错误，当然这是可以避免的　　end;
查找元素是否已经在表中　　procedure member(x:longint):boolean;　　var posi:integer;　　begin　　posi:=locate(x);　　if A[posi]=x then member:=true　　else member:=false;　　end;
权图，自2004年开始担任某著名酒类媒体高层管理人员。先后服务茅台、五粮液、剑南春、洋河等中国主流白酒企业，为之提供渠道建设、市场推广等服务，拥有宽阔的白酒视野、深刻的产业理解和丰富的市场推广经验和案例。
[3]
2008年权图提前洞察到酱酒的长期大势和战略机会，创办左右脑策略咨询机构和贵隆酒道文化传播机构，开始转型为酱香型白酒的品类研究、策略咨询、酒道文化传播等工作并先后为天士力（600535）、湖北宜化（000422）、茅台股份（600519）、华昱投资等知名集团企业和上市公司提供策略顾问。常年和贵州茅台集团、国台酒业集团、贵州金沙酒业集团、贵州钓鱼台国宾酒业、贵州酒中酒集团、贵州小糊涂仙酒业、贵州夜郎古酒业等主流酱酒企业和品牌保持战略合作和咨询服务。
[4]
1、创办有“左右脑策略咨询机构”，主要侧重于中国酱酒产业研究、战略咨询、市场策略咨询、品牌策略咨询、营销咨询、产业链整合及投资咨询；
2、创办的有“贵隆酒道文化传播机构”，主要侧重于中国白酒酒道文化传播和培训、酱酒品类研究、酱酒产区研究、酱酒酒道文化研究、酱酒及酒道专业书籍出版；
3、创办有“贵隆酱香酒道馆”，主要侧重于中国陈年白酒及陈年茅台酒的收藏、展示；该馆收藏有各个时期陈年中国名酒、陈年茅台酒近万瓶。
[3]
4、创办有“贵隆优选酒库”，在茅台镇核心产区自建“贵隆优选酒库”，主要侧重于高品质酱香基酒的定期封藏、投资及交易；
5、创办了有“权图酱酒工作室”，该工作室签约具有白酒省级评委、国家级品酒师资质、具备一线丰富勾酒经验的专业勾酒师、品酒师20余位，主要侧重于酱香型白酒的品质研究、酒体设计和高端个性化酒体研发。
[3]
权图作为国内酱酒研究专家，对中国酱酒产业及市场的发展有以下观点和认识：
一、基于高端品质的支撑、国酒茅台的引领、众多酱酒品牌的共同努力，未来十年，酱酒会是中国白酒中唯一呈快速上升的白酒品类，酱酒产能有望占到中国白酒产能的5%，销售收入有望占据20%以上，利润有望突破三分之一。
[3]
二、酱香型白酒的春天已经来临，这不容质疑。近5年来，酱香型白酒的平均增速达到了32%，是中国白酒5年平均增速的两倍多。
三、中国酱香型白酒春天的来临已经成为事实，酱香型白酒目前以2.5%的产能已经实现了中国白酒15%以上的销量和30%以上的利润。
四、过去10年中国经济保持了较快增长，中国白酒也实现了快速发展。未来10年中国经济将迎来更加复杂的局面和更大的挑战
五、近两年，酱香型白酒发展呈上升趋势，作为国内著名的酱酒研究专家，看好酱香型白酒这几年的发展和未来酱香型白酒的发展趋势。

函数指针的声明方法为：
返回值类型 ( * 指针变量名) ([形参列表]);
注1：“返回值类型”说明函数的返回类型，“(指针变量名 )”中的括号不能省，括号改变了运算符的优先级。若省略整体则成为一个函数说明，说明了一个返回的数据类型是指针的函数，后面的“形参列表”表示指针变量指向的函数所带的参数列表。例如：
int func(int x); /* 声明一个函数 */
int (*f) (int x); /* 声明一个函数指针 */
f=func; /* 将func函数的首地址赋给指针f */
或者使用下面的方法将函数地址赋给函数指针：
f = &func;
赋值时函数func不带括号，也不带参数，由于func代表函数的首地址，因此经过赋值以后，指针f就指向函数func(x)的代码的首地址。
注2：函数括号中的形参可有可无，视情况而定。
下面的程序说明了函数指针调用函数的方法：
例一、
#include<stdio.h>
int max(int x,int y){return (x>y? x:y);}
int main()
{
    int (*ptr)(int, int);
    int a, b, c;
    ptr = max;
    scanf("%d%d", &a, &b);
    c = (*ptr)(a,b);
    printf("a=%d, b=%d, max=%d", a, b, c);
    return 0;
}
ptr是指向函数的指针变量，所以可把函数max()赋给ptr作为ptr的值，即把max()的入口地址赋给ptr,以后就可以用ptr来调用该函数，实际上ptr和max都指向同一个入口地址，不同就是ptr是一个指针变量，不像函数名称那样是死的，它可以指向任何函数，就看你想怎么做了。在程序中把哪个函数的地址赋给它，它就指向哪个函数。而后用指针变量调用它，因此可以先后指向不同的函数。不过注意，指向函数的指针变量没有++和--运算，用时要小心。
不过，在某些编译器中这是不能通过的。这个例子的补充如下。
应该是这样的：
1.定义函数指针类型：
typedef int (*fun_ptr)(int,int);
2.声明变量，赋值：
fun_ptr max_func=max;
也就是说，赋给函数指针的函数应该和函数指针所指的函数原型是一致的。
例二、
#include<stdio.h>
void FileFunc()
{
printf("FileFunc\n");
}
void EditFunc()
{
printf("EditFunc\n");
}
void main()
{
typedef void(*funcp)();
funcp pfun=FileFunc;
pfun();
pfun=EditFunc;
pfun();
}
指针函数和函数指针的区别：
1,这两个概念都是简称，指针函数是指返回值是指针的函数，即本质是一个函数。我们知道函数都有返回类型（如果不返回值，则为无值型），只不过指针函数返回类型是某一类型的指针。
其定义格式如下所示：
返回类型标识符*函数名称（形式参数表）
{函数体}
返回类型可以是任何基本类型和复合类型。返回指针的函数的用途十分广泛。事实上，每一个函数，即使它不带有返回某种类型的指针，它本身都有一个入口地址，该地址相当于一个指针。比如函数返回一个整型值，实际上也相当于返回一个指针变量的值，不过这时的变量是函数本身而已，而整个函数相当于一个“变量”。例如下面一个返回指针函数的例子：
//指针函数是指返回值是指针的函数，即本质是一个函数：
#include<iostream>
using namespace std;
int main()
{
float*find(float(*p)[4],int m);//查询序号为m的学生的四门课程的成绩
float score[][4]={{50,51,52,55},{70,70,40,80},{77,99,88,67}};//定义成绩数组，第一维可以为变量
float*pf=NULL;//定义一个指针时一定要初始化
int i,m;
cout<<"请输入您想查询的学生的序号:";
cin>>m;
pf=find(score,m);//返回为一维数组指针，指向一个学生成绩
for(i=0;i<4;i++)
cout<<*(pf+i)<<"";
cout<<endl;
return 0;
}
float *find(float(*p)[4],int m)
{
float *pf=NULL;
pf=*(p+m);//p是指向二维数组的指针，加*取一维数组的指针
return pf;
}
学生学号从0号算起，函数find()被定义为指针函数，其形参pointer是指针指向包含4个元素的一维数组的指针变量。pf是一个指针变量，它指向浮点型变量。main()函数中调用find()函数，将score数组的首地址传给pointer.
函数指针定义
关于函数指针数组的定义方法，有两种：一种是标准的方法；一种是蒙骗法。
第一种，标准方法：
{
分析：函数指针数组是一个其元素是函数指针的数组。那么也就是说，此数据结构是一个数组，且其元素是一个指向函数入口地址的指针。
根据分析：首先说明是一个数组：数组名[]
其次，要说明其元素的数据类型指针:*数组名[].
再次，要明确这每一个数组元素是指向函数入口地址的指针：函数返回值类型 (*数组名[])().请注意，这里为什么要把“*数组名[]”用括号扩起来呢？因为圆括号和数组说明符的优先级是等同的，如果不用圆括号把指针数组说明表达式扩起来，根据圆括号和方括号的结合方向，那么 *数组名[]() 说明的是什么呢？是元素返回值类型为指针的函数数组。有这样的函数数组吗？不知道。所以必须括起来，以保证数组的每一个元素是指针。
}
第二种，蒙骗法：
尽管函数不是变量，但它在内存中仍有其物理地址，该地址能够赋给指针变量。获取函数地址的方法是：用不带有括号和参数的函数名得到。
函数名相当于一个指向其函数入口指针常量。 那么既然函数名是一个指针常量，那么就可以对其进行一些相应的处理，如强制类型转换。
那么我们就可以把这个地址放在一个整形指针数组中，然后作为函数指针调用即可。
完整例子：
#include <stdio.h>

int add1(int a1,int b1);
int add2(int a2,int b2);

int main(void)
{
    int numa1 = 1, numb1 = 2;
    int numa2 = 2, numb2 = 3;
    int(*op[2])(int a,int b);
    
    op[0] = add1;
    op[1] = add2;
    
    printf("%d%d\n", op[0](numa1, numb1), op[1](numa2, numb2));
}

int add1(int a1,int b1)
{
    return a1 + b1;
}

int add2(int a2,int b2)
{
    return a2 + b2;
}
函数指针赋值
为函数指针数组赋值有两种方式：静态定义和动态赋值。
1. 静态定义
在定义函数指针数组的时候，已经确定了每个成员所对应的函数。例如：
void(*Array[])(void)={Stop,Run,Jump};
从根本上讲函数指针数组依然是数组，所以和数组的定义类似，由于是静态赋值，[ ]里面的数字可以
省略。这个函数指针数组的成员有三个。
Array[1]();//执行Run函数
2. 动态赋值
也可以先定义一个函数指针数组，在需要的时候为其赋值。为了还原其本来面目，我们先对这个执行特定类型的函数指针进行类型重定义，然后再用这个新数据类型来定义数组。如下：
typedef void(*Funcint)(void);//此类型的函数指针指向的是无参、无返回值的函数。
 Funcint Array[32];//定义一个函数指针数组，其每个成员为Funcint类型的函数指针
    Array[10]=INT_TIMER0;//为其赋值
    Array[10]();//调用函数指针数组的第11个成员指向的函数
在数据元素理论研究中，下面的术语是很重要的，理解好这些术语是理解数据元素的基础。
(1)数据元素(Data Element)：是数据的基本单位，由数据项组成。在不同的条件下,数据元素又可称为元素、结点、顶点、记录等。数据元素是用一组属性描述定义、标识、表示和允许值的一个数据单元。
(2)数据元值/元数据（Data Element Value）:数据元能许值集合中的一个值。
(3)数据项：数据项是具有独立含义的最小标识单位，是数据元的一个具体值，是数据记录中最基本的、不可分的有名数据单位。
(4)同义名称: 与给定名称有区别但表示相同的数据元概念。
(5)限定词：帮助定度和呈递唯一性概念的术语。
(6)域：一种属性的可能数据值的集合。
(7)域名：将数据元的值域及度量单位利用一个统一的名称来表示。
(8)对象类：对象集，现实世界中的想法、抽象概念或事物集合，有清楚边界和含义，并且特性和其行为遵循同样的规则面能够加以标识。
(9)对象：可以想象或感觉的世界的任一部分。
(10)特性：对象类的所有个体所共有的某种性质。
(11)表示：值域、数据类型的组合，必要时也包括度量单位或字符集。
(12)对象类词：数据元名称的成分，用于表示其所属的对象类。
(13)特性类词：数据元名称的一个成分，用于表述对象类的特性，（数据元名称的一个成分，表述数据元所属类别）。
(14)表示类词：数据元名称的成分，用于描述数据元的表示形式。
(15)数据模型：以反信息结构的某种方式对数据组织的某种描述。
数据元由对象类、特性和表示三部分组成，其中对象类用于收集和存储数据的事物，例如，人、井、岩芯、管线、储罐都是对象类等；特性是用来区别和描述对象的，例如，颜色、性别、年龄、收入、地址、价格等均为特性；数据的表示部分中最为重要的方面是值域，值域是数据元允许(或有效)值的集合。对于值域，数据元中存在两种类型的值域，一种是所谓取值是固定的，即取值是可枚举的，例如，人眼睛颜色这个数据元，其取值可能包括：Brown、Gray、Green、Hazel、Blue，另一种是概括的，即数据元取值是有定义域约束的，其取值可能是有限的，但是无法列出全部值，例如人的年龄，其取值范围可能是1-200，并且每位要求是十进制表示。
数据元素本身也是一个事物，既然是事物那么就需要属性来描述这一事物，通常我们也将描述属性称为描述数据元素的元数据。
信息标准化实质是信息代码化的过程，须知，信息分类与编码在整个企业信息标准化中占有基础的不可替代的地位。因此如何对企业的各种信息进行有效的分类，并对其进行编码这是信息化过程中一个非常重要的过程。其实数据元素与信息分类及编码有着密不可分的关系。
数据元素理论属于信息标准化的基础理论，即是数据规范化理论基础。数据元分析在信息分类、数据的集成参考模型、数据模型优化设计、数据元字典以及制订数据交换标准等方面得到应用。
袁满，高雪等.中国石油数据元设计指南(企业标准)[M].北京：石油工业出版社，2005
[1]
对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。

这种加上了线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树(Threaded BinaryTree)。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。
注意：线索链表解决了无法直接找到该结点在某种遍历序列中的前驱和后继结点的问题，解决了二叉链表找左、右孩子困难的问题。
二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继（第一个结点无前驱，最后一个结点无后继）。对于二叉树的一个结点，查找其左右子女是方便的，其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。
线索二叉树优势
(1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
(2)任意一个结点都能直接找到它的前驱和后继结点。
[2]
线索二叉树不足
(1)结点的插入和删除麻烦，且速度也较慢。
(2)线索子树不能共用。
[2]
线索二叉树中的线索能记录每个结点前驱和后继信息。为了区别线索指针和孩子指针，在每个结点中设置两个标志ltag和rtag。
当tag和rtag为0时，leftChild和rightChild分别是指向左孩子和右孩子的指针；否则，leftChild是指向结点前驱的线索(pre)，rightChild是指向结点的后继线索(suc)。由于标志只占用一个二进位，每个结点所需要的存储空间节省很多。
[3]
现将二叉树的结点结构重新定义如下：
lchild
ltag
data
rtag
rchild
其中：ltag=0 时lchild指向左儿子；ltag=1 时lchild指向前驱；rtag=0 时rchild指向右儿子；rtag=1 时rchild指向后继。
建立线索二叉树，或者说对二叉树线索化，实质上就是遍历一棵二叉树。在遍历过程中，访问结点的操作是检查当前的左，右指针域是否为空，将它们改为指向前驱结点或后续结点的线索。为实现这一过程，设指针pre始终指向刚刚访问的结点，即若指针p指向当前结点，则pre指向它的前驱，以便设线索。
另外，在对一颗二叉树加线索时，必须首先申请一个头结点，建立头结点与二叉树的根结点的指向关系，对二叉树线索化后，还需建立最后一个结点与头结点之间的线索。
下面是建立中序二叉树的递归算法，其中pre为全局变量。
void InThreading(BiThrTree*p);//预先声明
BiThrNodeType*pre;
BiThrTree*InOrderThr(BiThrTree*T)
{/*中序遍历二叉树T，并将其中序线索化，pre为全局变量*/
BiThrTree*head;//线索二叉树的头结点，指向根结点
head=(BitThrNodeType*)malloc（sizeof（BitThrNodeType））;/*设申请头结点成功*/
head->ltag=0;head->rtag=1;/*建立头结点*/
head->rchild=head;/*右指针回指*/
if(!T)
head->lchild=head;/*若二叉树为空，则左指针回指*/
else
{
head->lchild=T;pre=head;
InThreading(T);/*中序遍历进行中序线索化*/
pre->rchild=head;
pre->rtag=1;/*最后一个结点线索化*/
head->rchild=pre;
}
returnhead;
}
voidInThreading(BiThrTree*p)
{/*通过中序遍历进行中序线索化*/
if(p)
{
InThreading(p->lchild);/*左子树线索化，递归*/
if(p->lchild==NULL)/*前驱线索*/
{
　p->ltag=1;
p->lchild=pre;
}
else
p->ltag=0;
if(p->rchild==NULL)
p->rtag=1;/*后驱线索*/
else
p->rtag=0;
if(pre!=NULL&&pre->rtag==1)
pre->rchild=p;
pre=p;
InThreading(p->rchild);/*右子树线索化*/
}
}
进行中序线索化的算法：
bithptr*pre=NULL;/*全程变量*/
voidINTHREAD(bithptr*p)
{
if(p!=NULL)
{
if(p->ltag==0)
INTHREAD(p->lchild);/*左子树线索化*/
if(p->lchild==NULL)
{
p->ltag=1;
p->lchild=pre;
}
if(p->rchild==NULL)
p->rtag=1;
if(pre!=NULL&&pre->rtag==1)
pre->rchild=p;
pre=p;/*前驱指向当前结点*/
if(p->rtag==0)
INTHREAD(p->rchild);/*右子树线索化*/
}
}
线索二叉树查找前驱和后继：
（1）中序线索二叉树：若结点的ltag=1，lchild指向其前驱；否则，该结点的前驱是以该结点为根的左子树上按中序遍历的最后一个结点。若rtag=1，rchild指向其后继；否则，该结点的后继是以该结点为根的右子树上按中序遍历的第一个结点。
求后继的算法如下：
bithptr*INORDERNEXT(bithptr*p)
{
if(p->rtag==1)
return(p->rchild);
else
{
q=p->rchild;/*找右子树最先访问的结点*/
while(q->ltag==0)
q=q->lchild;
return(q);
}
}
求前驱的算法如下：
bithptr*INORDERNEXT(bithptr*p)
{
if(p->ltag==1)
return(p->lchild);
else
{
q=p->lchild;/*找左子树最后访问的结点*/
while(q->rtag==0)
q=q->rchild;
return(q);
}
}
（2） 后序线索二叉树：
在后序线索二叉树中查找结点*p的前驱：若结点*p无左子树，则p->lchild指向其前驱；否则，若结点*p有左子树，当其右子树为空时，其左子树的根（即p->lrchild）为其后序前驱。当其右子树非空时，其右子树的根（即p->rchild）为其后序前驱。
在后序线索二叉树中查找结点*p的后继：若结点*p为根，则无后继；若结点*p为其双亲的右孩子，则其后继为其双亲；若结点*p为其双亲的左孩子，且双亲无右子女，则其后继为其双亲；若结点*p为其双亲的左孩子，且双亲有右子女，则结点*p的后继是其双亲的右子树中按后序遍历的第一个结点。所以，求后序线索二叉树中结点的后继要知道其双亲的信息，要使用栈，所以说后序线索二叉树是不完善的。
（3）先序线索二叉树：
在先序线索二叉树中查找结点的后继较容易，而查找前驱要知道其双亲的信息，要使用栈，所以说先序线索二叉树也是不完善的。
[4]
所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。这种新序列遵循着一定的规则，体现出一定的规律，因此，经处理后的数据便于筛选和计算，大大提高了计算效率。对于排序，我们首先要求其具有一定的稳定性，即当两个相同的元素同时出现于某个序列之中，则经过一定的排序算法之后，两者在排序前后的相对位置不发生变化。换言之，即便是两个完全相同的元素，它们在排序过程中也是各有区别的，不允许混淆不清。
[1]
排序(Sorting) 是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个关键字有序的序列。
排序就是把集合中的元素按照一定的次序排序在一起。一般来说有升序排列和降序排列2种排序，在算法中有8中基本排序：
(1)冒泡排序；
(2)选择排序；
(3)插入排序；
(4)希尔排序；
(5)归并排序；
(6)快速排序；
(7)基数排序；
(8)堆排序；
(9)计数排序；
(10)桶排序。
稳定性是一个特别重要的评估标准。稳定的算法在排序的过程中不会改变元素彼此的位置的相对次序，反之不稳定的排序算法经常会改变这个次序，这是我们不愿意看到的。我们在使用排序算法或者选择排序算法时，更希望这个次序不会改变，更加稳定，所以排序算法的稳定性，是一个特别重要的参数衡量指标依据。就如同空间复杂度和时间复杂度一样，有时候甚至比时间复杂度、空间复杂度更重要一些。所以往往评价一个排序算法的好坏往往可以从下边几个方面入手：
（1）时间复杂度：即从序列的初始状态到经过排序算法的变换移位等操作变到最终排序好的结果状态的过程所花费的时间度量。
（2）空间复杂度：就是从序列的初始状态经过排序移位变换的过程一直到最终的状态所花费的空间开销。
（3）使用场景：排序算法有很多，不同种类的排序算法适合不同种类的情景，可能有时候需要节省空间对时间要求没那么多，反之，有时候则是希望多考虑一些时间，对空间要求没那么高，总之一般都会必须从某一方面做出抉择。
（4）稳定性：稳定性是不管考虑时间和空间必须要考虑的问题，往往也是非常重要的影响选择的因素。
[2]
排序算法插入排序
插入排序算法是基于某序列已经有序排列的情况下，通过一次插入一个元素的方式按照原有排序方式增加元素。这种比较是从该有序序列的最末端开始执行，即要插入序列中的元素最先和有序序列中最大的元素比较，若其大于该最大元素，则可直接插入最大元素的后面即可，否则再向前一位比较查找直至找到应该插入的位置为止。插入排序的基本思想是，每次将1个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，寻找最适当的位置，直至全部记录插入完毕。执行过程中，若遇到和插入元素相等的位置，则将要插人的元素放在该相等元素的后面，因此插入该元素后并未改变原序列的前后顺序。我们认为插入排序也是一种稳定的排序方法。插入排序分直接插入排序、折半插入排序和希尔排序3类。
[1]
排序算法冒泡排序
冒泡排序算法是把较小的元素往前调或者把较大的元素往后调。这种方法主要是通过对相邻两个元素进行大小的比较，根据比较结果和算法规则对该二元素的位置进行交换，这样逐个依次进行比较和交换，就能达到排序目的。冒泡排序的基本思想是，首先将第1个和第2个记录的关键字比较大小，如果是逆序的，就将这两个记录进行交换，再对第2个和第3个记录的关键字进行比较，依次类推，重复进行上述计算，直至完成第(n一1)个和第n个记录的关键字之间的比较，此后，再按照上述过程进行第2次、第3次排序，直至整个序列有序为止。排序过程中要特别注意的是，当相邻两个元素大小一致时，这一步操作就不需要交换位置，因此也说明冒泡排序是一种严格的稳定排序算法，它不改变序列中相同元素之间的相对位置关系。
[1]
排序算法选择排序
选择排序算法的基本思路是为每一个位置选择当前最小的元素。选择排序的基本思想是，基于直接选择排序和堆排序这两种基本的简单排序方法。首先从第1个位置开始对全部元素进行选择，选出全部元素中最小的给该位置，再对第2个位置进行选择，在剩余元素中选择最小的给该位置即可；以此类推，重复进行“最小元素”的选择，直至完成第(n-1)个位置的元素选择，则第n个位置就只剩唯一的最大元素，此时不需再进行选择。使用这种排序时，要注意其中一个不同于冒泡法的细节。举例说明：序列58539．我们知道第一遍选择第1个元素“5”会和元素“3”交换，那么原序列中的两个相同元素“5”之间的前后相对顺序就发生了改变。因此，我们说选择排序不是稳定的排序算法，它在计算过程中会破坏稳定性。
[1]
排序算法快速排序
快速排序的基本思想是:通过一趟排序算法把所需要排序的序列的元素分割成两大块，其中，一部分的元素都要小于或等于另外一部分的序列元素，然后仍根据该种方法对划分后的这两块序列的元素分别再次实行快速排序算法，排序实现的整个过程可以是递归的来进行调用，最终能够实现将所需排序的无序序列元素变为一个有序的序列。
[3]
排序算法归并排序
归并排序算法就是把序列递归划分成为一个个短序列，以其中只有1个元素的直接序列或者只有2个元素的序列作为短序列的递归出口，再将全部有序的短序列按照一定的规则进行排序为长序列。归并排序融合了分治策略，即将含有n个记录的初始序列中的每个记录均视为长度为1的子序列，再将这n个子序列两两合并得到n/2个长度为2(当凡为奇数时会出现长度为l的情况)的有序子序列；将上述步骤重复操作，直至得到1个长度为n的有序长序列。需要注意的是，在进行元素比较和交换时，若两个元素大小相等则不必刻意交换位置，因此该算法不会破坏序列的稳定性，即归并排序也是稳定的排序算法。
[1]
排序算法冒泡排序
#include <stdio.h>
#include <stdlib.h>
int main() {
    int a[]= {12,4,132,55,46,232,789,1,0,98,523,666};//随机数组
    int n = sizeof(a)/sizeof(a[0]);//获取数组大小
    int i,j,k;
//比较相邻的两个数据，如果第二个数小，就交换位置。从后向前两两比较，一直到比较最前两个数据。
        for(i = 1; i < n; i ++) {
            for(j = 0; j < n-1; j ++) {
                if(a[j] > a[j+1]) {//从小到大排序
                    k = a[j];
                    a[j] = a[j+1];
                    a[j+1] = k;
                }
            }
        }  
    for(i = 0; i < n; i ++)//输出排序后的结果
        printf("%d ",a[i]);
    return 0;
}
//运行结果如下：
//0 1 4 12 46 55 98 132 232 523 666 789
排序算法选择排序
#include <stdio.h>
#include <stdlib.h>
int main() {
    int a[]= {12,4,132,55,46,232,789,1,0,98,523,666};//随机数组
    int n = sizeof(a)/sizeof(a[0]);//获取数组大小
    int i,j,k;
        //第一次遍历n-1个数，找到最小的数值与第一个元素交换
        //第二次遍历n-2个数，找到最小的数值与第二个元素交换
        // 以此类推
        //第n-1次遍历，找到最小的数值与第n-1个元素交换，排序完成。
    for(i = 0; i < n-1; i ++) {
        for(j = i+1; j < n; j ++) {
             if(a[i] > a[j]) {//从小到大排序
                    k = a[i];
                    a[i] = a[j];
                    a[j] = k;
             }
         }
    }
    for(i = 0; i < n; i ++)//输出排序后的结果
        printf("%d ",a[i]);
    return 0;
}
//运行结果如下：
//0 1 4 12 46 55 98 132 232 523 666 789
排序算法插入排序
#include <stdio.h>
#include <stdlib.h>
int main() {
    int a[]= {12,4,132,55,46,232,789,1,0,98,523,666};//随机数组
    int n = sizeof(a)/sizeof(a[0]);//获取数组大小
    int i,j,k;
 //在要排序的一组数中，假定前n-1个数已经排好序，现将第n个数插到前面的有序数列中，
 //使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。
    for(i = 0; i < n-1; i ++) {
        for(j = i+1; j > 0; j --)
            if(a[j] < a[j-1]) {
                k = a[j-1];
                a[j-1] = a[j];
                a[j] = k;
            } else
                break;
    }
    for(i = 0; i < n; i ++)//输出排序后的结果
        printf("%d ",a[i]);
    return 0;
}
//运行结果如下：
//0 1 4 12 46 55 98 132 232 523 666 789
排序算法快速排序
#include <stdio.h>
#include <stdlib.h>
//先从数列中取出一个数作为key值
//将比这个数小的数全部放在它的左边，大于或等于它的数全部放在它的右边
//对左右两个小数列重复第二步，直至各区间只有1个数。
void quickSort(int a[],int l,int r) {
    if(l>=r)
        return;
    int i = l;
    int j = r;
    int key = a[l];//选择第一个数为key
    while(i<j) {
        while(i<j && a[j]>=key)//从右向左找第一个小于key的值
            j--;
        if(i<j) {
            a[i] = a[j];
            i++;
        }
        while(i<j && a[i]<key)//从左向右找第一个大于key的值
            i++;
        if(i<j) {
            a[j] = a[i];
            j--;
        }
    }
    a[i] = key;
    quickSort(a, l, i-1);//继续排左部分，递归调用
    quickSort(a, i+1, r);//继续排右部分，递归调用
}
int main() {
    int a[]= {12,4,132,55,46,232,789,1,0,98,523,666};//随机数组
    int i,n = sizeof(a)/sizeof(a[0]);//获取数组大小
    quickSort(a,0,n-1);//快速排序函数入口
    for(i = 0; i < n; i ++)//输出排序后的结果
        printf("%d ",a[i]);
    return 0;
}
//运行结果如下：
//0 1 4 12 46 55 98 132 232 523 666 789
排序算法堆排序
#include <stdio.h>
#include <stdlib.h>
int arr[]= {12,4,132,55,46,232,789,1,0,98,523,666};//随机数组
int n = sizeof(arr)/sizeof(arr[0]);//获取数组大小
void adjustHeap(int i, int lef) {
    int temp=arr[i];
    for(int k=i*2+1; k<lef; k=k*2+1) { //从i结点的左子结点开始，也就是2i+1处开始
        if(k+1<lef&&arr[k]<arr[k+1]) {
            k++;
        }
        if(arr[k]>temp) { //如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）
            arr[i]=arr[k];
            i=k;
        } else {
            break;
        }
    }
    arr[i]=temp;//将temp值放到最终的位置
}
void swap(int a, int b) {
    int temp=arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}
void heapsort() {
    // 1、构建大顶堆
    for(int i = n/2-1; i>=0; i--) {
        //从第一个非叶子节点从下至上，从右至左调整结构
        adjustHeap(i,n);
    }
    //2、调整堆结构+交换堆顶元素与末尾元素
    for(int j=n-1; j>0; j--) {
        swap(0,j);//将堆顶元素与末尾元素进行交换
        adjustHeap(0, j);//重新对堆进行调整
    }
}
int main() {
    int i;
    heapsort();
    for(i = 0; i < n; i ++)
        printf("%d ",arr[i]);
    return 0;
}
//运行结果如下：
//0 1 4 12 46 55 98 132 232 523 666 789
插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌
[1] 
。
插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序
[3] 
。
用插入排序对长度为n的待排序数组A进行排序的伪代码（在代码中，A中元素的数目n用A.length来表示）
[1] 
：
INSERTION-SORT(A)
for j=2 to A.length:
    key=A[j]
    //将A[j]插入已排序序列A[1..j-1]
    i=j-1
    while i>0 and A[i]>key
        A[i+1]= A[i]
        i=i-1
    A[i+1]=key
在数组A=（5,2,4,6,1,3）上插入排序的操作。数组下标出现在长方形的上方，数组位置中存储的值出现在长方形中。(a)~(e)第(1)~(8)行for循环的迭代。每次迭代中，黑色的长方形保存取自A[j]的关键字，在第5行的测试中将它与其左边的加阴影的长方形中的值进行比较。加阴影的箭头指出数组值在第6行向右移动一个位置，黑色的箭头指出在第8行关键字被移到的地方。(f)最终排序好的数组
[1] 
。
下面是对数组a进行插入排序的JAVA代码，排序后数组a按升序排列
[4] 
。
public class Insertion
{
    public static void sort(Comparable[] a)
    {
        //将a[]按升序排列
        int N=a.length;
        for (int i=1;i<N;i++)
        {
        //将a[i]插入到a[i-1]，a[i-2]，a[i-3]……之中
            for(int j=i;j>0&&(a[j].compareTo(a[j-1])<0);j--)
            {
                Comparable temp=a[j];
                a[j]=a[j-1];
                a[j-1]=temp;
            }
        }
    }
}
插入排序时间复杂度
在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为



 
[3] 
。
最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为



 
[3] 
。
平均来说，A[1..j-1]中的一半元素小于A[j]，一半元素大于A[j]。插入排序在平均情况运行时间与最坏情况运行时间一样，是输入规模的二次函数
[1] 
。
插入排序空间复杂度
插入排序的空间复杂度为常数阶



 
[5] 
。
如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的
[5] 
。
插入排序适用于已经有部分数据已经排好，并且排好的部分越大越好。一般在输入规模大于1000的场合下不建议使用插入排序
[3] 
。
红黑树是一种特定类型的二叉树，它是在计算机科学中用来组织数据比如数字的块的一种结构。若一棵二叉查找树是红黑树，则它的任一子树必为红黑树.
[4]
红黑树是一种平衡二叉查找树的变体，它的左右子树高差有可能大于 1，所以红黑树不是严格意义上的平衡二叉树（AVL），但 对之进行平衡的代价较低， 其平均统计性能要强于 AVL 。
[2]
由于每一颗红黑树都是一颗二叉排序树，因此，在对红黑树进行查找时，可以采用运用于普通二叉排序树上的查找算法，在查找过程中不需要颜色信息。
[5]
红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。
[3] 
在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求:
性质1. 节点是红色或黑色。
[3]
性质2. 根节点是黑色。
[3]
性质3.所有叶子都是黑色。（叶子是NUIL节点）
[3]
性质4. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点）
性质5.. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
[3]
这些约束强制了红黑树的关键性质: 从根到叶子的最长的可能路径不多于最短的可能路径的两倍长。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的二叉查找树。
[3]
是性质4导致路径上不能有两个连续的红色节点确保了这个结果。最短的可能路径都是黑色节点，最长的可能路径有交替的红色和黑色节点。因为根据性质5所有最长的路径都有相同数目的黑色节点，这就表明了没有路径能多于任何其他路径的两倍长。
[3]
因为红黑树是一种特化的二叉查找树，所以红黑树上的只读操行与普通二叉查找树相同。
[2]
当我们在对红黑树进行插入和删除等操作时，对树做了修改，那么可能会违背红黑树的性




树的左旋(2张)



质。
为了保持红黑树的性质，我们可以对相关节点做一系列的调整，通过对树进行旋转（例如左旋和右旋操作），即修改树中某些结点的颜色及指针结构，以达到对红黑树进行插入、删除结点等操作时，红黑树依然能保持它特有的性质（五点性质）。
[3]
如右图。
红黑树1.节点插入算法
插入过程首先是根据一般二叉查找树的插入步骤， 把新节点 z 插入到 某个叶节点的位置上，然后将 z 着 为红色。 为了保证红黑树的性质能继续保 持，再对有关节点重点着色并旋转，其插入算法如下：
[2]
RB-INSERT (T,z) {
1 按二叉查找树的插入步骤将节点 z 插入到 T 中；
2 color[z]=RED；
3 while(z 不是根节点 &&color[z->parent]= =RED) {Insert-Fixup(T,z);}
4 color[root[T]]=BLACK； }
[2]
对上述算法分析，如果新插入的是黑色节点，那么它所在的路径上就多出一个黑色的节点，所以新插入的节点一定要设成红 色。 但是如果 z 的父节点也是红色，这就违反了每个红色节点的两个子节点都黑色的性质。
[2]
红黑树2.节点删除算法
与红黑树的的插入算法一样，对一个节点的删除算法要花 O(log n)时间，只是删 除算法略微复杂些，删除算法如下：
[2]
RB-DELETE(T,z) {
1 if (z 的左右子节点均为 NIL)
2 { NIL 节点代替 z 的位置； delete(z); }
3 else if (z 有一个子节点为 NIL)
4 {z 的非 NIL 子节点代替 z 的位置；delete(z); }
5 else
6 {将红黑树中序遍历中 z 的后继节点 s 的值赋给 z; delete(s); }
7 if (删除的节点是黑色的) Delete-Fixup(T,x); /*x 指向代替删除节点的节点 */ }
[2]
对以上算法分析，若删除的节点是红色，则不做任何操作，红黑树的任何属性都不会被破坏；若删除的节点是黑色的，显然它所 在的路径上就少一个黑色节点，红黑树的性质就被破坏了，这时执行一个 Delete-Fixup（）来修补这棵树。 一个节点被删除之后，一定 有一个它的节点代替了它的位置，即使是叶节点被删除后，也会有一个空节点来代替它的位置。 设指针 x 指向这个代替位置的节 点，同时引入指向 x 兄弟的指针 w，这里均假设 x 是 x->parent 的左子节点，则 w 是 x->parent 的右子节点，如果实际遇到相反的情 况，只要把所有操作中的左、右 互反一下就可以了。
（图一图二如下）
图2    Delete-Fixup（T，x）修补过程示意图






图1   Insert-Fixup(T,z)修补过程示意图
在红黑树上只读操作不需要对用于二叉查找树的操作做出修改，因为它也是二叉查找树。但是，在插入和删除之后，红黑属性可能变得违规。恢复红黑属性需要少量(O(log n))的颜色变更（这在实践中是非常快速的）并且不超过三次树旋转（对于插入是两次）。这允许插入和删除保持为 O（log n)）次，但是它导致了非常复杂的操作。
[3]
红黑树1.红黑树在Linux非实时任务调度中的应用
Linux 的稳定内核版本在 2． 6． 24 之后，使用了新的调度程序 CFS，所有非实时可运行进程都以虚拟运行时间为 key 值挂在一棵红黑树上，以完成更公平高效地调度所有任务。CFS 弃用 active /expired 数组和动态计算优先级，不再跟踪任务的睡眠时间和区别是否交互任务，并且在调度中采用基于时间计算键值的红黑树来选取下一个任务，根据所有任务占用 CPU 时间的状态来确定调度任务优先级。
[3]
红黑树2.红黑树在Linux虚拟内存中的应用
32 位 Linux 内核虚拟地址空间划分 0 － 3G 为用户空间，3 － 4G 为内核空间，因此每个进程可以使用 4GB的虚拟空间。同时，Linux 定义了虚拟存储区域( VMA) 以便于更好表示进程所使用的虚拟空间，每个 VMA是某个进程的一段连续虚拟空间，其中的单元具有相同的特征，所有的虚拟区域按照地址排序由指针链接为一个链表。当发生缺页中断时搜索 VMA 到指定区域时，则需要频繁操作，因此选用了红黑树以减少查找时间。
[3]
红黑树3.红黑树在检测树的平衡性上的应用
红黑树是一种自平衡二叉搜索树，它的每个节点都被“着色”为红色或者黑色，这些节点的颜色被用来检测树的平衡性。红黑树作为嵌入式数据库中的索引机制，可以获得更好的性能，对于SQLite数据库，可以采用红黑树实现索引机制的优化。
[6]
它的统计性能要好于平衡二叉树（有些书籍根




红黑树

据作者姓名，Adelson-Velskii和Landis，将其称为AVL-树），因此，红黑树在很多地方都有应用。目前，基于拥有上述特性，红黑树已广泛应用Linux 的进程管理、内存管理，设备驱动及虚拟内存跟踪等一系列场景中。
[3] 
其他平衡树还有：AVL，SBT，伸展树，TREAP等等。
单链表，箭头末尾为结点

线性表的链式存储表示的特点是用一组任意的存储单元存储线性表的数据元素（这组存储单元可以是连续的，也可以是不连续的）。因此，为了表示每个数据元素 与其直接后继数据元素 之间的逻辑关系，对数据元素 来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。由这两部分信息组成一个"结点"（如概述旁的图所示），表示线性表中一个数据元素。线性表的链式存储表示，有一个缺点就是要找一个数，必须要从头开始找起，十分麻烦。
根据情况，也可以自己设计链表的其它扩展。但是一般不会在边上附加数据，因为链表的点和边基本上是一一对应的（除了第一个或者最后一个节点，但是也不会产生特殊情况）。不过有一个特例是如果链表支持在链表的一段中把前和后指针反向，反向标记加在边上可能会更方便。
对于非线性的链表，可以参见相关的其他数据结构，例如树、图。另外有一种基于多个线性链表的数据结构：跳表，插入、删除和查找等基本操作的速度可以达到O(nlogn），和平衡二叉树一样。
其中存储数据元素信息的域称作数据域（设域名为data），存储直接后继存储位置的域称为指针域（设域名为next）。指针域中存储的信息又称做指针或链。
由分别表示,，…，的N 个结点依次相链构成的链表，称为线性表的链式存储表示，由于此类链表的每个结点中只包含一个指针域，故又称单链表或线性链表。
（pascal语言）
链表建立
第一行读入n，表示n个数
第二行包括n个数
以链表的形式存储输出这些数
program project1;
type
    point=^node;
    node=record
        data:longint;
        next:point;
    end;
var
    i,n,e:longint;
    p,q,head,last:point;

begin
    write('Input the number count:');
    readln(n);
    i:=1;
    new(head);
    read(e);
    head^.data:=e;
    head^.next:=nil;
    last:=head;
    q:=head;
    while i<n do
        begin
            inc(i);
            read(e);
            new(p);
            q^.next:=p;
            p^.data:=e;
            p^.next:=nil;
            last:=p;
            q:=last
        end;
    //建立链表
    q:=head;
    while q^.next<>nil do
        begin
            write(q^.data,'');
            q:=q^.next;
        end;
    write(q^.data);
    //输出
    readln;
    readln
    end.
删除
在以z为头的链表中搜索第一个n，如果找到则删去，返回值为1，否则返回0
function delete(n:longint;var z:point):longint;
    var
        t,s:point;

    begin
        t:=z;
        while(t^.next<>nil)and(t^.data<>n)do
            begin
                s:=t;
                t:=t^.next;
            end;
        if t^.data<> nthen exit(0);
        s^.next:=t^.next;
        dispose(t);
        exit⑴
    end;
链表查找
类似于删除，只需要找到不删即可
插入
插入，在以zz为头的链表第w个的前面插入nn元素，函数返回值正常是0，如果w超过了链表的长度，函数返回链表的长度
function insert(w,nn:longint;var zz:point):longint;
var d:longint;v,vp,vs:point;

begin
    v:=zz;
    for d:=1 to w do
    if v^.next=nil
        then exit(d)
    else
        begin
            vp:=v;
            v:=v^.next;
        end;

    new(vs);
    vs^.data:=nn;
    vp^.next:=vs;
    vs^.next:=v;
    exit(0)
end;
#include<stdio.h>
#include<stdlib.h>
#include<iostream.h>

usingnamespacestd;

structNode
{
intdata;//数据域
structNode*next;//指针域
};

/*
Create
*函数功能：创建链表.
*输入：各节点的data
*返回值：指针head
*/
Node*Create()
{
intn=0;
Node*head,*p1,*p2;
p1=p2=newNode;
cin>>p1->data;
head=NULL;
while(p1->data!=0)
{
if(n==0)
{
head=p1;
}
else
p2->next=p1;
p2=p1;
p1=newNode;
cin>>p1->data;
n++;
}
p2->next=NULL;
returnhead;
}

/*
insert
*函数功能：在链表中插入元素.
*输入：head链表头指针，p新元素插入位置，x新元素中的数据域内容
*返回值：无
*/
voidinsert(Node*head,intp,intx)
{
Node*tmp=head;//for循环是为了防止插入位置超出了链表长度
for(inti=0;i<p;i++)
{
if(tmp==NULL)
return;
if(i<p-1）
tmp=tmp->next;
}
Node*tmp2=newNode;
tmp2->data=x;
tmp2->next=tmp->next;
tmp->next=tmp2;
}

/*
del
*函数功能：删除链表中的元素
*输入：head链表头指针，p被删除元素位置
*返回值：被删除元素中的数据域.如果删除失败返回-1
*/
intdel(Node*head,intp)
{
Node*tmp=head;
for(inti=0;i<p;i++)
{
if(tmp==NULL)
return-1;
if(i<p-1）
tmp=tmp->next;
}
intret=tmp->next->data;
tmp->next=tmp->next->next;
returnret;
}

voidprint(Node*head)
{
for(Node*tmp=head;tmp!=NULL;tmp=tmp->next)
printf("%d",tmp->data);
printf("\n");
}

intmain()
{
Node*head;
head=newNode;
head->data=-1;
head->next=NULL;
return0;
}
例子
#include<iostream>
#defineNULL0
structstudent
{
longnum;
structstudent*next;
};
intmain()
{
inti,n;
student*p=(structstudent*)malloc(sizeof(structstudent));
student*q=p;
printf("输入几个值");
scanf("%d",&n);
for(i=1;i<=n;i++)
{
scanf("%d",&(q->num));
q->next=(structstudent*)malloc(sizeof(structstudent));
q=q->next;
}
printf("值第几个");
intrank;
scanf("%d%d",&(q->num),&rank);
student*w=p;
for(i=1;i<rank-1;i++)
{
w=w->next;
}
q->next=w->next;
w->next=q;
for(i=1;i<=n+1;i++)
{
printf("%d",p->num);
p=p->next;
}
return0;
}//指针后移麻烦链表形式循环链表
循环链表是与单链表一样，是一种链式的存储结构，所不同的是，循环链表的最后一个结点的指针是指向该循环链表的第一个结点或者表头结点，从而构成一个环形的链。
循环链表的运算与单链表的运算基本一致。所不同的有以下几点：
1、在建立一个循环链表时，必须使其最后一个结点的指针指向表头结点，而不是象单链表那样置为NULL。此种情况还使用于在最后一个结点后插入一个新的结点。
2、在判断是否到表尾时，是判断该结点链域的值是否是表头结点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为NULL。
双向链表
双向链表其实是单链表的改进。
当我们对单链表进行操作时，有时你要对某个结点的直接前驱进行操作时，又必须从表头开始查找。这是由单链表结点的结构所限制的。因为单链表每个结点只有一个存储直接后继结点地址的链域，那么能不能定义一个既有存储直接后继结点地址的链域，又有存储直接前驱结点地址的链域的这样一个双链域结点结构呢？这就是双向链表。
在双向链表中，结点除含有数据域外，还有两个链域，一个存储直接后继结点地址，一般称之为右链域；一个存储直接前驱结点地址，一般称之为左链域。
应用举例概述
约瑟夫环问题：已知n个人（以编号1，2，3...n分别表示）围坐在一张圆桌周围。从编号为k的人开始报数，数到m的那个人出列；他的下一个人又从1开始报数，数到m的那个人又出列；依此规律重复下去，直到圆桌周围的人全部出列。例如：n = 9,k = 1,m = 5
参考代码
#include<stdio.h>
#include<malloc.h>
#defineN41
#defineM5
typedefstructnode*link;
structnode
{
intitem;
linknext;
};
linkNODE(intitem,linknext)
{
linkt=malloc(sizeof*t);
t->item=item;
t->next=next;
returnt;
}
intmain(void)
{
inti;
linkt=NODE（1,NULL);
t->next=t;
for(i=2;i<=N;i++)
t=t->next=NODE(i,t->next);
while(t!=t->next)
{
for(i=1;i<M;i++)
t=t->next;
t->next=t->next->next;
}
printf("%d\n",t->item);
return0;
}
其他相关结语与个人总结
C语言是学习数据结构的很好的学习工具。理解了C中用结构体描述数据结构，那么对于理解其C++描述，Java描述都就轻而易举了！



链表的提出主要在于顺序存储中的插入和删除的时间复杂度是线性时间的，而链表的操作则可以是常数时间的复杂度。对于链表的插入与删除操作，个人做了一点总结，适用于各种链表如下：
插入操作处理顺序：中间节点的逻辑，后节点逻辑，前节点逻辑。按照这个顺序处理可以完成任何链表的插入操作。
删除操作的处理顺序：前节点逻辑，后节点逻辑，中间节点逻辑。
按照此顺序可以处理任何链表的删除操作。
如果不存在其中的某个节点略过即可。
上面的总结，大家可以看到一个现象，就是插入的顺序和删除的顺序恰好是相反的，很有意思！
操作
-----悉尼大学工程学院张志刚（Stone Cold）作品
#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
typedefstructSlist
{
intdata;
structSlist*next;
}
SLIST;
SLIST*InitList_Sq()/*初始化函数*/
{
inta;
SLIST*h,*s,*r;
h=(SLIST*)malloc(sizeof(SLIST));/*建立头指针，头指针不可以更改！！！*/
r=h;
if(!h)
{
printf("分配失败");
exit(0);
}
scanf("%d",&a);
for(;a!=-1;)
{
s=(SLIST*)malloc(sizeof(SLIST));/*每次都开辟一个结点空间并赋值*/
s->data=a;
r->next=s;
r=s;
scanf("%d",&a);
}
r->next='\0';
returnh;
}
voidprint_list(SLIST*finder)/*打印函数*/
{
while(finder!='\0')
{
printf("->%d",finder->data);
finder=finder->next;
}
printf("->end\n");
}
intDeleteNode(SLIST*killer)//删除节点函数
{
inti,j=0;
SLIST*p,*q;
intx;
p=killer;
q=killer->next;
printf("请输入您要删除的节点序号：");
scanf("%d",&i);
while((p->next!='\0')&&(j<i-1））
{
p=p->next;
j++;
q=p->next;
}
if(p->next=='\0'||j>i-1）
{
printf("\nerror");
return-1;
}
else
{
p->next=q->next;
x=q->data;
free(q);
returnx;
}
}
voidInsert_Node(SLIST*jumper)//插入函数，本算法为前插结点法
{
intt,e,j=0;
SLIST*p,*q;
p=jumper;
printf("请输入要插入位置的序号：");
scanf("%d",&t);
printf("请输入要插入的元素：");
scanf("%d",&e);
while(p->next!='\0'&&j<t-1）
{
j++;
p=p->next;
}
if(p=='\0'||j>t-1）
printf("插入的目的位置不存在");
else
{
q=(SLIST*)malloc(sizeof(SLIST));
q->data=e;
q->next=p->next;
p->next=q;
}
}
voidLocate_List(SLIST*reader)//查找值为e的元素
{
inte,i=0;
SLIST*p;
p=reader;
printf("请输入要查找的元素：");
scanf("%d",&e);
while(p->next!='\0'&&p->data!=e)
{
i++;
p=p->next;
}
if(p->data==e)
printf("此元素在%d号位置\n",i);
else
printf("无此元素！");
}
voidmain()
{
inti,k,y;
SLIST*head;
printf("\n1.建立线性表");
printf("\n2.在i位置插入元素e");
printf("\n3.删除第i个元素，返回其值");
printf("\n4.查找值为e的元素");
printf("\n5.结束程序运行");
printf("\n===================================================");
printf("请输入您的选择：");
scanf("%d",&k);
switch(k)
{
case1:
{
head=InitList_Sq();
print_list(head->next);
}break;
case2:
{
head=InitList_Sq();
print_list(head->next);
Insert_Node(head);
print_list(head->next);
}
break;
case3:
{
head=InitList_Sq();
print_list(head->next);
y=DeleteNode(head);
print_list(head->next);
if(y!=-1）
printf("被删除元素为：%d",y);
}break;//头结点不算，从有数据的开始算第一个
case4:
{
head=InitList_Sq();
print_list(head->next);
Locate_List(head);
}break;
}
}
本程序可在微软VC++下编译通过并且运行
使用方法简介：运行程序后，先打数字1，然后回车，这样就可以先创建一个新的链表，比如你要创建一个
4->5->6->7这样一个链表，你就输入数字4回车，输入5回车，输入6回车，输入7回车，最后输入-1回车，这个-1就是告诉程序到此为止的标志
假如你要使用插入的功能位置插入，就输入3，回车，程序会问你插入的数值是什么，比如你要插入999，然后回车，999就被插进去了
其他的功能都大同小异
将表中元素一个接一个的存入一组连续的存储单元中，这种存储结构是顺序结构。
采用顺序存储结构的线性表简称为“ 顺序表”。顺序表的存储特点是：只要确定了起始位置，表中任一元素的地址都通过下列公式得到：LOC（ai）=LOC（a1）+（i-1）*L 　1≤i≤n 其中，L是元素占用存储单元的长度。
顺序表的结构定义：
#define maxlen 50 //定义顺序表中元素个数最多有几个
typedef struct
{
elementtype data[maxlen]; //elementtype是元素的类型 依具体情况而定
int listlen; //便于时刻了解顺序表里元素的个数
}seqlist; //顺序表的名称 不妨为seqlist
声明顺序表类型变量：
seqlist L,L1;
如顺序表的每个结点占用len个内存单元，用location (ki)表示顺序表中第i个结点ki所占内存空间的第1个单元的地址。则有如下的关系:location (ki+1) = location (ki) +len
location (ki) = location(k1) + (i-1)len
存储结构要体现数据的逻辑结构，顺序表的存储结构中，内存中物理地址相邻的结点一定具有顺序表中的逻辑关系。
[2]
1.构造一个空的顺序线性表
Status InitList(SqList &L) // 算法2.3
{ // 操作结果：构造一个空的顺序线性表
L.elem=(ElemType*)malloc(LIST_INIT_SIZE*sizeof(ElemType));
if(!L.elem)
exit(OVERFLOW); // 存储分配失败
L.length=0; // 空表长度为0
L.listsize=LIST_INIT_SIZE; // 初始存储容量
return OK;
}
2.销毁顺序线性表L
Status DestroyList(SqList &L)
{ // 初始条件：顺序线性表L已存在。操作结果：销毁顺序线性表L
free(L.elem);
L.elem=NULL;
L.length=0;
L.listsize=0;
return OK;
}
3.将L重置为空表
Status ClearList(SqList &L)
{ // 初始条件：顺序线性表L已存在。操作结果：将L重置为空表
L.length=0;
return OK;
}
4.判断是否为空表
Status ListEmpty(SqList L)
{ // 初始条件：顺序线性表L已存在。操作结果：若L为空表，则返回TRUE，否则返回FALSE
if(L.length==0)
return TRUE;
else
return FALSE;
}
5.返回L中数据元素个数
int ListLength(SqList L)
{ // 初始条件：顺序线性表L已存在。操作结果：返回L中数据元素个数
return L.length;
}
6.用e返回L中第i个数据元素的值
Status GetElem(SqList L,int i,ElemType &e)
{ // 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)
// 操作结果：用e返回L中第i个数据元素的值
if(i<1||i>L.length)
exit(ERROR);
e=*(L.elem+i-1);
return OK;
}
7.返回L中第1个与e满足关系，不存在，则返回值为0
int LocateElem(SqList L,ElemType e,Status(*compare)(ElemType,ElemType))
{ // 初始条件：顺序线性表L已存在，compare()是数据元素判定函数(满足为1,否则为0)
// 操作结果：返回L中第1个与e满足关系compare()的数据元素的位序。
// 若这样的数据元素不存在，则返回值为0。算法2.6
ElemType *p;
int i=1; // i的初值为第1个元素的位序
p=L.elem; // p的初值为第1个元素的存储位置
while(i<=L.length&&!compare(*p++,e))
++i;
if(i<=L.length)
return i;
else
return 0;
}
8.是L的数据元素，且不是第一个，则用pre_e返回它的前驱
Status PriorElem(SqList L,ElemType cur_e,ElemType &pre_e)
{ // 初始条件：顺序线性表L已存在
// 操作结果：若cur_e是L的数据元素，且不是第一个，则用pre_e返回它的前驱，
// 否则操作失败，pre_e无定义
int i=2;
ElemType *p=L.elem+1;
while(i<=L.length&&*p!=cur_e)
{
p++;
i++;
}
if(i>L.length)
return INFEASIBLE;
else
{
pre_e=*--p;
return OK;
}
}
9.cur_e是L的数据元素，且不是最后一个，用next_e返回它的后继
Status NextElem(SqList L,ElemType cur_e,ElemType &next_e)
{ // 初始条件：顺序线性表L已存在
// 操作结果：若cur_e是L的数据元素，且不是最后一个，则用next_e返回它的后继，
// 否则操作失败，next_e无定义
int i=1;
ElemType *p=L.elem;
while(i<L.length&&*p!=cur_e)
{
i++;
p++;
}
if(i==L.length)
return INFEASIBLE;
else
{
next_e=*++p;
return OK;
}
}
10.在L中第i个位置之前插入新的数据元素e
Status ListInsert(SqList &L,int i,ElemType e) // 算法2.4
{ // 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)+1
// 操作结果：在L中第i个位置之前插入新的数据元素e，L的长度加1
ElemType *newbase,*q,*p;
if(i<1||i>L.length+1) // i值不合法
return ERROR;
if(L.length>=L.listsize) // 当前存储空间已满,增加分配
{
if(!(newbase=(ElemType *)realloc(L.elem,(L.listsize+LISTINCREMENT)*sizeof(ElemType))))
exit(OVERFLOW); // 存储分配失败
L.elem=newbase; // 新基址
L.listsize+=LISTINCREMENT; // 增加存储容量
}
q=L.elem+i-1; // q为插入位置
for(p=L.elem+L.length-1;p>=q;--p) // 插入位置及之后的元素右移
*(p+1)=*p;
*q=e; // 插入e
++L.length; // 表长增1
return OK;
}
11.删除L的第i个数据元素，并用e返回其值
Status ListDelete(SqList &L,int i,ElemType &e) // 算法2.5
{ // 初始条件：顺序线性表L已存在，1≤i≤ListLength(L)
// 操作结果：删除L的第i个数据元素，并用e返回其值，L的长度减1
ElemType *p,*q;
if(i<1||i>L.length) // i值不合法
return ERROR;
p=L.elem+i-1; // p为被删除元素的位置
e=*p; // 被删除元素的值赋给e
q=L.elem+L.length-1; // 表尾元素的位置
for(++p;p<=q;++p) // 被删除元素之后的元素左移
*(p-1)=*p;
L.length--; // 表长减1
return OK;
}
12.依次对L的每个数据元素调用函数vi()。一旦vi()失败，则操作失败
Status ListTraverse(SqList L,void(*vi)(ElemType&))
{ // 初始条件：顺序线性表L已存在
// 操作结果：依次对L的每个数据元素调用函数vi()。一旦vi()失败，则操作失败
// vi()的形参加'&'，表明可通过调用vi()改变元素的值
ElemType *p;
int i;
p=L.elem;
for(i=1;i<=L.length;i++)
vi(*p++);
cout<<endl;
return OK;
}
[2]
一个算法应该具有以下五个重要的特征：
算法有穷性
（Finiteness）
算法的有穷性是指算法必须能在执行有限个步骤之后终止；
算法确切性
(Definiteness)
算法的每一步骤必须有确切的定义；
算法输入项
(Input)
一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
算法输出项
(Output)
一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
算法可行性
(Effectiveness)
算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步骤，即每个计算步骤都可以在有限时间内完成（也称之为有效性）。
一、数据对象的运算和操作：计算机可以执行的基本操作是以指令的形式描述的。一个计算机系统能执行的所有指令的集合，成为该计算机系统的指令系统。一个计算机的基本运算和操作有如下四类：
[1]
1.算术运算：加减乘除等运算
2.逻辑运算：或、且、非等运算
3.关系运算：大于、小于、等于、不等于等运算
4.数据传输：输入、输出、赋值等运算
[1]
二、算法的控制结构：一个算法的功能结构不仅取决于所选用的操作，而且还与各操作之间的执行顺序有关。
[1]
同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。一个算法的评价主要从时间复杂度和空间复杂度来考虑。
算法时间复杂度
算法的时间复杂度是指执行算法所需要的计算工作量。一般来说，计算机算法是问题规模n 的函数f(n)，算法的时间复杂度也因此记做。
T(n)=Ο(f(n))
因此，问题的规模n 越大，算法执行的时间的增长率与f(n) 的增长率正相关，称作渐进时间复杂度（Asymptotic Time Complexity）。
算法空间复杂度
算法的空间复杂度是指算法需要消耗的内存空间。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。
算法正确性
算法的正确性是评价一个算法优劣的最重要的标准。
算法可读性
算法的可读性是指一个算法可供人们阅读的容易程度。
[1]
算法健壮性
健壮性是指一个算法对不合理数据输入的反应能力和处理能力，也称为容错性。
[1]
算法递推法
递推是序列计算机中的一种常用算法。它是按照一定的规律来计算序列中的每个项，通常是通过计算机前面的一些项来得出序列中的指定项的值。其思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复，该算法利用了计算机速度快和不知疲倦的机器特点。
算法递归法
程序调用自身的编程技巧称为递归（recursion）。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。
注意：
(1) 递归就是在过程或函数里调用自身;
(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。
算法穷举法
穷举法，或称为暴力破解法，其基本思路是：对于要解决的问题，列举出它的所有可能的情况，逐个判断有哪些是符合问题所要求的条件，从而得到问题的解。它也常用于对于密码的破译，即将密码进行逐个推算直到找出真正的密码为止。例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试10000次就能找到正确的密码。理论上利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。因此有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围。
算法贪心算法
贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。
用贪心法设计算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，它省去了为找最优解要穷尽所有可能而必须耗费的大量时间，它采用自顶向下,以迭代的方法做出相继的贪心选择,每做一次贪心选择就将所求问题简化为一个规模更小的子问题, 通过每一步贪心选择,可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。
贪婪算法是一种改进了的分级处理方法，其核心是根据题意选取一种量度标准，然后将这多个输入排成这种量度标准所要求的顺序，按这种顺序一次输入一个量，如果这个输入和当前已构成在这种量度意义下的部分最佳解加在一起不能产生一个可行解，则不把此输入加到这部分解中。这种能够得到某种量度意义下最优解的分级处理方法称为贪婪算法。
对于一个给定的问题，往往可能有好几种量度标准。初看起来，这些量度标准似乎都是可取的，但实际上，用其中的大多数量度标准作贪婪处理所得到该量度意义下的最优解并不是问题的最优解，而是次优解。因此，选择能产生问题最优解的最优量度标准是使用贪婪算法的核心。
一般情况下，要选出最优量度标准并不是一件容易的事，但对某问题能选择出最优量度标准后，用贪婪算法求解则特别有效。
算法分治法
分治法是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。
分治法所能解决的问题一般具有以下几个特征：
(1) 该问题的规模缩小到一定的程度就可以容易地解决；
(2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；
(3) 利用该问题分解出的子问题的解可以合并为该问题的解；
(4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。
算法动态规划法
动态规划是一种在数学和计算机科学中使用的，用于求解包含重叠子问题的最优化问题的方法。其基本思想是，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域。
动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。不象前面所述的那些搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。
算法迭代法
迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题。迭代法又分为精确迭代和近似迭代。“二分法”和“牛顿迭代法”属于近似迭代法。迭代算法是用计算机解决问题的一种基本方法。它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。
算法分支界限法
分枝界限法是一个用途十分广泛的算法，运用这种算法的技巧性很强，不同类型的问题解法也各不相同。
分支定界法的基本思想是对有约束条件的最优化问题的所有可行解（数目有限）空间进行搜索。该算法在具体执行时，把全部可行的解空间不断分割为越来越小的子集（称为分支），并为每个子集内的解的值计算一个下界或上界（称为定界）。在每次分支后，对凡是界限超出已知可行解值那些子集不再做进一步分支，这样，解的许多子集（即搜索树上的许多结点）就可以不予考虑了，从而缩小了搜索范围。这一过程一直进行到找出可行解为止，该可行解的值不大于任何子集的界限。因此这种算法一般可以求得最优解。
与贪心算法一样，这种方法也是用来为组合优化问题设计求解算法的，所不同的是它在问题的整个可能解空间搜索，所设计出来的算法虽其时间复杂度比贪婪算法高，但它的优点是与穷举法类似，都能保证求出问题的最佳解，而且这种方法不是盲目的穷举搜索，而是在搜索过程中通过限界，可以中途停止对某些不可能得到最优解的子空间进一步搜索（类似于人工智能中的剪枝），故它比穷举法效率更高。
算法回溯法
回溯法（探索与回溯法）是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。
其基本思想是，在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。 若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。 而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。
描述算法的方法有多种，常用的有自然语言、结构化流程图、伪代码和PAD图等，其中最普遍的是流程图。
算法可大致分为基本算法、数据结构的算法、数论与代数算法、计算几何的算法、图论的算法、动态规划以及数值分析、加密算法、排序算法、检索算法、随机化算法、并行算法，厄米变形模型，随机森林算法。
算法可以宏泛的分为三类：
一、有限的，确定性算法 这类算法在有限的一段时间内终止。他们可能要花很长时间来执行指定的任务，但仍将在一定的时间内终止。这类算法得出的结果常取决于输入值。
二、有限的，非确定算法 这类算法在有限的时间内终止。然而，对于一个（或一些）给定的数值，算法的结果并不是唯一的或确定的。
三、无限的算法 是那些由于没有定义终止定义条件，或定义的条件无法由输入的数据满足而不终止运行的算法。通常，无限算法的产生是由于未能确定的定义终止条件。
“算法”即演算法的大陆中文名称出自《周髀算经》；而英文名称Algorithm 来自于9世纪波斯数学家al-Khwarizmi，因为al-Khwarizmi在数学上提出了算法这个概念。“算法”原为"algorism"，意思是阿拉伯数字的运算法则，在18世纪演变为"algorithm"。欧几里得算法被人们认为是史上第一个算法。 第一次编写程序是Ada Byron于1842年为巴贝奇分析机编写求解伯努利方程的程序，因此Ada Byron被大多数人认为是世界上第一位程序员。因为查尔斯·巴贝奇(Charles Babbage)未能完成他的巴贝奇分析机，这个算法未能在巴贝奇分析机上执行。 因为"well-defined procedure"缺少数学上精确的定义，19世纪和20世纪早期的数学家、逻辑学家在定义算法上出现了困难。20世纪的英国数学家图灵提出了著名的图灵论题，并提出一种假想的计算机的抽象模型，这个模型被称为图灵机。图灵机的出现解决了算法定义的难题，图灵的思想对算法的发展起到了重要作用。
经典的算法有很多，如欧几里德算法，割圆术，秦九韶算法。
随着计算机的发展，算法在计算机方面已有广泛的发展及应用，如用随机森林算法，来进行头部姿势的估计，用遗传算法来解决弹药装载问题，信息加密算法在网络传输中的应用，并行算法在数据挖掘中的应用等。
字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 s=“a1a2···an”(n>=0)。它是编程语言中表示文本的数据类型。在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。
通常以串的整体作为操作对象，如：在串中查找某个子串、求取一个子串、在串的某个位置上插入一个子串以及删除一个子串等。两个字符串相等的充要条件是：长度相等，并且各个对应位置上的字符都相等。设p、q是两个串，求q在p中首次出现的位置的运算叫做模式匹配。串的两种最基本的存储方式是顺序存储方式和链接存储方式。
1. 连接运算 concat(s1,s2,s3…sn) 相当于s1+s2+s3+…+sn.
例：concat(‘11’,'aa’)='11aa’;
2. 求子串。 Copy(s,I,I) 从字符串s中截取第I个字符开始后的长度为l的子串。
例:copy(‘abdag’,2,3)=’bda’
3. 删除子串。过程 Delete(s,I,l) 从字符串s中删除第I个字符开始后的长度为l的子串。
例：s:=’abcde’;delete(s,2,3);结果s:=’ae’
4. 插入子串。 过程Insert(s1,s2,I) 把s1插入到s2的第I个位置
例：s:=abc;insert(‘12’,s,2);结果s:=’a12bc’
5. 求字符串长度 length(s) 例：length(‘12abc’)=5
在ASP中 求字符串长度用 len(s)例: len("abc12")=5
6. 搜索子串的位置 pos(s1,s2) 如果s1是s2的子串 ，则返回s1的第一个字符在s2中的位置，若不是子串，则返回0.
例：pos(‘ab’,’12abcd’)=3
7. 字符的大写转换。Upcase(ch) 求字符ch的大写体。
例：upcase(‘a’)=’A’
8. 数值转换为数串。 过程 Str(x,s) 把数值x化为数串s.
例：str(12345,s); 结果s=’12345’
9. 数串转换为数值。 过程val(s,x,I) 把数串s转化为数值x,如果成功则I=0,不成功则I为无效字符的序数,第三个参数也可不传
例：val(‘1234’,x,I);结果 x:=1234
“字符串（Trojan.String.a）”病毒：警惕程度★★★，木马病毒，通过网络传播，依赖系统: WIN9X/NT/2000/XP。
该病毒通过网络传播，进入用户电脑后就隐藏在系统目录和内存中，病毒发作时会给用户电脑造成以下破坏：屏幕为空、无端打开CD驱动器、进行洪水攻击、打开黄色网站等，用户要小心防毒。
设 Σ 是叫做字母表的非空有限集合。Σ 的元素叫做“符号”或“字符”。在 Σ 上的字符串(或字)是来自 Σ 的任何有限序列。例如，如果 Σ = {0, 1}，则 0101 是在 Σ 之上的字符串。
字符串的长度是在字符串中字符的数目(序列的长度)，它可以是任何非负整数。“空串”是在 Σ 上的唯一的长度为 0 的字符串，并被指示为 ε 或 λ。
在 Σ 上的所有长度为 n 的字符串的集合指示为 Σn。例如，如果 Σ = {0, 1} 则 Σ2 = {00, 01, 10, 11}。注意 Σ0 = {ε} 对于任何字母表 Σ。
在 Σ 上的所有任何长度的字符串的集合是 Σ 的Kleene闭包并被指示为 Σ*。 依据Σn, 。例如，如果 Σ = {0, 1} 则 Σ* = {ε, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, …}。尽管 Σ* 自身是可数无限的，Σ* 的所有元素都有有限长度。
在 Σ 上一个字符串的集合(就是 Σ* 的任何子集)被称为在 Σ 上的形式语言。例如，如果 Σ = {0, 1}，则带有偶数个零的字符串的集合({ε, 1, 00, 11, 001, 010, 100, 111, 0000, 0011, 0101, 0110, 1001, 1010, 1100, 1111, …})是在 Σ 上的形式语言。
“串接”是 Σ* 上的重要二元运算。对于 Σ* 中的两个字符串 s 和 t，它们的串接被定义为在 s 中的字符序列之后跟随着 t 中的字符序列，并被指示为 st。例如，Σ = {a, b, …, z}，并且 s = bear 且 t = hug，则 st = bearhug 而 ts = hugbear。
字符串串接是结合性的，但非交换性运算。空串充当单位；对于任何字符串 s，有 εs = sε = s。所以，集合 Σ* 和串接运算形成了幺半群，就是从 Σ 生成的自由幺半群。此外，长度函数定义从 Σ* 到非负整数的幺半群同态。
字符串 s 被称为是字符串 t 的“子串”或“因子”，如果存在(可能为空)字符串 u 和 v 使得 t = usv。“是其子串”关系定义了在 Σ* 上的偏序，其最小元是空串。
经常需要定义在字符串集合上的次序。如果字符表 Σ 有一个全序 (cf. 字母序)，则可以定义在 Σ* 上的叫做词典序的全序。注意因为 Σ 是有限的，总是可以定义在 Σ 继而在 Σ* 上的良好次序。例如，如果 Σ = {0, 1} 并且 0 < 1，则 Σ* 的词典次序是 ε < 0 < 00 < 000 < … < 011 < 0110 < … < 01111 < … < 1 < 10 < 100 < … < 101 < … < 111 …
在形式理论中经常出现一些在字符串上的额外运算。它们在条目字符串运算中给出。
字符串数据类型是建模在形式字符串的想法上的数据类型。字符串是几乎在所有编程语言中可以实现的非常重要和有用的数据类型。在某些语言中它们可作为基本类型获得，在另一些语言中做为复合类型获得。多数高级语言的语法允许通常用某种方式引用起来的字符串来表示字符串数据类型的实例；这种元字符串叫做“文本”或“字符串文本”。
尽管形式字符串可以有任意(但有限)的长度，实际语言的字符串的长度经常被限制到一个人工极大值。一般的说，有两种类型的字符串数据类型: “定长字符串”，它有固定的极大长度并且不管是否达到了这个极大值都使用同样数量的内存；和“变长字符串”，它的长度不是专断固定的并且依赖于实际的大小使用可变数量的内存。在现代编程语言中的多数字符串是变长字符串。尽管叫这个名字，所有变长字符串还是在长度上有个极限，一般的说这个极限只依赖于可获得的内存的数量。
历史上，字符串数据类型为每个字符分配一个字节，尽管精确的字符集随着区域而改变，字符编码足够类似得程序员可以忽略它 — 同一个系统在不同的区域中使用的字符集组要么让一个字符在同样位置，要么根本就没有它。这些字符集典型的基于ASCII码或EBCDIC码。
意音文本的语言比如汉语、日语和朝鲜语(合称为CJK)的合理表示需要多于256个字符(每字符一个字节编码的极限)。常规的解决涉及保持对ASCII码的单字节表示并使用双字节来表示CJK字形。现存代码在用到它们会导致一些字符串匹配和切断上的问题，严重程度依赖于字符编码是如何设计的。某些编码比如EUC家族保证在ASCII码范围内的字节值只表示ASCII字符，使得使用这些字符作为字段分隔符的系统得到编码安全。其他编码如ISO-2022和Shift-JIS不做这种担保，使得基于字节的代码做的匹配不安全。另一个问题是如果一个字符串的开头被删除了，对解码器的重要指示或关于在多字节序列中的位置的信息可能就丢失了。另一个问题是如果字符串被连接到一起(特别是在被不知道这个编码的代码截断了它们的结尾之后)，第一个字符串可能不能导致编码器进入适合处理第二个字符串的状态中。
Unicode也有些复杂的问题。多数语言有Unicode字符串数据类型(通常是UTF-16，因为它在Unicode补充位面介入之前就被增加了)。在Unicode和本地编码之间转换要求理解本地编码，这对于现存系统要一起传输各种编码的字符串而又没有实际标记出它们用了什么编码就是个问题。
某些语言如 C++ 把字符串实现为可以用于任何基本类型的模版，但这是个例外而不是规则。
如果一个面向对象语言把字符串表示为对象，它们叫做“可变的”(mutable)，如果值可以在进行时间变更，叫做“不变的”(immutable)，如果这个值在建立后就冻结了。例如，Ruby 有可变字符串，而 Python 的字符串是不可变的。
其他语言，最著名的有 Prolog 和 Erlang，避免实现字符串数据类型，转而采用把字符串表示为字符代码的列表的约定。
一种常用的表示法是使用一个字符代码的数组，每个字符占用一个字节（如在ASCII代码中）或两个字节（如在unicode中）。它的长度可以使用一个结束符（一般是NUL，ASCII代码是0，在C编程语言中使用这种方法）。或者在前面加入一个整数值来表示它的长度（在Pascal语言中使用这种方法）。
这是一个用NUL结束的字符串的例子，它用10个byte存储，用ASCII表示法：
F R A N K NUL k e f w
46 52 41 4E 4B 00 6B 66 66 77
上面的字符串的长度为5个字符，但注意它占用6个字节。结束符后的字符没有任何意义。
这是相同的Pascal字符串：
length F R A N K k e f w
05 46 52 41 4E 4B 6B 66 66 77
当然，可能还有其它的表示法。使用树和列表可以使得一些字符串操作（如插入和删除）更高效。
一些编程语言设计为编写字符串处理程序更容易编写。这是一些例子：
awk
Icon
perl
MUMPS
sed
SNOBOL
很多UNIX实用程序进行简单的字符串处理，并能用于简单地编写一些强大的字符串处理算法。文件和有限流可以像字符串一样查看。
一些新的编程语言，包括Perl、Python和Ruby，借助正则表达式来帮助文本处理。
一个简单的字符串操作是“连接”：也就是说先写一个字符串S，随后在后面再写一个T得到ST这样一个过程。 其它的常见操作包括在一个长字符串中搜索一个子串，排列一组字符串以及分析一个字符串。因为存在如此多的字符串应用方式，所以相应地有许多权衡了不同应用的相关算法。 高级的字符串算法通常使用包括后向树和有限状态机在内的复杂机制和数据结构。
这是一些字符串处理算法，在字符串上进行不同的处理：
字符串查找算法
正则表达式算法
模式匹配
字符串的匹配算法（kmp）
AC自动机
后缀数组/树/自动机
string是一系列字符。在 php 中，字符和字节一样，也就是说，一共有 256 种不同字符的可能性。这也暗示 php 对 Unicode 没有本地支持。请参阅函数utf8_encode()和utf8_decode()以了解有关 Unicode 支持
注:一个字符串变得非常巨大也没有问题，php 没有给字符串的大小强加实现范围，所以完全没有理由担心长字符串。
语法
字符串可以用三种字面上的方法定义。
单引号
双引号
定界符
字符串单引号
指定一个简单字符串的最简单的方法是用单引号（字符 '）括起来。
要表示一个单引号，需要用反斜线（/）转义，和很多其它语言一样。如果在单引号之前或字符串结尾需要出现一个反斜线，需要用两个反斜线表示。注意如果试图转义任何其它字符，反斜线本身也会被显示出来！所以通常不需要转义反斜线本身。
注:在 php 3 中，此情况下将发出一个 E_NOTICE 级的警告。
注:和其他两种语法不同，单引号字符串中出现的变量和转义序列不会被变量的值替代。
<?phpecho 'this is a simple string';echo 'You can also have embedded newlines instrings this way as it isokay to do';// Outputs: Arnold once said: "I'll be back"echo 'Arnold once said: "I/'ll be back"';// Outputs: You deleted C:/*.*?echo 'You deleted C://*.*?';// Outputs: You deleted C:/*.*?echo 'You deleted C:/*.*?';// Outputs: This will not expand: /n a newlineecho 'This will not expand: /n a newline';// Outputs: Variables do not $expand $eitherecho 'Variables do not $expand $either';?>
此外，如果试图转义任何其它字符，反斜线本身也会被显示出来！
双引号字符串最重要的一点是其中的变量名会被变量值替代。细节参见字符串解析。
字符串定界符
另一种给字符串定界的方法使用定界符语法（“<<<”）。应该在 <<< 之后提供一个标识符，然后是字符串，然后是同样的标识符结束字符串。
结束标识符必须从行的第一列开始。同样，标识符也必须遵循 php 中其它任何标签的命名规则：只能包含字母数字下划线，而且必须以下划线或非数字字符开始。
例子 11-3. 非法的例子
<?phpclass foo { public $bar = <<<EOTbarEOT;}?>
定界符文本表现的就和双引号字符串一样，只是没有双引号。这意味着在定界符文本中不需要转义引号，不过仍然可以用以上列出来的转义代码。变量会被展开，但当在定界符文本中表达复杂变量时和字符串一样同样也要注意。
例子 11-4. 定界符字符串例子
<?php$str = <<<EODExample of stringspanning multiple linesusing heredoc syntax.EOD;/* More complex example, with variables. */class foo{ var $foo; var $bar; function foo() { $this->foo = 'Foo'; $this->bar = array('Bar1', 'Bar2', 'Bar3'); }}$foo = new foo();$name = 'MyName';echo <<<EOTMy name is "$name". I am printing some $foo->foo.Now, I am printing some {$foo->bar[1]}.This should print a capital 'A': /x41EOT;?>注:定界符支持是 php 4 中加入的。
字符串变量解析
当用双引号或者定界符指定字符串时，其中的变量会被解析。
有两种语法，一种简单的和一种复杂的。简单语法最通用和方便，它提供了解析变量，数组值，或者对象属性的方法。
复杂语法是 php 4 引进的，可以用花括号括起一个表达式。
简单语法如果遇到美元符号（$），解析器会尽可能多地取得后面的字符以组成一个合法的变量名。如果想明示指定名字的结束，用花括号把变量名括起来。
<?php$beer = 'Heineken';echo "$beer's taste is great"; // works, "'" is an invalid character for varnamesecho "He drank some $beers"; // won't work, 's' is a valid character for varnamesecho "He drank some ${beer}s"; // worksecho "He drank some {$beer}s"; // works?>
同样也可以解析数组索引或者对象属性。对于数组索引，右方括号（]）标志着索引的结束。对象属性则和简单变量适用同样的规则，尽管对于对象属性没有像变量那样的小技巧。
<?php// These examples are specific to using arrays inside of strings.// When outside of a string, always quote your array string keys// and do not use {braces} when outside of strings either.// Let's show all errorserror_reporting(E_ALL);$fruits = array('strawberry' => 'red', 'banana' => 'yellow');// Works but note that this works differently outside string-quotesecho "A banana is $fruits[banana].";// Worksecho "A banana is {$fruits['banana']}.";// Works but php looks for a constant named banana first// as described below.echo "A banana is {$fruits[banana]}.";// Won't work, use braces. This results in a parse error.echo "A banana is $fruits['banana'].";// Worksecho "A banana is " . $fruits['banana'] . ".";// Worksecho "This square is $square->width meters broad.";// Won't work. For a solution, see the complex syntax.echo "This square is $square->width00 centimeters broad.";?>
对于任何更复杂的情况，应该使用复杂语法。
复杂（花括号）语法不是因为语法复杂而称其为复杂，而是因为用此方法可以包含复杂的表达式。
事实上，用此语法可以在字符串中包含任何在名字空间的值。仅仅用和在字符串之外同样的方法写一个表达式，然后用 { 和 } 把它包含进来。因为不能转义“{”，此语法仅在 $ 紧跟在 { 后面时被识别（用“{/$”或者“/{$”来得到一个字面上的“{$”）。用一些例子可以更清晰：
<?php// Let's show all errorserror_reporting(E_ALL);$great = 'fantastic';// 不行，输出为：This is { fantastic}echo "This is { $great}";// 可以，输出为：This is fantasticecho "This is {$great}";echo "This is ${great}";// Worksecho "This square is {$square->width}00 centimeters broad.";// Worksecho "This works: {$arr[4][3]}";// This is wrong for the same reason as $foo[bar] is wrong// outside a string. In otherwords, it will still work but// because php first looks for a constant named foo, it will// throw an error of level E_NOTICE (undefined constant).echo "This is wrong: {$arr[foo][3]}";// Works. When using multi-dimensional arrays, always use// braces around arrays when inside of stringsecho "This works: {$arr['foo'][3]}";// Works.echo "This works: " . $arr['foo'][3];echo "You can even write {$obj->values[3]->name}";echo "This is the value of the var named $name: {${$name}}";?>
访问和修改字符串中的字符
字符串中的字符可以通过在字符串之后用花括号指定所要字符从零开始的偏移量来访问和修改。
注:为了向下兼容，仍然可以用方括号。不过此语法自 php 4 起已过时。
例子 11-5. 一些字符串例子
<?php// Get the first character of a string$str = 'This is a test.';$first = $str{0};// Get the third character of a string$third = $str{2};// Get the last character of a string.$str = 'This is still a test.';$last = $str{strlen($str)-1};// Modify the last character of a string$str = 'Look at the sea';$str{strlen($str)-1} = 'e';?>
字符串实用函数
字符串可以用“.”（点）运算符连接。注意这里不能用“+”（加）运算符。更多信息参见字符串运算符。
有很多实用函数来改变字符串。
普通函数见字符串函数一节，高级搜索和替换见正则表达式函数（两种风格：Perl 和 POSIX 扩展）。
还有 URL 字符串函数，以及加密/解密字符串的函数（mcrypt 和 mhash）。
最后，如果还是找不到想要的函数，参见字符类型函数。
字符串转换
可以用 (string) 标记或者strval()函数将一个值转换为字符串。当某表达式需要字符串时，字符串的转换会在表达式范围内自动完成。例如当使用echo()或者print()函数时，或者将一个变量值与一个字符串进行比较的时候。阅读手册中有关类型和类型戏法中的部分有助于更清楚一些。参见settype()。
布尔值TRUE将被转换为字符串 "1"，而值FALSE将被表示为 ""（即空字符串）。这样就可以随意地在布尔值和字符串之间进行比较。
整数或浮点数数值在转换成字符串时，字符串由表示这些数值的数字字符组成（浮点数还包含有指数部分）。
数组将被转换成字符串 "Array"，因此无法通过echo()或者print()函数来输出数组的内容。请参考下文以获取更多提示。
对象将被转换成字符串 "Object"。如果因为调试需要，需要将对象的成员变量打印出来，请阅读下文。如果希望得到该对象所依附的类的名称，请使用函数get_class()。自 php 5 起，如果合适可以用 __toString() 方法。
资源类型总是以 "Resource id #1" 的格式被转换成字符串，其中 1 是 php 在运行时给资源指定的唯一标识。如果希望获取资源的类型，请使用函数get_resource_type()。
NULL将被转换成空字符串。
正如以上所示，将数组、对象或者资源打印出来，并不能提供任何关于这些值本身的有用的信息。请参阅函数print_r()和var_dump()，对于调试来说，这些是更好的打印值的方法。
可以将 php 的值转换为字符串以永久地储存它们。这种方法被称为序列化，可以用函数serialize()来完成该操作。如果在安装 php 时建立了 WDDX 支持，还可以将 php 的值序列化为 XML 结构。
字符串转换数值
当一个字符串被当作数字来求值时，根据以下规则来决定结果的类型和值。
如果包括“.”，“e”或“E”其中任何一个字符的话，字符串被当作float来求值。否则就被当作整数。
该值由字符串最前面的部分决定。如果字符串以合法的数字数据开始，就用该数字作为其值，否则其值为 0（零）。合法数字数据由可选的正负号开始，后面跟着一个或多个数字（可选地包括十进制分数），后面跟着可选的指数。指数是一个“e”或者“E”后面跟着一个或多个数字。
<?php$foo = 1 + "10.5"; // $foo is float (11.5)$foo = 1 + "-1.3e3"; // $foo is float (-1299)$foo = 1 + "bob-1.3e3"; // $foo is integer (1)$foo = 1 + "bob3"; // $foo is integer (1)$foo = 1 + "10 Small Pigs"; // $foo is integer (11)$foo = 4 + "10.2 Little Piggies"; // $foo is float (14.2)$foo = "10.0 pigs " + 1; // $foo is float (11)$foo = "10.0 pigs " + 1.0; // $foo is float (11)?>
此转换的更多信息见 Unix 手册中关于 strtod(3) 的部分。
如果想测试本节中的任何例子，可以拷贝和粘贴这些例子并且加上下面这一行自己看看会发生什么：
<?phpecho "/$foo==$foo; type is " . gettype ($foo) . "<br />/n";?>
不要指望在将一个字符转换成整型时能够得到该字符的编码（可能也会在 C 中这么做）。如果希望在字符编码和字符之间转换，请使用ord()和chr()函数。
粒子群优化算法定义
粒子群优化算法(Particle Swarm optimization,PSO)又翻译为粒子群算法、微粒群算法、或微粒群优化算法。是通过模拟鸟群觅食行为而发展起来的一种基于群体协作的随机搜索算法。通常认为它是群集智能 (Swarm intelligence, SI) 的一种。它可以被纳入多主体优化系统(Multiagent Optimization System, MAOS)。粒子群优化算法是由Eberhart博士和kennedy博士发明。
粒子群优化算法模拟捕食
PSO模拟鸟群的捕食行为。一群鸟在随机搜索食物，在这个区域里只有一块食物。所有的鸟都不知道食物在那里。但是他们知道当前的位置离食物还有多远。那么找到食物的最优策略是什么呢。最简单有效的就是搜寻离食物最近的鸟的周围区域。
粒子群优化算法启示
PSO从这种模型中得到启示并用于解决优化问题。PSO中，每个优化问题的解都是搜索空间中的一只鸟。我们称之为“粒子”。所有的粒子都有一个由被优化的函数决定的适应值(fitnessvalue)，每个粒子还有一个速度决定他们飞翔的方向和距离。然后粒子们就追随当前的最优粒子在解空间中搜索。
粒子群优化算法PSO初始化
PSO初始化为一群随机粒子(随机解)，然后通过迭代找到最优解，在每一次迭代中，粒子通过跟踪两个“极值”来更新自己。第一个就是粒子本身所找到的最优解，这个解叫做个体极值pBest，另一个极值是整个种群找到的最优解，这个极值是全局极值gBest。另外也可以不用整个种群而只是用其中一部分最优粒子的邻居，那么在所有邻居中的极值就是局部极值。
在找到这两个最优值时,粒子根据如下的公式来更新自己的速度和新的位置
(a)
(b)
v[] 是粒子的速度，present[] 是当前粒子的位置。pbest[] 和 gbest[] 如前定义。rand() 是介于(0,1)之间的随机数。c1，c2是学习因子。通常c1=c2=2。
粒子群优化算法伪代码实现
For each particle
____Initialize particle
END
Do
____For each particle
________Calculate fitness value
________If the fitness value is better than the best fitness value (pBest) in history
____________set current value as the new pBest
____End
____Choose the particle with the best fitness value of all the particles as the gBest
____For each particle
________Calculate particle velocity according equation (a)
________Update particle position according equation (b)
____End
While maximum iterations or minimum error criteria is not attained
在每一维粒子的速度都会被限制在一个最大速度Vmax，如果某一维更新后的速度超过用户设定的Vmax，那么这一维的速度就被限定为Vmax。
粒子群优化算法共同点
①种群随机初始化。
②对种群内的每一个个体计算适应值(fitness value)。适应值与最优解的距离直接有关。
③种群根据适应值进行复制。
④如果终止条件满足的话，就停止，否则转步骤② 。
从以上步骤，我们可以看到PSO和遗传算法有很多共同之处。两者都随机初始化种群，而且都使用适应值来评价系统，而且都根据适应值来进行一定的随机搜索。两个系统都不是保证一定找到最优解。但是，PSO没有遗传操作如交叉(crossover)和变异(mutation)，而是根据自己的速度来决定搜索。粒子还有一个重要的特点，就是有记忆。
粒子群优化算法不同点
与遗传算法比较，PSO的信息共享机制是很不同的。在遗传算法中，染色体(chromosomes)互相共享信息，所以整个种群的移动是比较均匀的向最优区域移动。在PSO中, 只有gBest (orlBest) 给出信息给其他的粒子， 这是单向的信息流动。整个搜索更新过程是跟随当前最优解的过程。与遗传算法比较, 在大多数的情况下，所有的粒子可能更快的收敛于最优解。
粒子群优化算法优缺点
演化计算的优势，在于可以处理一些传统方法不能处理的。例子例如不可导的节点传递函数或者没有梯度信息存在。
但是缺点在于：
1.在某些问题上性能并不是特别好。
2.网络权重的编码而且遗传算子的选择有时比较麻烦。
最近已经有一些利用PSO来代替反向传播算法来训练神经网络的论文。研究表明PSO 是一种很有潜力的神经网络算法。PSO速度比较快而且可以得到比较好的结果。而且还没有遗传算法碰到的问题。
粒子群优化算法定义
人工神经网络(ANN)是模拟大脑分析过程的简单数学模型，反向转播算法是最流行的神经网络训练算法。进来也有很多研究开始利用演化计算(evolutionary computation)技术来研究人工神经网络的各个方面。
粒子群优化算法研究方面
演化计算可以用来研究神经网络的三个方面：网络连接权重，网络结构(网络拓扑结构，传递函数)，网络学习算法。
不过大多数这方面的工作都集中在网络连接权重，和网络拓扑结构上。在GA中，网络权重和/或拓扑结构一般编码为染色体(Chromosome)，适应函数(fitness function)的选择一般根据研究目的确定。例如在分类问题中，错误分类的比率可以用来作为适应值。
粒子群优化算法举例
这里用一个简单的例子说明PSO训练神经网络的过程。这个例子使用分类问题的基准函数 (Benchmark function)IRIS数据集。(Iris 是一种鸢尾属植物) 在数据记录中，每组数据包含Iris花的四种属性：萼片长度，萼片宽度，花瓣长度，和花瓣宽度，三种不同的花各有50组数据. 这样总共有150组数据或模式。
我们用3层的神经网络来做分类。有四个输入和三个输出。所以神经网络的输入层有4个节点，输出层有3个节点我们也可以动态调节隐含层节点的数目，不过这里我们假定隐含层有6个节点。我们也可以训练神经网络中其他的参数。不过这里我们只是来确定网络权重。粒子就表示神经网络的一组权重，应该是4*6+6*3=42个参数。权重的范围设定为[-100，100] (这只是一个例子，在实际情况中可能需要试验调整).在完成编码以后，我们需要确定适应函数。对于分类问题，我们把所有的数据送入神经网络，网络的权重有粒子的参数决定。然后记录所有的错误分类的数目作为那个粒子的适应值。我们就利用PSO来训练神经网络来获得尽可能低的错误分类数目。PSO本身并没有很多的参数需要调整。所以在实验中只需要调整隐含层的节点数目和权重的范围以取得较好的分类效果。
从上面的例子我们可以看到应用PSO解决优化问题的过程中有两个重要的步骤: 问题解的编码和适应度函数PSO的一个优势就是采用实数编码, 不需要像遗传算法一样是二进制编码(或者采用针对实数的遗传操作.例如对于问题 f(x) = x1^2 + x2^2+x3^2 求解,粒子可以直接编码为 (x1, x2, x3), 而适应度函数就是f(x). 接着我们就可以利用前面的过程去寻优.这个寻优过程是一个叠代过程, 中止条件一般为设置为达到最大循环数或者最小错误
PSO中并没有许多需要调节的参数,下面列出了这些参数以及经验设置
粒子数: 一般取 20–40. 其实对于大部分的问题10个粒子已经足够可以取得好的结果, 不过对于比较难的问题或者特定类别的问题, 粒子数可以取到100 或 200
粒子的长度: 这是由优化问题决定, 就是问题解的长度
粒子的范围: 由优化问题决定,每一维可是设定不同的范围
Vmax: 最大速度,决定粒子在一个循环中最大的移动距离,通常设定为粒子的范围宽度,例如上面的例子里,粒子 (x1, x2, x3) x1 属于 [-10, 10], 那么 Vmax 的大小就是 20
学习因子: c1 和 c2 通常等于 2. 不过在文献中也有其他的取值. 但是一般 c1 等于 c2 并且范围在0和4之间
中止条件: 最大循环数以及最小错误要求. 例如, 在上面的神经网络训练例子中, 最小错误可以设定为1个错误分类, 最大循环设定为2000, 这个中止条件由具体的问题确定.
全局PSO和局部PSO: 我们介绍了两种版本的粒子群优化算法: 全局版和局部版. 前者速度快不过有时会陷入局部最优. 后者收敛速度慢一点不过很难陷入局部最优. 在实际应用中, 可以先用全局PSO找到大致的结果,再用局部PSO进行搜索.
另外的一个参数是惯性权重, 由Shi 和Eberhart提出, 有兴趣的可以参考他们1998年的论文(题目: A modified particle swarm optimizer)。
操作符语义
每个操作符都有自己的语义，具体取决于它所操作的类型。
[1]
操作符优先级
每个操作符都有优先级。
[1]
操作符结合性
每个操作符都有结合性。
[1] 
操作符的结合性定义了操作符对操作数执行操作的顺序，例如：右结合性表示该操作符对其操作数从右向左执行操作。
指令系统的每一条指令都有一个操作符，它表示该指令应进行什么性质的操作。不同的指令用操作符这个字段的不同编码来表示，每一种编码代表一种指令。组成操作符字段的位数一般取决于计算机指令系统的规模。
1.java操作符
2.c语言操作符
3.c++操作符
4.c#操作符
5.perl操作符
6.python操作符
7.javascript操作符
8.位操作符
9.布尔操作符
10.作用域操作符
11.一元操作符
12.二元操作符
13.三元操作符
以下以操作符+为例说明：
用户定义的类型，如：字符串，日期，复数，联合体以及文件常常重载，二元操作符以实现对象的连接，附加或合并机制。但是要正确实现操作符会给设计，实现和性能带来一定的挑战 。
内建的 操作符有两个类型相同的操作数，相加并返回右值 6，然后被赋值给 x。我们可以断定内建的是一个二元的，对称的，可交换的操作符。它产生的结果的类型与其操作数类型相同。按照这个规测，当你为某个用户定义类型重载操作符时，也应该遵循相应内建操作符的特征。
下面我们就来分析内建操作符的特征并尝试模仿其相应的重载机制。
第一步：在成员函数和非成员函数之间选择
你可以用类成员函数的方式实现二元操作符如：+、- 以及 ==，例如：class String {public: bool operator==(const String & s); // 比较 *this 和 s};
这个方法是有问题的。相对于其内建的操作符来说，重载的操作符在这里不具有对称性；它的两个参数一个类型为：const String * const（这个参数是隐含的），另一个类型为：const String &。因此，一些 STL 算法和容器将无法正确处理这样的对象。
另外一个可选方法是把重载操作符 + 定义为一个外部（extern）函数，该函数带两个类型相同的参数：
String operator + (const String & s1, const String s2);
这样一来，类 String 必须将该重载操作符声明为友元：
class String{public: friend String operator+(const String& s1,const String&s2);};
第二步：返回值的两难选择
如前所述，内建操作符 + 返回右值，其类型与操作数相同。但是在调用者堆栈里返回一个对象效率很低，处理大型对象时尤其如此。那么能不能返回一个指针或引用呢？答案是不行。因为返回指针破坏参数类型与返回值类型应该相同的规则。更糟的是，链接多个表达式将成为不可能：
String s1,s2,s3; String res;res=s1+s2+s3; // 不可能用 String* 作为返回值
虽然有一个办法可以定义额外的 + 操作符重载版本，但这个办法是我们不希望用的，因为返回的指针必须指向动态分配的对象。这样的话，如果调用者释放（delete）返回的指针失败，那么将导致内存泄漏。显然，返回 String* 不是一个好主意。
那么返回 String& 好不好呢？返回的引用必须一定要是一个有效的 String。它避免了使用动态对象分配，该方法返回的是一个本地静态对象的引用。静态对象确实解决了内存泄漏问题，但这个方法的可行性仍然值得怀疑。在一个多线程应用中，两个线程可能会并发调用 + 操作符，因此造成 String 对象的混乱。而且，因为静态对象总是保留其调用前的状态，所以有必要针对每次 + 操作符的调用都清除该静态 String 对象。由此看来，在堆栈上返回结果仍然是最安全和最简单的解决方案。
操作符比较操作符
相等：相等操作符在SQL语句里比较一个值与另一个值，等号（=）表示相等。在进行相等比较时，被比较的值必须完全匹配，否则就不会返回数据。如果在相等比较过程中两个值相等，那么这个比较的返回值就是true，否则就是false。这个布尔值（true或false）用于决定是否返回数据。
不相等：在SQL里表示不相等的操作符是<>（一个小于号和一个大于号）。如果两个值不相等，条件就返回true，否则就返回false。另一种表示不相等的方式是！=，而且很多主要的SQL实现采用这种方式。
小于：<
大于：>
比较操作符的组合：等号可以与小于号和大于号联合使用。
操作符逻辑操作符
用户对SQL关键字而不是符号进行比较。
is null：这个操作符用于与null值进行比较。
between：操作符between用于寻找位于一个给定最大值和最小值之间的值，这个最大值和最小值是包含在内的。between是包含边界值的，所以查询结果里会包含指定的最大值和最小值。
in：操作符in用于把一个值与一个指定列表进行比较，当被比较的值至少与列表中一个值相匹配时，它会返回true。使用操作符in可以得到操作符or一样的结果，但它的速度更快。
like：操作符like利用通配符把一个值与类似的值进行比较，通配符有两个：百分号（%）；下划线（_）。百分号代表零个、一个或多个字符；下划线( _ )代表一个数字或字符。
exists：这个操作符用于搜索指定表里是否存在满足特定条件的记录。
all：操作符all用于把一个值与另一个集合里全部值进行比较。
any/some：操作符any用于把一个值与另一个列表里任意值进行比较。some是any的别名，它们可以互换使用。
操作符连接操作符
如果想在SQL语句里利用多个条件来缩小数据范围，我们就需要组合多个条件。这正是连接操作符的功能。
and：操作符and让我们可以在一条SQL语句的where子句里使用多个条件。在使用and时，无论SQL语句是事务操作还是查询，所有由and连接的条件都必须为true，SQL语句才会实际执行。
or：操作符or可以在SQL语句的where子句中连接多个条件，这时无论SQL语句是事务操作还是查询，只要or连接的条件里有至少一个是true，SQl语句就会执行。
注意：比较操作符和逻辑操作符都可以单独或彼此复合使用。
提示：当SQL语句里包含多个条件和操作符时，利用圆括号把语句按照逻辑关系进行划分可以提高语句的可读性。当然，不恰当地使用圆括号也会影响输出结果。
操作符求反操作符
操作符not可以颠倒逻辑操作符的含义，它可以与其他操作符构成以下几种形式：
not equal：不相等
not between：操作符between的求反
not in：操作符in的求反
not like：操作符like的求反
is not null：操作符is null的求反
not exists：操作符exists的求反
not unique：操作符distinct的求反
操作符算术操作符
加法（+）
减法（-）
乘法（*）
除法（/）
算术操作符可以彼此组合使用，并且遵循基本算数运算中的优先级：首先执行乘法和除法，然后是加法和减法。用户控制算术运算次序的唯一方式是使用圆括号，圆括号里包含的表达式会被当作一个整体进行优先求值。
在求解一个输入规模为n，而n的取值又很大的问题时，直接求解往往非常困难。这时，可以先分析问题本身所具有的某些特性，然后从这些特性出发，选择某些适当的设计策略来求解。这种方法，就是所谓的分治法。
采用分治法解决的问题一般具有的特征如下：
1. 问题的规模缩小到一定的规模就可以较容易地解决。
2. 问题可以分解为若干个规模较小的模式相同的子问题，即该问题具有最优子结构性质。
3. 合并问题分解出的子问题的解可以得到问题的解。
4. 问题所分解出的各个子问题之间是独立的，即子问题之间不存在公共的子问题。
1. 划分步：把输入的问题划分为k个子问题，并尽量使这k个子问题的规模大致相同。
2. 治理步：当问题的规模大于某个预定的阈值n0时，治理步由k个递归调用组成。
3. 组合步：组合步把各个子问题的解组合起来，它对分治算法的实际性能至关重要，算法的有效性很大地依赖于组合步的实现。
分治法的关键是算法的组合步。究竟应该怎样合并，没有统一的模式，因此需要对具体问题进行具体分析，以得出比较好的合并算法。
通常，在分析一个算法的计算复杂性时，一般将加法和乘法运算当作是基本运算来处理，即将执行一次加法或乘法运算所需的计算时间，看作一个仅仅取决于计算机硬件处理速度的常数。
然而，在有些情况下，需要处理数值很大的整数，这些数值无法在计算机硬件能直接表示的范围内进行处理。如果要精确地表示大整数的数值并在计算结果中要求精确地得到所有位数上的数字，就必须用软件的方法来实现大整数的算术运算，即用分治法实现大整数的运算。另外，分治法实现大整数运算，可以大大提高运算效率。
设两个n（na，nb）位d进制数A、B相乘：
当位数n为偶数时，将数拆分为两段等长的数段，高位段为H，低位段为L，则有
A=Ha*d^(n/2)+La B=Hb*d^(n/2)+Lb
当位数n为奇数时，可在数的首位前添0，使数的位数为偶数，然后将数拆分为两段等长的数段。
例如，计算2进制数1010与1110的乘积。步骤如下：
（1）：1010=10*2^(2)+10 1110=11*2^(2)+10
（2）：1010*1110=（10*2^(2)+10）*（11*2^(2)+10）=10*11*2^(4)+10*11*2^(2)+10*10*2^(2)+10*10
（3）：1010*1110=（1*2^(1)+0）*（1*2^(1)+1）*2^(4)+（1*2^(1)+0）*（1*2^(1)+1）*2^(2)+（1*2^(1)+0）*（1*2^(1)+0）*2^(2)+（1*2^(1)+0）*（1*2^(1)+0）=2*3*16+2*3*4+2*2*4+2*2=140
B+树在节点访问时间远远超过节点内部访问时间的时候，比可作为替代的实现有着实在的优势。这通常在多数节点在次级存储比如硬盘中的时候出现。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。这种价值得以确立通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。
[1]
B+背后的想法是内部节点可以有在预定范围内的可变数目的子节点。因此，B+树不需要象其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。
[1]
B+ 树的创造者Rudolf Bayer没有解释B代表什么。最常见的观点是B代表平衡(balanced)，因为所有的叶子节点在树中都在相同的级别上。B也可能代表Bayer，或者是波音（Boeing），因为他曾经工作于波音科学研究实验室。
[1]
B+树是B树的一种变形形式，B+树上的叶子结点存储关键字以及相应记录的地址，叶子结点以上各层作为索引使用。一棵m阶的B+树定义如下:
[2]
(1)每个结点至多有m个子女；
[2]
(2)除根结点外，每个结点至少有[m/2]个子女，根结点至少有两个子女；
[2]
(3)有k个子女的结点必有k个关键字。
[2]
B+树的查找与B树不同，当索引部分某个结点的关键字与所查的关键字相等时，并不停止查找，应继续沿着这个关键字左边的指针向下，一直查到该关键字所在的叶子结点为止。
[2]
在 B+ 树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的序数（order）是m ，则除了根之外的每个节点都包含最少



 个元素最多 m-1 个元素，对于任意的节点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。因为所有叶子都在相同的高度上，节点通常不包含确定它们是叶子还是内部节点的方式。
[1]
每个内部节点的元素充当分开它的子树的分离值。例如，如果内部节点有三个子节点（或子树）则它必须有两个分离值或元素a1和a2。在最左子树中所有的值都小于等于a1，在中间子树中所有的值都在a1和a2之间((a1，a2]），而在最右子树中所有的值都大于a2。
[1]
B+树是B树的一种变形，比B树具有更广泛的应用，m阶 B+树有如下特征:
[3]
(1)每个结点的关键字个数与孩子个数相等，所有非最下层的内层结点的关键字是对应子树上的最大关键字，最下层内部结点包含了全部关键字。
[3]
(2)除根结点以外，每个内部结点有



 到m个孩子。
[3]
(3)所有叶结点在树结构的同一层，并且不含任何信息(可看成是外部结点或查找失败的结点)，因此，树结构总是树高平衡的。
[3]
B+树查找
查找以典型的方式进行，类似于二叉查找树。起始于根节点，自顶向下遍历树，选择其分离值在要查找值的任意一边的子指针。在节点内部典型的使用是二分查找来确定这个位置。
[1]
B+树插入
节点要处于违规状态，它必须包含在可接受范围之外数目的元素。
[1]
首先，查找要插入其中的节点的位置。接着把值插入这个节点中。
[1] 

如果没有节点处于违规状态则处理结束。
[1] 

如果某个节点有过多元素，则把它分裂为两个节点，每个都有最小数目的元素。在树上递归向上继续这个处理直到到达根节点，如果根节点被分裂，则创建一个新根节点。为了使它工作，元素的最小和最大数目典型的必须选择为使最小数不小于最大数的一半。
[1]
B+树删除
首先，查找要删除的值。接着从包含它的节点中删除这个值。
[1] 

如果没有节点处于违规状态则处理结束。
[1] 

如果节点处于违规状态则有两种可能情况：
[1] 

它的兄弟节点，就是同一个父节点的子节点，可以把一个或多个它的子节点转移到当前节点，而把它返回为合法状态。如果是这样，在更改父节点和两个兄弟节点的分离值之后处理结束。
[1] 

它的兄弟节点由于处在低边界上而没有额外的子节点。在这种情况下把两个兄弟节点合并到一个单一的节点中，而且我们递归到父节点上，因为它被删除了一个子节点。持续这个处理直到当前节点是合法状态或者到达根节点，在其上根节点的子节点被合并而且合并后的节点成为新的根节点。
[1]
B+树是应文件系统所需而产生的一种B-树的变形树。一棵m阶的B+树和m阶的B树的差异在于:
[4] 

(1)有n棵子树的结点中含有n个关键码；
[4] 

(2)所有的叶子结点中包含了全部关键码的信息，及指向含有这些关键码记录的指针，且叶子结点本身依关键码的大小自小而大的顺序链接；
[4] 

(3)所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大(或最小)关键码。
[4]
线性表定义
线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。
在稍复杂的线性表中，一个数据元素可由多个数据项（item）组成，此种情况下常把数据元素称为记录（record），含有大量记录的线性表又称文件（file）。
线性表中的个数n定义为线性表的长度，n=0时称为空表。在非空表中每个数据元素都有一个确定的位置，如用ai表示数据元素，则i称为数据元素ai在线性表中的位序。
线性表的相邻元素之间存在着序偶关系。如用（a1，…，ai-1，ai，ai+1，…，an）表示一个顺序表，则表中ai-1领先于ai，ai领先于ai+1，称ai-1是ai的直接前驱元素，ai+1是ai的直接后继元素。当i=1,2，…，n-1时，ai有且仅有一个直接后继，当i=2，3，…，n时，ai有且仅有一个直接前驱
[1] 
。
线性表分类
我们说“线性”和“非线性”，只在逻辑层次上讨论，而不考虑存储层次，所以双向链表和循环链表依旧是线性表。
在数据结构逻辑层次上细分，线性表可分为一般线性表和受限线性表。一般线性表也就是我们通常所说的“线性表”，可以自由的删除或添加结点。受限线性表主要包括栈和队列，受限表示对结点的操作受限制。
线性表优点
线性表的逻辑结构简单，便于实现和操作。因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。
1．集合中必存在唯一的一个“第一元素”。
2．集合中必存在唯一的一个 “最后元素” 。
3．除最后一个元素之外，均有唯一的后继(后件)。
4．除第一个元素之外，均有唯一的前驱(前件)。
1）MakeEmpty(L) 这是一个将L变为空表的方法
2）Length（L） 返回表L的长度，即表中元素个数
3）Get（L，i） 这是一个函数，函数值为L中位置i处的元素（1≤i≤n）
4）Prior（L，i） 取i的前驱元素
5）Next（L，i） 取i的后继元素
6）Locate（L，x） 这是一个函数，函数值为元素x在L中的位置
7）Insert（L，i，x）在表L的位置i处插入元素x，将原占据位置i的元素及后面的元素都向后推一个位置
8）Delete（L，p） 从表L中删除位置p处的元素
9）IsEmpty(L) 如果表L为空表(长度为0)则返回true，否则返回false
10）Clear（L）清除所有元素
11）Init（L）同第一个，初始化线性表为空
12）Traverse（L）遍历输出所有元素
13）Find（L，x）查找并返回元素
14）Update（L，x）修改元素
15）Sort（L）对所有元素重新按给定的条件排序
16) strstr(string1,string2)用于字符数组的求string1中出现string2的首地址
线性表主要由顺序表示或链式表示。在实际应用中，常以栈、队列、字符串等特殊形式使用。
顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，称为线性表的顺序存储结构或顺序映像（sequential mapping）。它以“物理位置相邻”来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。
链式表示指的是用一组任意的存储单元存储线性表中的数据元素，称为线性表的链式存储结构。它的存储单元可以是连续的，也可以是不连续的。在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置），这两部分信息组成数据元素的存储映像，称为结点（node）。它包括两个域；存储数据元素信息的域称为数据域；存储直接后继存储位置的域称为指针域。指针域中存储的信息称为指针或链
[1] 
。
1.均匀性：虽然不同数据表的数据元素可以是各种各样的，但对于同一线性表的各数据元素必定具有相同的数据类型和长度。
2.有序性：各数据元素在线性表中的位置只取决于它们的序号，数据元素之前的相对位置是线性的，即存在唯一的“第一个“和“最后一个”的数据元素，除了第一个和最后一个外，其它元素前面均只有一个数据元素(直接前驱)和后面均只有一个数据元素（直接后继）。
时间有序表、排序表、和频率有序表都可以看做是线性表的推广。如果按照结点到达结构的时间先后，作为确定结点之间关系的，这样一种线性结构称之为时间有序表。例如，在红灯前停下的一长串汽车，最先到达的为首结点，最后到达的为尾结点；在离开时最先到达的汽车将最先离开，最后到达的将最后离开。这些汽车构成了一个队列，实际上就是一个时间有序表。栈和队列都是时间有序表。频率有序表是按照结点的使用频率确定它们之间的相互关系的，而排序表是根据结点的关键字值来加以确定的。
[2]
在图论中，如果一个有向图无法从某个顶点出发经过若干条边回到该点，则这个图是一个有向无环图（DAG图）。
因为有向图中一个点经过两种路线到达另一个点未必形成环，因此有向无环图未必能转化成树，但任何有向树均为有向无环图。




有向无环图
一个无环的有向图称做有向无环图（Directed Acyclic Graph）。简称DAG 图。DAG 图是一类较有向树更一般的特殊有向图，如图 给出了有向树、DAG 图和有向图的例子。
[1]
有向树、DAG 图和有向图的示例
有向无环图是描述含有公共子式的表达式的有效工具。例如下述表达式：
((a+b)*b*(c+d)+(c+d)*e)*(c+d)*e
可以用第六章讨论的二叉树来表示，如图1 所示。仔细观察该表达式，可发现有一些相同的子表达式，如(c+d)和(c+d)*e 等，在二叉树中，它们也重复出现。若利用有向无环图，则可实现对相同子式的共享，从而节省存储空间。例如图2 所示为表示同一表达式的有向无环图。
用二叉树描述表达式
检查一个有向图是否存在环要比无向图复杂。对于无向图来说，若深度优先遍历过程中遇到回边（即指向已访问过的顶点的边），则必定存在环；而对于有向图来说，这条回边有可能是指向深度优先生成森林中另一棵生成树上顶点的弧。但是，如果从有向图上某个顶点v 出发的遍历，在dfs(v)结束之前出现一条从顶点u 到顶点v 的回边，由于u 在生成树上是v 的子孙，则有向图必定存在包含顶点v 和u 的环。
有向无环图是描述一项工程或系统的进行过程的有效工具。除最简单的情况之外，几乎所有的工程（project）都




描述表达式的有向无环图

可分为若干个称作活动（activity）的子工程，而这些子工程之间，通常受着一定条件的约束，如其中某些子工程的开始必须在另一些子工程完成之后。　　对整个工程和系统，人们关心的是两个方面的问题：一是工程能否顺利进行：二是估算整个工程完成所必须的最短时间。这样两个问题都是可以通过对有向图进行拓扑排序和关键路径操作来解决的。


对于任意一个序列以及一个给定的元素，将给定元素与序列中元素依次比较，直到找出与给定关键字相同的元素，或者将序列中的元素与其都比较完为止。
顺序查找Java
package search;
/*顺序查找
* des 要查找的元素
* i 保存当前元素的下标
*/
public class OrderSearch {
public static int ordersearch(int[] arry,int des){
int i=0;
for(;i<=arry.length-1;i++){
if(des==arry[i])
return i;
}
return -1;
}
public static void main(String[] args){
int[] a=new int[]{2,3,5,6,7,3,};
System.out.println(ordersearch(a,3));
}
}
顺序查找C
int sq_search(keytype keyp[],int n,keytype key)
{
int i;
for(i=0; i<n; i++)
if(key[i] == key)
return i;//查找成功
return -1;//查找失败
}
顺序查找C++
int Seqsch(ElemType A[ ],int n,KeyType K)
{
//从顺序表A的n个元素中顺序查找关键字为K的元素，若成功返回其下标，否则返回-1
int i;
for( i=0;i<n;i++){
if(A[i].key==K)
break;
}
if(i<=n-1) //查找成功返回下标，否则返回-1
return i;
elsereturn -1;}
php实现方法
function seq_sch($array, $n, $k) 
{ 　
for($i=0; $i<$n; $i++) 
{ 　
if( $array[$i]==$k)　
break; 　
} 　
if ($i<$n) 
{ 　
return $i; 　
}
else
{ 　
return -1; 　
} 　
}
顺序查找python
# 最基本的查找算法，
# 基本原理：
# 对于任意一个序列以及一个给定元素，将给定元素与序列中元素依次比较，直到找出与给定关键字相同的数为止

import random
Range = 10
Length = 5
flag = 0
pos = -1

list = random.sample(range(Range),Length)
goal = random.randint(0,Range)
print('search ',goal,', in list:',list)

for i in range(Length):
    if list[i] == goal:
        flag = 1
        pos = i
        break

if flag:
    print('find in ',pos+1,'th place')
else:
    print('not found')
求线性目标函数在线性约束条件下的最大值或最小值的问题，统称为线性规划问题。可行解亦称可行点或允许解，数学规划的基本概念之一，指在数学规划问题中，满足所有约束条件的解（点）。
[1]
(basic feasible solution)
基本可行解亦称可行点或允许解，是线性规划的重要概念。在线性规划问题中，满足非负约束条件的基本解，称基本可行解，简称基可行解。线性规划问题如果有可行解，则必有基可行解，可行解是基可行解的充分必要条件为：它的非零分量所对应的系数矩阵列向量是线性无关的。基本可行解与可行域中的极点相对应，为有限个。若存在有界最优解，则至少有一个基本可行解为最优解。
在约束方程组系数矩阵中找到一个基，令这个基的非基变量为零，再求解这个m元线性方程组就可得到唯一的解，这个解称之为线性规划的基本解。
最优解通常定义为不牺牲任何总目标和各分目标的条件下，技术上能够达到的最好的解。它表示所有的总目标和分目标都可以达到的理想的解。而实际上这样的解是很少存在的。工程问题固有的内在因素总是包含各种矛盾的，由于科学水平的限制，很多设计因素和系统的约束还不是很了解;许多判别准则。例如： 社会上的相互关系、生活的质量、生态学，以及兴趣、爱好等等，是不容易确定的，更不容易定量化。而工程系统的设计问题或规划问题中劳动力、设备、财力以及时间总是有限的。所以，最优化过程只是产生一个在设计和工艺约束条件下所能达到的“最令人满意解”。
可行解是满足约束条件的解，基本解对应基向量的非基变量为零，基解不一定为可行解，可行解也不一定为基解，既是可行解又是基本解的解是基本可行解，最优解是基本可行解中使目标函数达到最优的解。
主要内容包括蚁群算法基本原理、蚁群算法在TSP及其扩展问题求解中的应用、蚁群算法在VRP及其扩展问题求解中的应用、蚁群算法在最优树问题求解中的应用、蚁群算法在整数规划问题求解中的应用、一般连续优化问题的蚁群算法以及多目标蚁群算法等。书中还给出了一些主要算法的Delphi程序实现源代码，可供参考或修改使用。
本书可供运筹学、管理科学、系统工程、计算机科学等有关专业的高校师生、科研人员和工程技术人员阅读参考。
[1]
第1章 引论
1.1 组合优化与计算复杂性
1.2 来自自然界的几类优化方法
第2章 蚁群算法原理
2.1 基本思想
2.2研究概况
第3章 标准TSP的蚁群算法
3.1 TSP概述
3.2 经典方法
3.3 遗传算法与模拟退火法
3.4　蚁群算法
3.5 元胞蚁群算法及其收敛性
第4章 扩展旅行商问题的蚁群算法
4.1 瓶颈TSP及其求解
4.2 最小比率TSP及其求解
4.3 时间约束TSP及其求解
4.4 多目标TSP及其求解
第5章 车辆路径问题的蚁群算法
5.1 VRP概述
5.2 CVRP及其求解
5.3 多目标VRP及其求解
5.4 VRPTW及其求解
5.5 VRPSTW及其求解
5.6 FVRP及其求解
第6章 最优树问题的蚁群算法
6.1 度约束最小树问题及其求解
6.2 Steiner最小树问题及其求解
6.3 Min-Max度最优树问题与多目标最小树问题
第7章 整数规划问题的蚁群算法
7.1 0-1规划问题及其求解
7.2 背包问题及其求解
7.3 多目标0-1规划问题及其求解
7.4 一般整数规划问题及其求解
第8章 连续优化问题的蚁群算法
8.1 基本蚁群算法
8.2 元胞蚁群算法
8.3 平面选址问题及其求解
8.4 多目标优化问题及其求解
第9章 其他优化问题的蚁群算法
9.1 二次分配问题及其求解
9.2 图着色问题及其求解
9.3 多目标最短路及其求解
参考文献
附录 中国144城市相对坐标数据
后记
《运筹与管理科学丛书》已出版书目
还指同一杯咖啡中所并存的不同层次的特色，复杂度高，表示可以感受到的感官刺激种类较多；要注意的是这些感觉包括了馀韵，不一定限制于喝时的当下感受。
复杂度（计算机复杂性理论）
计算复杂性理论（Computational complexity theory）是计算理论的一部分，研究计算问题时所需的资源，比如时间和空间，以及如何尽可能的节省这些资源。
计算复杂性理论所研究的资源中最常见的是时间复杂度（要通过多少步才能解决问题）和空间复杂度（在解决问题时需要多少内存）。其他资源亦可考虑，例如在并行计算中，需要多少并行处理器才能解决问题。
时间复杂度是指在计算机科学与工程领域完成一个算法所需要的时间，是衡量一个算法优劣的重要参数。时间复杂度越小，说明该算法效率越高，则该算法越有价值。
空间复杂度是指计算机科学领域完成一个算法所需要占用的存储空间，一般是输入参数的函数。它是算法优劣的重要度量指标，一般来说，空间复杂度越小，算法越好。我们假设有一个图灵机来解决某一类语言的某一问题，设有X个字（word）属于这个问题，把X放入这个图灵机的输入端，这个图灵机为解决此问题所需要的工作带格子数总和称为空间。
复杂度理论和可计算性理论不同，可计算性理论的重心在于问题能否解决，不管需要多少资源。而复杂性理论作为计算理论的分支，某种程度上被认为和算法理论是一种“矛”与“盾”的关系，即算法理论专注于设计有效的算法，而复杂性理论专注于理解为什么对于某类问题，不存在有效的算法。
复杂度(Complexity, CPX)
[1] 
 ：
复杂度的概念首先是由Kolmgorov提出来的。简明说就是一件事物的复杂性可以用描写这事物所用的计算机语言的长度来衡量。一般认为描述一件事物的计算机语言的长度越长，该事物就越复杂。70年代Lemple等在信息理论的研究中对随机序列复杂性给出了定义， 认为复杂性反映了一个时间序列随其长度的增加出现新模式的速率， 表现了序列接近随机的程度。80年代末期Kasper 等对随机序列Lem-Ziv意义下的复杂度进行了研究，提出了随机序列复杂性测度的具体算法。这套算法得到的复杂性测度被称为Kc复杂度，并且指出此算法比Lyapunov指数优越。由于复杂度分析方法对序列的长度要求不严格，因此在信号处理领域应用较广。
计算Kc之前，首先将要处理的序列进行粗粒化，在此对随机序列进行二值化处理，就是将序列的每一个点都由一个比特位来代表，于是就可以将所研究的信号信息粗粒化形成一个“0，1”序列。假设要处理的时间传输序列为{xi)(i=1，2，…，n)，求得平均值。如果xi≥平均值，令xi=1；如果xi<平均值，令xi=0；然后将这些0，1点组成原来序列的简化序列。
Kc的计算即找出序列x中所含的模式数，具体方法是通过一个“0，1”时间序列中的一串字符s(s1，s2，．．．，s。)后再加一个或一串字符Q，看字符Q是否属于SQv(SQv是SQ字符串中减去最后一个字符而得到的)，如果出现的字句在前面已经有过，即Q是sQ咛的一个子串，则该字符称为“复制”，认为这个过程没有新模式出现，把该字符加在串的后面，继续增长Q，再进行判断；若它没有出现过，那么对这个字符进行“插入”，“插入”时用一个“·”把前后字符分开，认为出现了一个新的模式：然后把最后一个“·”前面所有字符看成s，重新构造Q，再重复上述操作直到该序列结束并计算发现的模式数的总和。例如序列(0010)的复杂度可由下面的步骤得出：
(1)第一个字符永远是插入0·；
(2) S=0，Q=0，SQ=00，SQv=0，Q属于字句SQv，0·0；
(3)s=0，Q=01，sQ=001，sQv=00，Q不属于字句sQv，0·01·；
(4) S=001，Q=0，SQ=0010，SQv=001，Q属于字句SQv，0·01·0。
于是得出该序列的模式数为3，即复杂度c(4)=3。符号序列0000…应是最简单的，0·000…，c(n)=2。另外，如010101…应是0.1.0101…，c(n)=3。
如上所述，用“·”将字符串分成了段，段的数目就定义为复杂度c(n)，几乎所有的“0，1”序列的c(n)都趋向于一个定值，即：
limc(n)=b(n) = n/ln(n)
所以，b(n)是随机序列的渐进行为，可利用它使c(n)归一化，成为相对复杂度：
C(n) = c(n)/b(n)
用这种函数来表达时间序列的复杂变化，可以看出完全随机的序列的C(n)趋于1，其他规律的和周期的运动则趋于0，而不完全随机序列的c(n)介于二者之间。
粗粒化的过程并不一定局限于二值化，也可以用四值化(孙红 et al.2002)或者称作细粒化的方法(陈宏伟and陈亚珠，2004)，这样的结果比粗粒化复杂度更为精确。
冒泡排序算法的原理如下：
[1]
比较相邻的元素。如果第一个比第二个大，就交换他们两个。
[1] 

对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
[1] 

针对所有的元素重复以上的步骤，除了最后一个。
[1] 

持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。
[1]
冒泡排序流程图
冒泡排序时间复杂度
若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数



 和记录移动次数



 均达到最小值：



 ，



 。
[1]
所以，冒泡排序最好的时间复杂度为



 。　　若初始文件是反序的，需要进行



 趟排序。每趟排序要进行



 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
[1]


冒泡排序的最坏时间复杂度为



 。
[1]
综上，因此冒泡排序总的平均时间复杂度为



 。
[1]
冒泡排序算法稳定性
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。
[1]
冒泡排序C语言
#include <stdio.h>

#define ARR_LEN 255 /*数组长度上限*/
#define elemType int /*元素类型*/

/* 冒泡排序 */
/* 1. 从当前元素起，向后依次比较每一对相邻元素，若逆序则交换 */
/* 2. 对所有元素均重复以上步骤，直至最后一个元素 */
/* elemType arr[]: 排序目标数组; int len: 元素个数 */
void bubbleSort (elemType arr[], int len) {
    elemType temp;
    int i, j;
    for (i=0; i<len-1; i++) /* 外循环为排序趟数，len个数进行len-1趟 */
        for (j=0; j<len-1-i; j++) { /* 内循环为每趟比较的次数，第i趟比较len-i次 */
            if (arr[j] > arr[j+1]) { /* 相邻元素比较，若逆序则交换（升序为左大于右，降序反之） */
                temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
}

int main (void) {
    elemType arr[ARR_LEN] = {3,5,1,-7,4,9,-6,8,10,4};
    int len = 10;
    int i;
    
    bubbleSort (arr, len);
    for (i=0; i<len; i++)
        printf ("%d\t", arr[i]);
    putchar ('\n');
    
    return 0;
}
冒泡排序Visual Fox Pro语言
?'Original Array ' + CHR(43147)
DIMENSION arr(10)
FOR i = 1 TO 10
    arr(i) = ROUND(rand()*100,0)
ENDFOR
DISPLAY MEMORY LIKE arr
?'After Sort ' + CHR(43147)
FOR i = 1 TO 10
    FOR j = 1 TO 10 - i
        IF arr(j) > arr(j + 1)
            lnTemp = arr(j)
            arr(j) = arr(j + 1)
            arr(j + 1) = lnTemp
        ENDIF
    ENDFOR
ENDFOR
DISPLAY MEMORY LIKE arr
冒泡排序Python3
def bubble_sort(nums):
    for i in range(len(nums) - 1):  # 这个循环负责设置冒泡排序进行的次数
        for j in range(len(nums) - i - 1):  # j为列表下标
            if nums[j] > nums[j + 1]:
                nums[j], nums[j + 1] = nums[j + 1], nums[j]
    return nums

print(bubble_sort([45, 32, 8, 33, 12, 22, 19, 97]))
# 输出：[8, 12, 19, 22, 32, 33, 45, 97]
冒泡排序Swift
func bubbleSort(_ nums: inout [Int]) {
    let n = nums.count
    for i in 0..<n {
        for j in 0..<(n - 1 - i) {
            if nums[j] > nums[j + 1] {
                nums.swapAt(j, j + 1)
            }
        }
    }
    print(nums)
}

var nums = [1,3,7,8,9]
bubbleSort(&nums)
冒泡排序C++
C++语言程序示例如下
#include <iostream>
using namespace std;
template<typename T>
//整数或浮点数皆可使用
void bubble_sort(T arr[], int len)
{
    int i, j;  T temp;
    for (i = 0; i < len - 1; i++)
        for (j = 0; j < len - 1 - i; j++)
        if (arr[j] > arr[j + 1])
        {
            temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
}
int main()
{
    int arr[] = { 61, 17, 29, 22, 34, 60, 72, 21, 50, 1, 62 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    bubble_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';

    cout << endl;

    float arrf[] = { 17.5, 19.1, 0.6, 1.9, 10.5, 12.4, 3.8, 19.7, 1.5, 25.4, 28.6, 4.4, 23.8, 5.4 };
    len = (int) sizeof(arrf) / sizeof(*arrf);
    bubble_sort(arrf, len);
    for (int i = 0; i < len; i++)
        cout << arrf[i] << ' ';

    return 0;
}
冒泡排序RUBY
def bubbleSort(array)
    return array if array.size < 2
    (array.size - 2).downto(0) do |i|
        (0 .. i).each do |j|
            array[j], array[j + 1] = array[j + 1], array[j] if array[j] >= array[j + 1]
        end
    end
    return array
end
冒泡排序PHP
function bubbleSort($numbers) {
    $cnt = count($numbers);
    for ($i = 0; $i < $cnt - 1; $i++) {
        for ($j = 0; $j < $cnt - $i - 1; $j++) {
            if ($numbers[$j] > $numbers[$j + 1]) {
                $temp = $numbers[$j];
                $numbers[$j] = $numbers[$j + 1];
                $numbers[$j + 1] = $temp;
            }
        }
    }

    return $numbers;
}

$num = array(20, 40, 60, 80, 30, 70, 90, 10, 50, 0);
var_dump(bubbleSort($num));

//输出结果如下：
//array(10) {
//  [0]=>
//  int(0)
//  [1]=>
//  int(10)
//  [2]=>
//  int(20)
//  [3]=>
//  int(30)
//  [4]=>
//  int(40)
//  [5]=>
//  int(50)
//  [6]=>
//  int(60)
//  [7]=>
//  int(70)
//  [8]=>
//  int(80)
//  [9]=>
//  int(90)
//}
冒泡排序C#语言
冒泡算法C#
namespace 数组排序
{
    class Program
    {
        static void Main(string[] args)
        {
            int temp = 0;
            int[] arr = {23, 44, 66, 76, 98, 11, 3, 9, 7};
            #region该段与排序无关
            Console.WriteLine("排序前的数组：");
            foreach (int item in arr)
            {
                Console.Write(item + "");
            }
            Console.WriteLine();
            #endregion
            for (int i = 0; i < arr.Length - 1; i++)
            {
                #region将大的数字移到数组的arr.Length-1-i
                for (int j = 0; j < arr.Length - 1 - i; j++)
                {
                    if (arr[j] > arr[j + 1])
                    {
                        temp = arr[j + 1];
                        arr[j + 1] = arr[j];
                        arr[j] = temp;
                    }
                }
            #endregion
            }
            Console.WriteLine("排序后的数组：");
            foreach (int item in arr)
            {
                Console.Write(item+"");
            }
            Console.WriteLine();
            Console.ReadKey();
        }
    }
}
冒泡排序Erlang
bubble_sort(L)->
bubble_sort(L,length(L)).

bubble_sort(L,0)->
L;
bubble_sort(L,N)->
bubble_sort(do_bubble_sort(L),N-1).

do_bubble_sort([A])->
[A];
do_bubble_sort([A,B|R])->
caseA<Bof
true->[A|do_bubble_sort([B|R])];
false->[B|do_bubble_sort([A|R])]
end.
冒泡排序JAVA
public static void bubbleSort(int arr[]) {

        for(int i =0 ; i<arr.length-1 ; i++) { 
          
            for(int j=0 ; j<arr.length-1-i ; j++) {  

                if(arr[j]>arr[j+1]) {
                    int temp = arr[j];
                    
                    arr[j]=arr[j+1];
                    
                    arr[j+1]=temp;
            }
            }    
        }
    }
冒泡排序Kotlin
fun bubbleSort(array: Array<Int>) { 
   val arrayLength = array.size    
   for (i in 0 until arrayLength) {        
       for (j in 0 until arrayLength - i - 1) {            
           if (array[j] > array[j + 1]) {                
               val temp = array[j]                
               array[j] = array[j + 1]                
               array[j + 1] = temp           
           }       
       }   
   }   
   // Prints result.
}
冒泡排序JavaScript
function bubbleSort(arr) {
    var i = arr.length, j;
    var tempExchangVal;
    while (i > 0) {
        for (j = 0; j < i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                tempExchangVal = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tempExchangVal;
            }
        }
        i--;
    }
    return arr;
}

var arr = [3, 2, 4, 9, 1, 5, 7, 6, 8];
var arrSorted = bubbleSort(arr);
console.log(arrSorted);
alert(arrSorted);
控制台将输出：[1, 2, 3, 4, 5, 6, 7, 8, 9]
并且弹窗；
冒泡排序Visual Basic语言
Sub maopao()
    Dim a = Array(233, 10086, 31, 15, 213, 5201314, 427)
    Dim i As Integer, j As Integer
    
    For i = UBound(a) - 1 To 0 Step -1
        For j = 0 To i
            If a(j) > a(j + 1) Then
                a(j) = a(j) + a(j + 1)
                a(j + 1) = a(j) - a(j + 1)
                a(j) = a(j) - a(j + 1)
            End If
        Next j
    Next i
    For i = 0 To UBound(a)
        Print a(i)
    Next i
End Sub
冒泡排序Objective-C
for (int i = 0; i<result.count-1; i++) {
        for (int j = 0; j<result.count-1-i; j++) {
            NSInteger left = [result[j] integerValue];
            NSInteger right = [result[j+1] integerValue];
            if (left>right) {
                [result exchangeObjectAtIndex:j withObjectAtIndex:j+1];
            }
        }
    }
NSLog(@"%@",result);
冒泡排序Go语言
package main
import (
    "fmt"
)
const (
    LENGTH = 8
)
func main() {
    var tmp int
    number := []int{95, 45, 15, 78, 84, 51, 24, 12}
    for i := 0; i < LENGTH; i++ {
        for j := LENGTH - 1; j > i; j-- {
            if number[j] < number[j-1] {
                tmp = number[j-1]
                number[j-1] = number[j]
                number[j] = tmp
            }
        }
    }
    for i := 0; i < LENGTH; i++ {
        fmt.Printf("%d ", number[i])
    }
    fmt.Printf("\n")
}
冒泡排序GO语言2
func BubbleSort(values []int) {
    flag := true
    vLen := len(values)
    for i := 0; i < vLen-1; i++ {
        flag = true
        for j := 0; j < vLen-i-1; j++ {
            if values[j] > values[j+1] {
                values[j], values[j+1] = values[j+1], values[j]
                flag = false
                continue
            }
        }
        if flag {
            break
        }
    }
}
冒泡排序PASCAL
var
    a:array[1..4] of integer;
    i, j, temp, n:integer;
begin
   read(n);
   for i := 1 to n do read(a[i]);
   for i := 1 to n do
       for j := 1 to n-i do
           if a[j] > a[j + 1] then
               begin
                   temp := a[j];
                   a[j] := a[j + 1];
                   a[j+1] := temp;
               end;
    for i:= 1 to n do write(a[i]);
end.
冒泡排序Python
def bubble(bubbleList):
    listLength = len(bubbleList)
    while listLength > 0:
        for i in range(listLength - 1):
            if bubbleList[i] > bubbleList[i+1]:
                bubbleList[i], bubbleList[i+1] = bubbleList[i+1], bubbleList[i]
        listLength -= 1
    print bubbleList

if __name__ == '__main__':
    bubbleList = [3, 4, 1, 2, 5, 8, 0]
    bubble(bubbleList)
冒泡排序汇编
有一个首地址为A的5个有符号数字的数组，请采用“冒泡”排序
DATAS SEGMENT
A  DW 9,4,26,85,38
DATAS ENDS
CODES SEGMENT
ASSUME CS:CODES,DS:DATAS
START:
    MOV AX,DATAS
    MOV DS,AX
    MOV DI,4;初始化外循环次数为数组个数-1
 LP1:MOV CX,DI;外循环次数初值为数组个数-1
     MOV  BX,0;基址初值BX为0
  LP2:MOV AX,A[BX]
    CMP AX,A[BX+2]
    JGE CONT;大于等于不交换
    XCHG AX,A[BX+2];小于交换,AX保存的为较大的数
MOV A[BX],AX;A[BX]保存的为较大的数，准备进行下一次比较,
  CONT:ADD BX,2;基址初值BX+2,字变量，下一个字偏移地址+2
LOOP LP2  ;内循环次数-1,内循环次数是否为0？
    DEC DI;外循环次数-1
    JNZ LP1;外循环次数是否为0?
    MOV AH,4CH
    INT 21H
CODES ENDS
    END START
冒泡排序lua
function sortBubble(list)
    local len = #list
    for i = 1, len do
        for j = 1, len-i do
            if list[j+1]>list[j] then
                local t = list[j+1]
                list[j+1] = list[j]
                list[j] = t
            end
        end
    end
end
针对问题：
数据的顺序排好之后，冒泡算法仍然会继续进行下一轮的比较，直到arr.length-1次，后面的比较没有意义的。
方案：
设置标志位flag，如果发生了交换flag设置为true；如果没有交换就设置为false。　　这样当一轮比较结束后如果flag仍为false，即：这一轮没有发生交换，说明数据的顺序已经排好，没有必要继续进行下去。
以Java为例
public static void BubbleSort1(int [] arr){
　
　
　   int temp;//临时变量
　
　   boolean flag;//是否交换的标志
　
　   for(int i=0; i<arr.length-1; i++){   //表示趟数，一共 arr.length-1 次
　
　
　       // 每次遍历标志位都要先置为false，才能判断后面的元素是否发生了交换
　
　       flag = false;
　
　       
　
　       for(int j=arr.length-1; j>i; j--){ //选出该趟排序的最大值往后移动
　
　
　           if(arr[j] < arr[j-1]){
　
　               temp = arr[j];
　
　               arr[j] = arr[j-1];
　
　               arr[j-1] = temp;
　
　               flag = true;    //只要有发生了交换，flag就置为true
　
　           }
　
　       }
　
　       // 判断标志位是否为false，如果为false，说明后面的元素已经有序，就直接return
　
　       if(!flag) break;
　
　   }
　
　}
排序算法平均时间复杂度冒泡排序O(n2)选择排序O(n2)插入排序O(n2)希尔排序O(n1.5)快速排序O(N*logN)归并排序O(N*logN)堆排序O(N*logN)基数排序O(d(n+r))
冒泡排序插入排序
插入排序算法是基于某序列已经有序排列的情况下，通过一次插入一个元素的方式按照原有排序方式增加元素。这种比较是从该有序序列的最末端开始执行，即要插入序列中的元素最先和有序序列中最大的元素比较，若其大于该最大元素，则可直接插入最大元素的后面即可，否则再向前一位比较查找直至找到应该插入的位置为止。插入排序的基本思想是，每次将1个待排序的记录按其关键字大小插入到前面已经排好序的子序列中，寻找最适当的位置，直至全部记录插入完毕。执行过程中，若遇到和插入元素相等的位置，则将要插人的元素放在该相等元素的后面，因此插入该元素后并未改变原序列的前后顺序。我们认为插入排序也是一种稳定的排序方法。插入排序分直接插入排序、折半插入排序和希尔排序3类。
[2]
冒泡排序选择排序
选择排序算法的基本思路是为每一个位置选择当前最小的元素。选择排序的基本思想是，基于直接选择排序和堆排序这两种基本的简单排序方法。首先从第1个位置开始对全部元素进行选择，选出全部元素中最小的给该位置，再对第2个位置进行选择，在剩余元素中选择最小的给该位置即可；以此类推，重复进行“最小元素”的选择，直至完成第(n-1)个位置的元素选择，则第n个位置就只剩唯一的最大元素，此时不需再进行选择。使用这种排序时，要注意其中一个不同于冒泡法的细节。举例说明：序列58539．我们知道第一遍选择第1个元素“5”会和元素“3”交换，那么原序列中的两个相同元素“5”之间的前后相对顺序就发生了改变。因此，我们说选择排序不是稳定的排序算法，它在计算过程中会破坏稳定性。
[2]
冒泡排序快速排序
快速排序的基本思想是:通过一趟排序算法把所需要排序的序列的元素分割成两大块，其中，一部分的元素都要小于或等于另外一部分的序列元素，然后仍根据该种方法对划分后的这两块序列的元素分别再次实行快速排序算法，排序实现的整个过程可以是递归的来进行调用，最终能够实现将所需排序的无序序列元素变为一个有序的序列。
[3]
冒泡排序归并排序
归并排序算法就是把序列递归划分成为一个个短序列，以其中只有1个元素的直接序列或者只有2个元素的序列作为短序列的递归出口，再将全部有序的短序列按照一定的规则进行排序为长序列。归并排序融合了分治策略，即将含有n个记录的初始序列中的每个记录均视为长度为1的子序列，再将这n个子序列两两合并得到n/2个长度为2(当凡为奇数时会出现长度为l的情况)的有序子序列；将上述步骤重复操作，直至得到1个长度为n的有序长序列。需要注意的是，在进行元素比较和交换时，若两个元素大小相等则不必刻意交换位置，因此该算法不会破坏序列的稳定性，即归并排序也是稳定的排序算法。
[2]
先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。
[2]
新建图G，G中拥有原图中相同的节点，但没有边；
[1] 

将原图中所有的边按权值从小到大排序；
[1] 

从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边到图G中；
[1] 

重复3，直至图G中所有的节点都在同一个连通分量中。
[1]
这样的步骤保证了选取的每条边都是桥，因此图G构成一个树。
[3] 

为什么这一定是最小生成树呢？关键还是步骤3中对边的选取。算法中总共选取了n-1条边，每条边在选取的当时，都是连接两个不同的连通分量的权值最小的边。
[3] 

要证明这条边一定属于最小生成树，可以用反证法：如果这条边不在最小生成树中，它连接的两个连通分量最终还是要连起来的，通过其他的连法，那么另一种连法与这条边一定构成了环，而环中一定有一条权值大于这条边的边，用这条边将其替换掉，图仍旧保持连通，但总权值减小了。
[1] 
也就是说，如果不选取这条边，最后构成的生成树的总权值一定不会是最小的。
[2]
平均时间复杂度为O(|E|log|E|)，其中E和V分别是图的边集和点集。
[2]
#include<stdio.h>
#include<iostream>
#include<algorithm>
using namespace std;

const int M = 1e5+7;

struct node
{
  int a,b,val;
} Q[M];
int fa[M];

int Rd()
{
  int res=0;char c;
  while(c=getchar(),!isdigit(c));
  do {
    res=(res<<3)+(res<<1)+(c^48);
  } while(c=getchar(),isdigit(c));
  return res;
}

bool cmp(LZ a,LZ b){
  return a.val<b.val;
}

int getfa(int v){
    if(fa[v]!=v)fa[v]=getfa(fa[v]);
    return fa[v];
}

int main()
{
    int i,j,n,m,x,y;
    scanf("%d%d",&n,&m);
    for(i=1;i<=m;i++)
    {
        Q[i].a=Rd();Q[i].b=Rd();Q[i].val=Rd();
    }
    sort(Q+1,Q+m+1,cmp);
    for(i=1;i<=n;i++)
    {
        fa[i]=i;
    }

    int sum=0,cut=0;
    for(i=1;i<=m;i++)
    {
        x=getfa(Q[i].a);
        y=getfa(Q[i].b);        
        if(x==y)continue;        
        sum+=Q[i].val;        
        if(++cut==n-1)break;        
        fa[x]=y;    
    }    
    printf("%d",sum);    
    return 0;
}
有几种标准技术可以设计一种近似算法。这些包括以下内容。
1.贪婪算法
2.本地搜索
3.枚举和动态规划
4.解决凸规划松弛以获得分数解，然后通过一些适当的舍入将这个分数解解成一个可行的解。流行的放松包括以下：
1.线性规划放松
2.半封闭编程放松
5.将问题嵌入到一些简单的度量中，然后解决度量上的问题。这也被称为度量嵌入
[2]
所有已知的解决NP-难问题算法都有指数型运行时间。但是，如果我们要找一个“好”解而非最优解，有时候多项式算法是存在的。
给定一个最小化问题和一个近似算法，我们按照如下方法评价算法：首先给出最优解的一个下界，然后把算法的运行结果与这个下界
进行比较。对于最大化问题，先给出一个上界然后把算法的运行结果与这个上界比较。
近似算法比较经典的问题包括：最小顶点覆盖、旅行售货员问题、集合覆盖等。
迄今为止，所有的NP完全问题都还没有多项式时间算法。
对于这类问题，通常可采取以下几种解题策略。
(1)只对问题的特殊实例求解
(2)用动态规划法或分支限界法求解
(3)用概率算法求解
(4)只求近似解
(5)用启发式方法求解
若一个最优化问题的最优值为c*，求解该问题的一个近似算法求得的近似最优解相应的目标函数值为c，
则将该近似算法的性能比定义为max(c/c*, c*/c)。在通常情况下，该性能比是问题输入规模n的一个函数
ρ(n)，即 max(c/c*, c*/c) <= ρ(n)。
该近似算法的相对误差定义为Abs[(c-c*)/c*]。若对问题的输入规模n，有一函数ε(n)使得Abs[(c-c*)/c*] <= ε(n)，则称ε(n)为该近似算法的相对误差界。近似算法的性能比ρ(n)与相对误差界ε(n)之间显然有如下
关系：ε(n)≤ρ(n)-1。
[3]
顶点覆盖问题的近似算法
问题描述：无向图G=(V,E)的顶点覆盖是它的顶点集V的一个子集V’，使得若(u,v)是G的一条边，则v∈V’或u∈V’。顶点覆盖V’的大小是它所包含的顶点个数|V’|。
VertexSet approxVertexCover ( Graph g )
{ cset=NULL；
e1=g.e；
while (e1 !=NULL) {
从e1中任取一条边(u,v)；
cset=cset∪{u,v}；
从e1中删去与u和v相关联的所有边；
}
return c
}
Cset用来存储顶点覆盖中的各顶点。初始为空，不断从边集e1中选取一边(u,v)，将边的端点加入cset中，并将e1中已被u和v覆盖的边删去，直至cset已覆盖所有边。即e1为空。
图(a)～(e)说明了算法的运行过程及结果。(e)表示算法产生的近似最优顶点覆盖cset，它由顶点b,c,d,e,f,g所组成。(f)是图G的一个最小顶点覆盖，它只含有3个顶点：b,d和e。
[3]
旅行售货员问题近似算法
问题描述：给定一个完全无向图G=(V,E)，其每一边(u,v)∈E有一非负整数费用c(u,v)。要找出G的最小费用哈密顿回路。
旅行售货员问题的一些特殊性质：
比如，费用函数c往往具有三角不等式性质，即对任意的3个顶点u,v,w∈V，有：c(u,w)≤c(u,v)+c(v,w)。当图G中的顶点就是平面上的点，任意2顶点间的费用就是这2点间的欧氏距离时，费用函数c就具有三角不等式性质。
对于给定的无向图G，可以利用找图G的最小生成树的算法设计找近似最优的旅行售货员回路的算法。
void approxTSP (Graph g)
{
(1)选择g的任一顶点r；
(2)用Prim算法找出带权图g的一棵以r为根的最小生成树T；
(3)前序遍历树T得到的顶点表L；
(4)将r加到表L的末尾，按表L中顶点次序组成回路H，作为计 算结果返回；
}
当费用函数满足三角不等式时，算法找出的旅行售货员回路的费用不会超过最优旅行售货员回路费用的2倍。

(b)表示找到的最小生成树T；(c)表示对T作前序遍历的次序；(d)表示L产生的哈密顿回路H；
(e)是G的一个最小费用旅行售货员回路。
[3]
一般的旅行售货员问题
在费用函数不一定满足三角不等式的一般情况下，不存在具有常数性能比的解TSP问题的多项式时间近似算法，除非P=NP。换句话说，若P≠NP，则对任意常数ρ>1，不存在性能比为ρ的解旅行售货员问题的多项式时间近似算法。
集合覆盖问题的近似算法
问题描述：给定一个完全无向图G=(V,E)，其每一边(u,v)∈E有一非负整数费用c(u,v)。要找出G的最小费用哈密顿回路。
集合覆盖问题的一个实例〈X,F〉由一个有限集X及X的一个子集族F组成。子集族F覆盖了有限集X。也就是说X中每一元素至少属于F中的一个子集，即X= 。对于F中的一个子集CF，若C中的X的子集覆盖了X，即X= ，则称C覆盖了X。集合覆盖问题就是要找出F中覆盖X的最小子集C*，使得
|C*|=min{|C||CF且C覆盖X}
集合覆盖问题举例：



用12个黑点表示集合X。F={S1,S2,S3,S4,S5,S6,}，如图所示。容易看出，对于这个例子，最小集合覆盖为：C={S3,S4,S5,}。
集合覆盖问题近似算法——贪心算法
Set greedySetCover (X,F)
{
U=X；
C=；
while (U !=) {
选择F中使|S∩U|最大的子集S；
U=U-S；
C=C∪{S}；
}
return C；
}
算法的循环体最多执行min{|X|，|F|}次。而循环体内的计算显然可在O(|X||F|)时间内完成。因此，算法的计算时间为O(|X||F|min{|X|，|F|})。由此即知，该算法是一个多项式时间算法。
[3]
子集和问题的近似算法
问题描述：设子集和问题的一个实例为〈S,t〉。其中，S={x1，x2，…，xn}是一个正整数的集合，t是一个正整数。子集和问题判定是否存在S的一个子集S1，使得∑x = t。(x属于S1)
1 子集和问题的指数时间算法
int exactSubsetSum (S,t)
{
int n=|S|；
L[0]={0}；
for (int i=1；i<=n；i++) {
L[i]=mergeLists(L[i-1],L[i-1]+S[i])；
删去L[i]中超过t的元素；
}
return max(L[n])；
}
算法以集合S={x1，x2，…，xn}和目标值t作为输入。算法中用到将2个有序表L1和L2合并成为一个新的有序表的算法mergeLists(L1,L2)。
2 子集和问题的完全多项式时间近似格式
基于算法exactSubsetSum，通过对表L[i]作适当的修整建立一个子集和问题的完全多项式时间近似格式。
在对表L[i]进行修整时，用到一个修整参数δ，0<δ<1。用参数δ修整一个表L是指从L中删去尽可能多的元素，使得每一个从L中删去的元素y，都有一个修整后的表L1中的元素z满足(1-δ)y≤z≤y。可以将z看作是被删去元素y在修整后的新表L1中的代表。
举例：若δ=0.1，且L=〈10,11,12,15,20,21,22,23,24,29〉，则用δ对L进行修整后得到L1=〈10，12，15，20，23，29〉。其中被删去的数11由10来代表，21和22由20来代表，24由23来代表。
对有序表L修整算法
List trim(L,δ)
{ int m=|L|；
L1=〈L[1]〉；
int last=L[1]；
for (int i=2；i<=m；i++) {
if (last<(1-δ)*L[i]) {
将L[i]加入表L1的尾部；
last=L[i]；
}
return L1；
}
子集和问题近似格式
int approxSubsetSum(S,t,ε)
{ n=|S|；
L[0]=〈0〉；
for (int i=1；i<=n；i++) {
L[i]=Merge-Lists(L[i-1],
L[i-1]+S[i])；
L[i]=Trim(L[i],ε/n)；
删去L[i]中超过t的元素；
}
return max(L[n])；
}
[3]
（1）实数集的子集是连通的，当且仅当它是一个区间；
（2）连通性由同胚保持，从而是空间的拓扑性质；
（3）设Ω是X的一族子集，它们的并是整个空间X，每个Ω中的个体连通，且两两不分离（即任意两个集合的闭包有非空交），则称为‘X连通’；
（4）若X、Y连通，则乘积空间X×Y连通。
连通性连通空间
定义1：设X是一个拓扑空间。如果X中有两个非空的隔离子集A和B，使得X= A∪ B，则称X是一个不连通空间；否则，则称X是一个连通空间。
连通性局部连通空间
定义2：设X是一个拓扑空间。如果x∈ X的每一个邻域中都包含着x的某一个连通的邻域V，则称拓扑空间在点x处是局部连通的。如果拓扑空间X在它的每一个点处都是局部连通的，则称是一个局部连通空间
[1] 
。
局部连通的拓扑空间也不必是连通的。例如，每一个离散空间都是局部连通空间，但包含着多于一个点的离散空间却不是连通空间。又例如，n维欧氏空间



 的任何一个开子空间都是局部连通的(这是因为每一个球形邻域都同胚于整个欧氏空间，因而是连通的)，特别地，欧氏空间本身是局部连通的。另一方面，欧氏空间中由两个无交的非空开集的并作为子空间就一定不是连通的。
此外根据定义立即可见：拓扑空间X在点x



 X处是局部连通的当且仅当x的所有连通邻域构成点二处的一个邻域基。
连通性道路连通空间
定义3：设X是一个拓扑空间，如果对于任何x, y，存在着X中的一条从x到y的道路(或曲线)，我们则称X是一个道路连通空间。X中的一个子集Y称为X中的一个道路连通子集，如果它作为X的子空间是一个道路连通空间。
实数空间R是道路连通的，这是因为如果x, y



 R，则连续映射f： [0,1]



 R定义为对于任何t



 [0,1]有f(t)=x+t(y-x)，便是R中的一条以x为起点以y为终点的道路。也容易验证任何一个区间都是道路连通的
[2] 
。
连通性简介
假设有个整数对，p-q解释为p与q连通。如图1所示




图1

。如果新输入的对，可以由以前的输入对连通，就不会输出；如果不能由以前的对连通，就输出这个对。例如2-9不在输出之列，因为前面的对存在2-3-4-9的连通。
其可应用如下：
（1）整数代表网络节点，对代表网络连通，因此网络可以判断p和q之间是否应经连通。
（2）电网。
（3）更甚至与程序中定义的两个等价变量。
连通性算法实现
首先假设连通的每个节点都存在一个数组中a[N]，每次都选择两个节点，判断两个节点是不是连通。
（1）快速查找（quick-find）算法：程序如图2所示，程序中当且仅当p与q连通的时候，id[p]与id[q]相等。
图2
（2）快速并集算法：相比上面的算法，并集运算计算量少，查找运算计算量大，算是算法的改进。根本就是：每个节点都沿着树上移，找到各自的根节点(root)。具体程序如图3所示。
图3
（3）快速并集的加权算法：
图4
上面的算法，我们并不能保证每一种情况，它的速度都比快速查找有实质性的提高。这个是修改版，它使用一个额外的数组sz完成维护的目的，为每个对象用id[i]==i来表示，这样可以组织树的增长。图4描述了快速并集加权算法，连接两棵树的时候，较小的数的根要附属到较大的数的根下面。这样节点与根的距离短，多以查找效率要高。
如图4所示，当处理1和6的时候，让1、5、6都指向3，得到的树比上面的算法更扁平。
中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。若二叉树为空则结束返回，否则：
（1）中序遍历左子树
（2）访问根结点
（3）中序遍历右子树
如右图所示二叉树，中序遍历结果：DBEAFC

当对一棵数学表达式树进行中序，前序和后序遍历时，就分别得到表达式的中缀、前缀和后缀形式。中缀（infix）形式即平时所书写的数学表达式形式，在这种形式中，每个二元操作符（也就是有两个操作数的操作符）出现在左操作数之后，右操作数之前。在使用中缀形式时，可能会产生一些歧义。例如，x+y ×z可以理解为(x+y) ×z或x+ (y ×z)。为了避免这种歧义，可对操作符赋于优先级并采用优先级规则来分析中缀表达式。在完全括号化的中缀表达式中，每个操作符和相应的操作数都用一对括号括起来。更甚者把操作符的每个操作数也都用一对括号括起来。如( (x) + (y) )，( (x) + ( (y) * (z) ) )和( ( (x) + (y) ) * ( (y) + (z) ) ) * (w)。
[1]
设二叉树中元素数目为n，中序遍历算法的空间复杂性均为O (n)，时间复杂性为(n)。
当t的高度为n时(右斜二叉树的情况)，通过观察其前序、中序和后序遍历时所使用的递归栈空间即可得到上述结论。
[1]
中序遍历c++版本
树中节点结构为：
typedef struct TreeNode {
    int data;
    struct TreeNode *left;
    struct TreeNode *right;
    struct TreeNode *parent;
} TreeNode;

void middle_order(TreeNode *Node) {
    if(Node != NULL) {
        middle_order(Node->left);
        printf("%d ", Node->data);
        middle_order(Node->right);
    }
}

调用时： middle_order(Root); //Root为树的根
中序遍历Java版本
class TreeNode{
    public int data;
    public TreeNode leftChild;
    public TreeNode rightChild;
    public static void inOrderTraversal(TreeNode node){
        if(node == null){
            return;
        }else{
            inOrderTraversal(node.leftChild);
        System.out.println(node.data);
        inOrderTRaversal(node.rightChild);
        }
    }
}
中序遍历C#版本
/*
public class BTNode                  //二叉树节点类型
{
    public BTNode lchild;
    public BTNode rchild;
    public char data;
}
*/
/*
public string btstr                 //全局变量
*/
public string InOrder(BTNode t)
{
    btstr="";                         
    InOrder1(r);
    return btstr;
}
public string InOrder1(BTNode t)
{
    if(t!=null)
    {
        InOrder(t.lchild);
        bster+=t.data.ToString()+" ";
        InOrder(t.rchild);
    }
}
中序遍历pascal版本
核心代码：
procedure mid(bt:tree);
begin
    if bt<>nil then begin
        mid (bt^.left);
        write(bt^.data);
        mid (bt^.right);
    end;
end;
[tabulate;arrange in columns or tables] 把…制成表,以表显示
英文解释：list 、list files of type
以表格为容器，装载着文字或图表的一种形式，叫列表。
在互联网发展的同时，还衍生了一种在以网上形式发表的列表。简称“网表”。
<数据结构术语>数据结构中的列表一般指线性列表的简称.
列表是一种数据项构成的有限序列,即按照一定的线性顺序,排列而成的数据项的集合,在这种数据结构上进行的基本操作包括对元素的的查找,插入和删除
列表的两种主要表现是数组和链表,栈和队列是两种特殊类型的列表
列表控件可使用四种不同视图显示项目。可将项目组成带有或不带有列标头的列，并显示伴随的图标和文本。 比如使用 ListView 控件将称作 ListItem 对象的列表条目组织成下列四种不同的视图之一：1.大（标准）图标2.小图标3.列表4.报表 View 属性决定在列表中控件使用何种视图显示项目。比如ComponentOne
[1] 
的List控件有齐全的列表框和多列的下拉列表框,拆分样式等.可管理列表中项目的排序方法和选定项目的外观.
例如右图：任务的优先权及执行顺序的关系

优先队列的类定义
#include<assert.h>
#include<iostream.h>
#include<stdlib.h>

constintmaxPQSize=50;//缺省元素个数

template<class Type>
class PQueue{
public:
    PQueue();
    ~PQueue()
    {
        delete[]pqelements;
    }
    void PQInsert(const Type& item);
    Type PQRemove();
    void makeEmpty()
    {
        ~PQueue();
        count=0;
    }
    int IsEmpty() const
    {
        return count==0;
    }
    intIsFull() const
    {
        return count==maxPQSize;
    }
    int Length() const
    {
        return count;
    }
    private:
    Type *pqelements;//存放数组
    int count;//队列元素计数
};
优先队列是0个或多个元素的集合,每个元素都有一个优先权或值,对优先队列执行的操作有1) 查找;2) 插入一个新元素;3) 删除.在最小优先队列(min priority queue)中,查找操作用来搜索优先权最小的元素,删除操作用来删除该元素;对于最大优先队列(max priority queue),查找操作用来搜索优先权最大的元素,删除操作用来删除该元素.优先权队列中的元素可以有相同的优先权,查找与删除操作可根据任意优先权进行.
最大优先权队列的抽象数据类型描述下所示,最小优先队列的抽象数据类型描述与之类似,只需将最大改为最小即可.
ADT 最大优先队列的抽象数据类型描述抽象数据类型
pascal 版本优先队列
vara:array[0..1000]oflongint;
l,i,j,x,y,n,m:longint;
procedureup(i:longint);//向上调整
vart,j:longint;
begin
j:=i;
while j>1 do
begin
j:=i>>1;
if a[j]>a[i] then
begin
t:=a[j];
a[j]:=a[i];
a[i]:=t;
i:=j;
end 
else break;
end;
end;
procedure down(i:longint);//向下调整
var t,j:longint;
begin
while i<=(l>>1) do
begin
j:=2*i;
if (j<l)and(a[j+1]<a[j]) then inc(j);
if a[i]>a[j] then
begin
t:=a[i];
a[i]:=a[j];
a[j]:=t;
i:=j;
end 
else break;
end;
end;
procedure rudui(i:longint);//入队
begin
inc(l);
a[l]:=i;
up(l);
end;
function chudu(i:longint);//出队
var t,j,ans:longint;
begin
ans:=a[1];
a[1]:=a[l];
a[l]:=0;
dec(l);
down(1);
exit(ans);
end;
begin
readln(n);
l:=n;
for i:=1to n do read(a[i]);
readln;
for i:=n>>1 downto 1do
down(i);
readln(m);
for i:=1 to m do
begin
readln(x,y);
if x=1 then rudui(y);//将y入队
if x=0 then writeln(chudui);//探出栈顶元素并调整
end;
end.
有限的元素集合,每个元素都有一个优先权
操作
Create ( ):创建一个空的优先队列
Size ( ):返回队列中的元素数目
Max ( ):返回具有最大优先权的元素
Insert (x):将x插入队列
DeleteMax (x):从队列中删除具有最大优先权的元素,并将该元素返回至x
}
优先队列插入和删除元素的复杂度都是O(log2n)，所以很快。
另一种描述方法是采用有序线性表,当元素按递增次序排列,使用链表时则按递减次序排列,这两种描述方法的删除时间均为( 1 ),插入操作所需时间为(n).
例：
假设我们对机器服务进行收费.每个用户每次使用机器所付费用都是相同的,但每个
用户所需要服务时间都不同.为获得最大利润,假设只要有用户机器就不会空闲,我们可以把
等待使用该机器的用户组织成一个最小优先队列,优先权即为用户所需服务时间.当一个新的
用户需要使用机器时,将他/她的请求加入优先队列.一旦机器可用,则为需要最少服务时间
(即具有最高优先权)的用户提供服务.
如果每个用户所需时间相同,但用户愿意支付的费用不同,则可以用支付费用作为优先权,
一旦机器可用,所交费用最多的用户可最先得到服务,这时就要选择最大优先队列.
下面是数组实现的二叉堆，其中MAX_SIZE是数组的最大长度；ElementType是其中元素的类型；Priority(x: ElementType) 是一个函数，返回值是元素x的优先级，当然也可以用一个Priority数组来保存每个元素的优先级(在这个打字员问题中就应该用一个数组来保存每个元素的优先级，在这个问题中优先级就是从初始密码转换到该密码所需的操作的数目)。
type
PriorityQueue = record
contents: array [1..MAX_SIZE]of ElementType;
last : integer;
end;
{ 将一个优先队列变空 }
procedure MakeNull(var A: PriorityQueue);
begin
A.last := 0;
end;
{ 向优先队列A中插入一个元素x }
procedure Insert(x: ElementType; var A: PriorityQueue);
var
i: integer;
temp:ElementType;
begin
if A.last = MAX_SIZE then
Error('Priority Queue is full.')
else begin
A.last := A.last + 1;
A.contents[A.last] := x;
i := A.last;
while (i > 1) and ( Priority(A.contents) < Priority(A.contents[i div 2]) do
begin
temp := A.contents;
A.contents:= A.contents[i div 2];
A.contents[i div 2] := temp;
i := i div 2;
end; { end of while }
end; { end of else }
end; { end of Insert }
{ 删除优先队列对头的那个优先级最小的元素，并将其值返回 }
function DeleteMin(var A: PriorityQueue): ElementType;
var
minimun : ElementType;
i : integer;
begin
if A.last = 0 then
Error('Priority Queue is empty. ')
else begin
minimun := A.contents[1];
A.contents[1] := A.contents[A.last];
A.last := A.last - 1;
i := 1;
while i < (A.last div 2) do
begin
if (Priority(A.contents[2*i]) < Priority(A.contents[2*i+1])) or (2*i = A.last)
then j := 2*i;
else j := 2*i + 1;
{ j节点是i节点具有较高优先级的儿子，当i节点只有一个儿子的时候，j节点是i节点的唯一儿子 }
if Priority(A.contents) > Priority(A.contents[j]) then
begin
temp := A.contents;
A.contents:= A.contents[j];
A.contents[j] := temp;
i := j;
end
else begin { 不能再向下推了 }
DeleteMin := minimum;
exit;
end;
end; { end of while }
{ 这时已经到达叶结点 }
DeleteMin := minimum;
exit;
end; { end of else }
end; { end of DeleteMin }
//二叉堆就是优先队列（父节点大于子节点）
优先级队列必须至少支持以下操作：
is_empty：检查队列是否没有元素。
insert_with_priority：使用关联的优先级向队列添加元素。
pull_highest_priority_element：从队列中删除具有最高优先级的元素，并将其返回。
这也称为“pop_element（Off）”，“get_maximum_element”或“get_front（most）_element”。
一些约定颠倒了优先级的顺序，将较低的值视为较高的优先级，因此这也可称为“get_minimum_element”，并且在文献中通常称为“get-min”。
这可以替代地被指定为单独的“peek_at_highest_priority_element”和“delete_element”函数，其可以被组合以产生“pull_highest_priority_element”
[1] 
。
此外，peek（在此上下文中通常称为find-max或find-min）返回最高优先级元素但不修改队列，它经常被实现，并且几乎总是在O（1）时间内执行。此操作及其O（1）性能对于许多优先级队列应用程序至关重要。
更高级的实现可能支持更复杂的操作，例如pull_lowest_priority_element，检查前几个最高或最低优先级元素，清除队列，清除队列子集，执行批量插入，将两个或多个队列合并为一个，增加优先级任何元素等。
可以将优先级队列想象为已修改的队列，但是当一个人从队列中获取下一个元素时，将首先检索优先级最高的元素。
堆栈和队列可以被建模为特定类型的优先级队列。提醒一下，堆栈和队列的行为方式如下：
堆栈 - 元素以最后一个顺序被拉入（例如，一叠纸）
队列 - 元素先进先出（例如，自助餐厅中的一条线）
在堆栈中，每个插入元素的优先级是单调递增的;因此，插入的最后一个元素始终是第一个检索的元素。在队列中，每个插入元素的优先级是单调递减的;因此，插入的第一个元素始终是第一个检索到的元素。
为了用图表示亲缘关系，把分类单位摆在图上树枝顶部，根据分枝可以表示其相互关系，具有二次元和三次元。在数量分类学上用于表型分类的树状图，称为表型树状图（phenogram），掺入系统的推论的称为系统树状图（cladogram）以资区别。表型树状图是根据群析描绘的，系统树状图是根据一种模拟的假定的性状进化方向即用电子计算机描绘的。
树状图也是初中学生学习概率问题所需要画的一种图形。
最小树形图，就是给有向带权图中指定一个特殊的点v，求一棵有向生成树T，使得该有向树的根为v，并且T中所有边的总权值最小。最小树形图的第一个算法是1965年朱永津和刘振宏提出的复杂度为O(VE)的算法。　　判断是否存在树形图的方法很简单，只需要以v为根作一次图的遍历就可以了，所以下面的算法中不再考虑树形图不存在的情况。　　在所有操作开始之前，我们需要把图中所有的自环全都清除。很明显，自环是不可能在任何一个树形图上的。只有进行了这步操作，总算法复杂度才真正能保证是O(VE)。　　首先为除根之外的每个点选定一条入边，这条入边一定要是所有入边中最小的。所有的最小入边都选择出来了，如果这个入边集不存在有向环的话，我们可以 证明这个集合就是该图的最小树形图。这个证明并不是很难。如果存在有向环的话，我们就要将这个有向环所称一个人工顶点，同时改变图中边的权。假设某点u在 该环上，并设这个环中指向u的边权是in[u]，那么对于每条从u出发的边(u, i, w)，在新图中连接(new, i, w)的边，其中new为新加的人工顶点; 对于每条进入u的边(i, u, w)，在新图中建立边(i, new, w-in[u])的边。为什么入边的权要减去in[u]，这个后面会解释，在这里先给出算法的步骤。然后可以证明，新图中最小树形图的权加上旧图中被收缩 的那个环的权和，就是原图中最小树形图的权。　　上面结论也不做证明了。依据上面的结论，说明一下为什么出边的权不变，入边的权要减去in [u]。对于新图中的最小树形图T，设指向人工节点的边为e。将人工节点展开以后，e指向了一个环。假设原先e是指向u的，这个时候我们将环上指向u的边 in[u]删除，这样就得到了原图中的一个树形图。我们会发现，如果新图中e的权w'(e)是原图中e的权w(e)减去in[u]权的话，那么在我们删除 掉in[u]，并且将e恢复为原图状态的时候，这个树形图的权仍然是新图树形图的权加环的权，而这个权值正是最小树形图的权值。所以在展开节点之后，我们 得到的仍然是最小树形图。逐步展开所有的人工节点，就会得到初始图的最小树形图了。　　如果实现得很聪明的话，可以达到找最小入边O(E)，找环 O(V)，收缩O(E)，其中在找环O(V)这里需要一点技巧。这样每次收缩的复杂度是O(E)，然后最多会收缩几次呢？由于我们一开始已经拿掉了所有的 自环，我门可以知道每个环至少包含2个点，收缩成1个点之后，总点数减少了至少1。当整个图收缩到只有1个点的时候，最小树形图就不不用求了。所以我们最 多只会进行V-1次的收缩，所以总得复杂度自然是O(VE)了。由此可见，如果一开始不除去自环的话，理论复杂度会和自环的数目有关。
例1、随机掷两枚质地均匀的正方体骰子，骰子的六个面上分别刻有1到6的点数，则这两个骰子向上的一面点数都是奇数的概率为多少？
分析：本题中的事件是掷两枚骰子，看向上的一面点数，由此可确定本事件包括两个环节，掷第一枚骰子和掷第二枚骰子，所以树状图该画两层。第一枚骰子向上的一面的点数可能是1，2，3，4，5，6等6个的一个，所以第一层应画6个分叉；再看第二层，第二枚骰子，向上一面的点数可能是6个的一个，所以第二层应接在第一层的6个分叉上，每个小分支上，再有6个分叉。画出树状图，这样共得到6×6种情况，从中找出两个骰子向上的一面点数都是奇数的情况，再求出概率。
解：画出树状图，如图1。
由图中可以看出，两枚骰子向上的一面点数的可能性情况共36种，其中向上的一面点数都是奇数的情况有（1，1），（1，3），（1，5），（3，1），（3，3），（3，5），（5，1）（5，3）（5，5）共9种情况，从而得两个骰子向上的一面点数都是奇数的概率（记为事件A）为P（A）=9/36=1/4
点评：由本例看出，只要画好了树状图，就很容易求出概率。而画树状图的关键一是确定层数，二是确定每层分叉的个数。
例2、一个口袋中装有红、白、绿三只小球，另一只口袋中装有（除颜色外其余都相同）红、白两只小球。现从两只口袋中各取一只小球，求两只小球颜色一样的概率是多少？
分析：本题从两只口袋中各取一只小球，由此可见事件的环节共两个，树状图画两层。由于一只口袋中装有三只小球，所以此层应有三个分叉。另一只口袋中装有两只小球，拿一个球的可能性有两种，此层可能有两个分叉。各层的分叉要画对。至于两只口袋中哪只放上，哪只放下，可以随便画，不影响结果。
解：画出树状图如下图2（图3也正确）：
从图中可以看出，两只小球颜色的可能性共6种，而两只小球颜色一样的可能性只有（红，红），（白，白）共2种，所以两只小球颜色一样的概率（记为事件A）为P（A）=2/6=1/3
点评：本题与上题不同的是两个口袋的球数不等，所以各层的分叉要根据本层的可能情来确定，这是画树状图最不易掌握的知识点，大家要多加揣摩。
假定：输入是由一个随机过程产生的[0, 1)区间上均匀分布的实数。将区间[0, 1)划分为n个大小相等的子区间（桶），每桶大小1/n：[0, 1/n)， [1/n, 2/n)， [2/n, 3/n)，…，[k/n, (k+1)/n )，…将n个输入元素分配到这些桶中，对桶中元素进行排序，然后依次连接桶输入0 ≤A[1..n] <1辅助数组B[0..n-1]是一指针数组，指向桶（链表）。
桶排序算法要求，数据的长度必须完全一样，程序过程要产生长度相同的数据，使用下面的方法：Data=rand()/10000+10000上面提到的，每次下一次的扫描顺序是按照上次扫描的结果来的，所以设计上提供相同的两个桶数据结构。前一个保存每一次扫描的结果供下次调用，另外一个临时拷贝前一次扫描的结果提供给前一个调用。
数据结构设计：链表可以采用很多种方式实现，通常的方法是动态申请内存建立结点，但是针对这个算法，桶里面的链表结果每次扫描后都不同，就有很多链表的分离和重建。如果使用动态分配内存，则由于指针的使用，安全性低。所以，笔者设计时使用了数组来模拟链表（当然牺牲了部分的空间，但是操作却是简单了很多，稳定性也大大提高了）。共十个桶，所以建立一个二维数组，行向量的下标0—9代表了10个桶，每个行形成的一维数组则是桶的空间。
平均情况下桶排序以线性时间运行。像基数排序一样，桶排序也对输入作了某种假设， 因而运行得很快。具 体来说，基数排序假设输入是由一个小范围内的整数构成，而桶排序则 假设输入由一个随机过程产生，该过程将元素一致地分布在区间[0，1)上。 桶排序的思想就是把区间[0，1)划分成n个相同大小的子区间，或称桶，然后将n个输入数分布到各个桶中去。因为输入数均匀分布在[0，1)上，所以一般不会有很多数落在一个桶中的情况。为得到结果，先对各个桶中的数进行排序，然后按次序把各桶中的元素列出来即可。
在桶排序算法的代码中，假设输入是含n个元素的数组A，且每个元素满足0≤ A[i]<1。另外还需要一个辅助数组B[O..n-1]来存放链表实现的桶，并假设可以用某种机制来维护这些表。
桶排序的算法如下(伪代码表示)，其中floor(x)是地板函数，表示不超过x的最大整数。
procedure Bin_Sort(var A:List);begin
n:=length(A);
for i:=1 to n do
将A[i]插到表B[floor(n*A[i])]中;
for i:=0 to n-1 do
用插入排序对表B[i]进行排序;
将表B[0],B[1],...,B[n-1]按顺序合并;
end;
右图演示了桶排序作用于有10个数的输入数组上的操作过程。(a)输入数组A[1..10]。(b)在该算法的第5行后的有序表(桶)数组B[0..9]。桶i中存放了区间[i/10，(i+1)/10]上的值。排序输出由表B[O]、B[1]、...、B[9]的按序并置构成。
要说明这个算法能正确地工作，看两个元素A[i]和A[j]。如果它们落在同一个桶中，则它们在输出序列中有着正确的相对次序，因为它们所在的桶是采用插入排序的。现假设它们落到不同的桶中，设分别为B[i']和B[j']。不失一般性，假设i' i'=floor(n*A[i])≥floor(n*A[j])=j' 得矛盾 (因为i' 来分析算法的运行时间。除第5行外，所有各行在最坏情况的时间都是O(n)。第5行中检查所有桶的时间是O(n)。分析中唯一有趣的部分就在于第5行中插人排序所花的时间。
为分析插人排序的时间代价，设ni为表示桶B[i]中元素个数的随机变量。因为插入排序以二次时间运行，故为排序桶B[i]中元素的期望时间为E[O(ni2)]=O(E[ni2])，对各个桶中的所有元素排序的总期望时间为：O(n)。



(1) 为了求这个和式，要确定每个随机变量ni的分布。我们共有n个元素，n个桶。某个元素落到桶B[i]的概率为l/n，因为每个桶对应于区间[0，1)的l/n。这种情况与投球的例子很类似：有n个球 (元素)和n个盒子 (桶)，每次投球都是独立的，且以概率p=1/n落到任一桶中。这样，ni=k的概率就服从二项分布B(k;n,p)，其期望值为E[ni]=np=1，方差V[ni]=np(1-p)=1-1/n。对任意随机变量X，有右图所示表达式。
(2)将这个界用到(1)式上，得出桶排序中的插人排序的期望运行时间为O(n)。因而，整个桶排序的期望运行时间就是线性的。
桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。
对N个关键字进行桶排序的时间复杂度分为两个部分：
(1) 循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。
(2) 利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为 ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。
很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：
(1) 映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。
(2) 尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。 当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。
对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：
O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)
当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。
总结：桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。当然桶排序的空间复杂度为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。
[1]
io.open();//打开控制台
/**-------------------------------------------------------* 桶排序**------------------------------------------------------*/
/*
桶排序假设输入元素均匀而独立分布在区间[0,1) 即 0 <= x and x < 1;将区间划分成n个相同大小的子区间(桶)，然后将n个输入按大小分布到各个桶中去，对每个桶内部进行排序。最后将所有桶的排序结果合并起来.
*/
//插入排序算法
insert_sort = function( array ){
for( right=2;#array ) {
var top = array[right];
//Insert array[right] into the sorted seqquence array[1....right-1]
var left = right -1;
while( left and array[left]>top){
array[left+1] = array[left];
left--;
}
array[left+1] = top;
}
return array;
}
//桶排序算法
bucket_sort = function( array ){
var n = #array;
var bucket ={}
for(i=0;n;1){
bucket[i] = {} //创建一个桶
}
var bucket_index
for(i=1;n;1){
bucket_index = math.floor(n * array[i]);
table.push( bucket [ bucket_index ],array[i] );//放到桶里去
}
for(i=1;n;1){
insert_sort( bucket[i] ); //对每个桶进行插入排序
}
return table.concat( table.unpack(bucket) )
}
io.print("----------------")
io.print("桶排序")
io.print("----------------")
array={};
//桶排序假设输入是由一个随机过程产生的小数.
math.randomize()
for(i=1;20;1){
table.push( array,math.random() )
}
//排序
array = bucket_sort( array )
//输出结果
for(i=1;#array;1){
io.print( array[i] )
}
execute("pause") //按任意键继续
io.close();//关闭控制台
桶排序C++
#include<iostream>
usingnamespace std;
int a[]={1,255,8,6,25,47,14,35,58,75,96,158,657};
const int len=sizeof(a)/sizeof(int);
int b[10][len+1]={0};//将b全部置0
void bucketSort(int a[]);//桶排序函数
void distribute Elments(int a[],int b[10][len+1],int digits);
void collectElments(int a[],int b[10][len+1]);
int numOfDigits(int a[]);
void zeroBucket(int b[10][len+1]);//将b数组中的全部元素置0
int main()
{
cout<<"原始数组：";
for(int i=0;i<len;i++)
cout<<a[i]<<",";
cout<<endl;
bucketSort(a);
cout<<"排序后数组：";
for(int i=0;i<len;i++)
cout<<a[i]<<",";
cout<<endl;
return 0;
}
void bucketSort(int a[])
{
int digits=numOfDigits(a);
for(int i=1;i<=digits;i++)
{
distributeElments(a,b,i);
collectElments(a,b);
if(i!=digits)
zeroBucket(b);
}
}
int numOfDigits(int a[])
{
int largest=0;
for(int i=0;i<len;i++)//获取最大值
if(a[i]>largest)
largest=a[i];
int digits=0;//digits为最大值的位数
while(largest)
{
digits++;
largest/=10;
}
return digits;
}
void distributeElments(int a[],int b[10][len+1],int digits)
{
int divisor=10;//除数
for(int i=1;i<digits;i++)
divisor*=10;
for(int j=0;j<len;j++)
{
int numOfDigist=(a[j]%divisor-a[j]%(divisor/10))/(divisor/10);
//numOfDigits为相应的(divisor/10)位的值,如当divisor=10时,求的是个位数
int num=++b[numOfDigist][0];//用b中第一列的元素来储存每行中元素的个数
b[numOfDigist][num]=a[j];
}
}
void collectElments(int a[],int b[10][len+1])
{
int k=0;
for(int i=0;i<10;i++)
for(int j=1;j<=b[i][0];j++)
a[k++]=b[i][j];
}
void zeroBucket(int b[][len+1])
{
for(int i=0;i<10;i++)
for(int j=0;j<len+1;j++)
b[i][j]=0;
}
桶排序JAVA
public static void basket(int data[])//data为待排序数组
{
int n=data.length;
int bask[][]=new int[10][n];
int index[]=new int[10];
int max=Integer.MIN_VALUE;
for(int i=0;i<n;i++)
{
max=max>(Integer.toString(data[i]).length())?max:(Integer.toString(data[i]).length());
}
String str;
for(int i=max-1;i>=0;i--)
{
for(int j=0;j<n;j++)
{
str="";
if(Integer.toString(data[j]).length()<max)
{
for(int k=0;k<max-Integer.toString(data[j]).length();k++)
str+="0";
}
str+=Integer.toString(data[j]);
bask[str.charAt(i)-'0'][index[str.charAt(i)-'0']++]=data[j];
}
int pos=0;
for(int j=0;j<10;j++)
{
for(int k=0;k<index[j];k++)
{
data[pos++]=bask[j][k];
}
}
for(intx=0;x<10;x++)index[x]=0;
}
}
桶排序PAS
program barrel_sort;
var
a:array[0..100] of integer;
i,k,n:integer;
begin
for i:=0 to 100 do a[i]:=0;{初始化}
readln(n);
for i:=1 to n do
begin
read(k);
a[k]:=a[k]+1;{将等于k的值全部装入第k桶中}
end;
for i:=0 to 100 do
while a[i]>0 do
begin
write(i:6);
a[i]:=a[i]-1;
end;{输出排序结构}
end.
//这段应该是鸽巢排序，桶排序应该有段桶内比较排序的函数
桶排序海量数据
一年的全国高考考生人数为500 万，分数使用标准分，最低100 ，最高900 ，没有小数，要求对这500 万元素的数组进行排序。
分析：对500W数据排序，如果基于比较的先进排序，平均比较次数为O(5000000*log5000000)≈1.112亿。但是我们发现，这些数据都有特殊的条件： 100=<score<=900。那么我们就可以考虑桶排序这样一个“投机取巧”的办法、让其在毫秒级别就完成500万排序。
方法：创建801(900-100)个桶。将每个考生的分数丢进f(score)=score-100的桶中。这个过程从头到尾遍历一遍数据只需要500W次。然后根据桶号大小依次将桶中数值输出，即可以得到一个有序的序列。而且可以很容易的得到100分有***人，501分有***人。
实际上，桶排序对数据的条件有特殊要求，如果上面的分数不是从100-900，而是从0-2亿，那么分配2亿个桶显然是不可能的。所以桶排序有其局限性，适合元素值集合并不大的情况。
桶排序典型
在一个文件中有10G个整数，乱序排列，要求找出中位数。内存限制为2G。只写出思路即可（内存限制为2G意思是可以使用2G空间来运行程序，而不考虑本机上其他软件内存占用情况。） 关于中位数：数据排序后，位置在最中间的数值。即将数据分成两部分，一部分大于该数值，一部分小于该数值。中位数的位置：当样本数为奇数时，中位数=(N+1)/2 ; 当样本数为偶数时，中位数为N/2与1+N/2的均值（那么10G个数的中位数，就第5G大的数与第5G+1大的数的均值了）。
分析：既然要找中位数，很简单就是排序的想法。那么基于字节的桶排序是一个可行的方法。
思想：将整型的每1byte作为一个关键字，也就是说一个整形可以拆成4个keys，而且最高位的keys越大，整数越大。如果高位keys相同，则比较次高位的keys。整个比较过程类似于字符串的字典序。
第一步:把10G整数每2G读入一次内存，然后一次遍历这536,870,912即（1024*1024*1024）*2 /4个数据。每个数据用位运算">>"取出最高8位(31-24)。这8bits(0-255)最多表示256个桶，那么可以根据8bit的值来确定丢入第几个桶。最后把每个桶写入一个磁盘文件中，同时在内存中统计每个桶内数据的数量NUM[256]。
代价：(1) 10G数据依次读入内存的IO代价(这个是无法避免的，CPU不能直接在磁盘上运算)。(2)在内存中遍历536,870,912个数据，这是一个O(n)的线性时间复杂度。(3)把256个桶写回到256个磁盘文件空间中，这个代价是额外的，也就是多付出一倍的10G数据转移的时间。
第二步：根据内存中256个桶内的数量NUM[256]，计算中位数在第几个桶中。很显然，2,684,354,560个数中位数是第1,342,177,280个。假设前127个桶的数据量相加，发现少于1,342,177,280，把第128个桶数据量加上，大于1,342,177,280。说明，中位数必在磁盘的第128个桶中。而且在这个桶的第1,342,177,280-N(0-127)个数位上。N(0-127)表示前127个桶的数据量之和。然后把第128个文件中的整数读入内存。(若数据大致是均匀分布的，每个文件的大小估计在10G/256=40M左右，当然也不一定，但是超过2G的可能性很小)。注意，变态的情况下，这个需要读入的第128号文件仍然大于2G，那么整个读入仍然可以按照第一步分批来进行读取。
代价：(1)循环计算255个桶中的数据量累加，需要O(M)的代价，其中m<255。(2)读入一个大概80M左右文件大小的IO代价。
第三步：继续以内存中的某个桶内整数的次高8bit（他们的最高8bit是一样的）进行桶排序(23-16)。过程和第一步相同，也是256个桶。
第四步：一直下去，直到最低字节(7-0bit)的桶排序结束。我相信这个时候完全可以在内存中使用一次快排就可以了。
整个过程的时间复杂度在O(n)的线性级别上(没有任何循环嵌套)。但主要时间消耗在第一步的第二次内存-磁盘数据交换上，即10G数据分255个文件写回磁盘上。一般而言，如果第二步过后，内存可以容纳下存在中位数的某一个文件的话，直接快排就可以了（修改者注：我想，继续桶排序但不写回磁盘，效率会更高？）。
[2]
孤立点：V中不与E中任一条边关联的点称为D的孤立点．
简单图：不含平行边的图称为简单图．
完备图：图中任两个顶点U与u之间，恰有两条有向边(u，v)，及(v，u)，则称该有向图D为完备图．
基本图：把有向图D的每条边除去定向就得到一个相应的无向图G，称G为D的基本图．称D为G的定向图．
[2]
强连通图：给定有向图G=(VE)，并且给定该图G中的任意两个结点u和v，如果结点u与结点v相互可达，即至少存在一条路径可以由结点u开始，到结点v终止，同时存在至少有一条路径可以由结点v开始，到结点u终止，那么就称该有向图G是强连通图。
弱连通图:若至少有一对结点不满足单向连通，但去掉边的方向后从无向图的观点看是连通图，则D称为弱连通图．
单向连通图:若每对结点至少有一个方向是连通的，则D称为单向连通图.
[3]
强连通分支:有向图G的极大强连通子图称为该有向图的强连通分支。
[4]
有向通路：无环有向图D中总存在这样一个独立集5，使得y—Js中任何一点"，存在H∈S，从M到"有长度不超过2的有向通路．
[5]
除了孤立顶点外，任意顶点都至少与一条边相关联，因此，任何有向图，不考虑孤立顶点，可以由其边集完



全描述．例如，如果D的边如下：
(1，1)，(1，2)，(1，3)，(1，4)，(2，2)，(2，3)，(2，4)，(3，3)，(3，4)，(4，4)，
注意，我们是按照字典序列出D的边的，只不过这里不是a，b，c，…，而是1，2，3.....
依照这种思想，我们可以用矩阵来完全地描述任何有向图，这就是有向图的邻接矩阵．
[6]
对于有向图最短路问题，计算步骤与求解无向图最短路问题相同，主要区别在于：无向图最短路问题使用单标号法。单标号法是对每一点赋予一个路权标号；而有向最短路问题使用双标号法．双标号法是对每一点赋予两个标号：路径和路权。
[7]
对于一个无向图来说，如果它是连通的，那么它的任意两个顶点之问必存在一条路径，因此，通过这一路径可从一个顶点“到达”另一个顶点，若从顶点“可以到达u，则从u也可以到达“，也即v和u之间是互相可以到达的。
对于有向图，情形就不同了，因为存在从u到v的路径，并不蕴涵也存在从v到u的路径。
设D是一个有向图，且u、v∈D，若存在从顶点u到顶点v的一条路径，则称从顶点v到顶点u可达。
可达的慨念与从u到v的各种路径的数目及路径的长度无关。另外，为了完备起见，规定任一顶点到达它自身的是可达的。
可达性是一个有向图顶点的二元关系，依照定义，它是自反的，且是传递的。一般来说，可达不是对称的，也不是反对称的。
后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点，在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后遍历根结点。即：
若二叉树为空则结束返回，
否则：



（1）后序遍历左子树
（2）后序遍历右子树
（3）访问根结点
如右图所示二叉树
后序遍历结果：DEBFCA
已知前序遍历和中序遍历，就能确定后序遍历。
[1]
后序遍历算法1
/*
public class BTNode  //二叉树节点类型
{
    public BTNode lchild;
    public BTNode rchild;
    public char data;
}
*/
/*
public string btstr                 //全局变量
*/
public string postOrder(BTNode t)
{
    btstr="";                         
    postOrder1(r);
    return btstr;
}
public string postOrder1(BTNode t)
{
    if(t!=null)
    {
        
        postOrder(t.lchild);
        postOrder(t.rchild);
        
bstr+=t.data.ToString()+" ";
    }
}
后序遍历算法2
PROCEDURE POSTRAV(BT)
IF BT<>0 THEN
{
    POSTRAV(L(BT))
    POSTRAV(R(BT))
    OUTPUT V(BT)
}
RETURN
后序遍历算法3
struct btnode {
    int d;
    struct btnode *lchild;
    struct btnode *rchild;
};
void postrav(struct btnode *bt) {
    if(bt!=NULL) {
    postrav(bt->lchild);
    postrav(bt->rchild);
    printf("%d ",bt->d);
    }
}
后序遍历算法4
procedure last(bt:tree);
begin
    if bt<>nil then begin
        last (bt^.left);
        last (bt^.right);
        write(bt^.data);
    end;
end;
后序遍历算法5
public class TreeNode{
    intval;
    TreeNodeleft;
    TreeNoderight;
    TreeNode(intx){
        val = x;
    }
}
public void postOrder(TreeNode biTree){
    TreeNode leftTree = biTree.left;
    if (leftTree != null) {
        postOrder(leftTree);
    }
    TreeNode rightTree = biTree.right;
    if(rightTree != null){
        postOrder(rightTree);
    }
    System.out.printf(biTree.val+"");
}
后序遍历核心思想
首先要搞清楚先序、中序、后序的非递归算法共同之处：用栈来保存先前走过的路径，以便可以在访问完子树后,可以利用栈中的信息,回退到当前节点的双亲节点,进行下一步操作。
后序遍历的非递归算法是三种顺序中最复杂的，原因在于，后序遍历是先访问左、右子树,再访问根节点，而在非递归算法中，利用栈回退到时，并不知道是从左子树回退到根节点，还是从右子树回退到根节点，如果从左子树回退到根节点，此时就应该去访问右子树，而如果从右子树回退到根节点，此时就应该访问根节点。所以相比前序和后序，必须得在压栈时添加信息，以便在退栈时可以知道是从左子树返回，还是从右子树返回进而决定下一步的操作。
[2]
后序遍历算法1
void postrav1(struct btnode* bt)
{
    struct btnode* p;
    struct
    {
        struct btnode* pt;
        int tag;
    }st[MaxSize];
    
    int top=-1;
    top++;
    st[top].pt=bt;
    st[top].tag=1;
    while(top>-1)/*栈不为空*/
    {
        if(st[top].tag==1)/*不能直接访问的情况*/
        {
            p=st[top].pt;
            top--;
            if(p!=NULL)
            {
                top++;/*根结点*/
                st[top].pt=p;
                st[top].tag=0;
                top++;/*右孩子结点*/
                st[top].pt=p->p->rchild;
                st[top].tag=1;
                top++;/*左孩子结点*/
                st[top].pt=p->lchild;
                st[top].tag=1;
            }
        }
        if(st[top].tag==0)/*直接访问的情况*/
        {
            printf("%d",st[top].pt->d);
            top--;
        }

    }
    
}
后序遍历算法2
void postrav2(struct btnode* bt)
{
    struct btnode* st[MaxSize],*p;
    int flag,top=-1;
    if(bt!=NULL) {
        do {
            while(bt!=NULL) {
                top++;
                st[top]=bt;
                bt=bt->lchild;
            }
            p=NULL;
            flag=1;
            while(top!=-1&&flag) {
                bt=st[top];
                if(bt->rchild==p) {
                    printf("%d",bt->d);
                    top--;
                    p=bt;
                } else {
                    bt=bt->rchild;
                    flag=0;
                }
            }
        }while(top!=-1)
        printf("\n");
    }
}
首先绘制远山，然后草地，最后树木等
“画家算法”表示头脑简单的画家首先绘制距离较远的场景，然后用绘制距离较近的场景覆盖较远的部分。画家算法首先将场景中的多边形根据深度进行排序，然后按照顺序进行描绘。这种方法通常会将不可见的部分覆盖，这样就可以解决可见性问题。
画家算法无法处理相互重叠的多边形在有些场合下，画家算法可能无法解决可见性问题。在这个例子中，多边形 A、B、C 互相重叠，我们无法确定哪一个多边形在上面，哪一个在下面，我们也无法确定两个多边形什么时候在三维空间中交叉。在这种情况下必须用一些方法对这些多边形进行切分、排序。1972年提出的Newell算法就是切分类似多边形的一种方法，在计算几何领域人们已经提出了许许多多的解决方法。
一些基本的画家算法实现方法也可能效率很低，因为这将使得系统将可见多边形集合中的每个点都进行渲染，而没有考虑这些多边形在最终场景中可能被其它部分遮挡。这也就是说，对于细致的场景来说，画家算法可能会过度地消耗计算机资源。
[1]
这种算法首先绘制距离观察者较近的物体，已经进行绘制的部分不再进行其它的绘制过程。在计算机图形系统中，这种方法由于无需根据光照、纹理等参数计算被较近物体遮挡的远处物体的颜色，所以效率非常高。但是，这种方法也有许多与普通画家算法同样的问题。
画家算法的这些缺陷导致了深度缓冲技术的发展，深度缓冲技术可以看作是画家算法的一个发展，它根据逐个像素的信息解决深度冲突的问题，并且抛弃了对于深度渲染顺序的依赖。即使在这样的系统中，有时也使用画家算法的变体。由于深度缓冲实现通常是基于硬件中的固定精度深度缓冲寄存器，因此舍入误差就会带来一些显示问题，即在多边形连接的地方会出现重叠或者间隙。为了避免这种问题，一些图形处理引擎使用了“过度渲染”的方法，即根据画家算法的顺序绘制两个多边形中受影响的边界。这也就是说有些像素如同在画家算法中那样实际上绘制了两次，但是由于图像中只有很少的一部分才做这样的处理，因此对于性能的影响很小。
[2]
正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。
正则表达式是对字符串（包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为“元字符”））操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。正则表达式是一种文本模式，该模式描述在搜索文本时要匹配的一个或多个字符串。
[1]
正则表达式的“鼻祖”或许可一直追溯到科学家对人类神经系统工作原理的早期研究。美国新泽西州的Warren McCulloch和出生在美国底特律的Walter Pitts这两位神经生理方面的科学家，研究出了一种用数学方式来描述神经网络的新方法，他们创造性地将神经系统中的神经元描述成了小而简单的自动控制元，从而作出了一项伟大的工作革新。
在1951 年,一位名叫Stephen Kleene的数学科学家，他在Warren McCulloch和Walter Pitts早期工作的基础之上，发表了一篇题目是《神经网事件的表示法》的论文，利用称之为正则集合的数学符号来描述此模型，引入了正则表达式的概念。正则表达式被作为用来描述其称之为“正则集的代数”的一种表达式，因而采用了“正则表达式”这个术语。
之后一段时间，人们发现可以将这一工作成果应用于其他方面。Ken Thompson就把这一成果应用于计算搜索算法的一些早期研究，Ken Thompson是 Unix的主要发明人，也就是大名鼎鼎的Unix之父。Unix之父将此符号系统引入编辑器QED，然后是Unix上的编辑器ed，并最终引入grep。Jeffrey Friedl 在其著作《Mastering Regular Expressions (2nd edition)》（中文版译作：精通正则表达式，已出到第三版）中对此作了进一步阐述讲解，如果你希望更多了解正则表达式理论和历史，推荐你看看这本书。
自此以后，正则表达式被广泛地应用到各种UNIX或类似于UNIX的工具中，如大家熟知的Perl。Perl的正则表达式源自于Henry Spencer编写的regex，之后已演化成了pcre（Perl兼容正则表达式Perl Compatible Regular Expressions），pcre是一个由Philip Hazel开发的、为很多现代工具所使用的库。正则表达式的第一个实用应用程序即为Unix中的 qed 编辑器。
然后，正则表达式在各种计算机语言或各种应用领域得到了广大的应用和发展，演变成为计算机技术森林中的一只形神美丽且声音动听的百灵鸟。
以上是关于正则表达式的起源和发展的历史描述，如今正则表达式在基于文本的编辑器和搜索工具中依然占据着一个非常重要的地位。
在最近的六十年中，正则表达式逐渐从模糊而深奥的数学概念，发展成为在计算机各类工具和软件包应用中的主要功能。不仅仅众多UNIX工具支持正则表达式，近二十年来，在WINDOWS的阵营下，正则表达式的思想和应用在大部分 Windows 开发者工具包中得到支持和嵌入应用！从正则表达式在Microsoft Visual Basic 6 或 Microsoft VBScript到.NET Framework中的探索和发展，WINDOWS系列产品对正则表达式的支持发展到无与伦比的高度，几乎所有 Microsoft 开发者和所有.NET语言都可以使用正则表达式。如果你是一位接触计算机语言的工作者，那么你会在主流操作系统（*nix[Linux, Unix等]、Windows、HP、BeOS等）、主流的开发语言（delphi、Scala、PHP、C#、Java、C++、Objective-c、Swift、VB、Javascript、Ruby以及Python等）、数以亿万计的各种应用软件中，都可以看到正则表达式优美的舞姿。
[1]
给定一个正则表达式和另一个字符串，我们可以达到如下的目的：
1. 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）：
2. 可以通过正则表达式，从字符串中获取我们想要的特定部分。
正则表达式的特点是：
1. 灵活性、逻辑性和功能性非常强；
2. 可以迅速地用极简单的方式达到字符串的复杂控制。
3. 对于刚接触的人来说，比较晦涩难懂。
由于正则表达式主要应用对象是文本，因此它在各种文本编辑器场合都有应用，小到著名编辑器EditPlus，大到Microsoft Word、Visual Studio等大型编辑器，都可以使用正则表达式来处理文本内容。
正则引擎主要可以分为两大类：一种是DFA，一种是NFA。这两种引擎都有了很久的历史(至今二十多年)，当中也由这两种引擎产生了很多变体！于是POSIX的出台规避了不必要变体的继续产生。这样一来，主流的正则引擎又分为3类：一、DFA，二、传统型NFA，三、POSIX NFA。
DFA 引擎在线性时状态下执行，因为它们不要求回溯（并因此它们永远不测试相同的字符两次）。DFA 引擎还可以确保匹配最长的可能的字符串。但是，因为 DFA 引擎只包含有限的状态，所以它不能匹配具有反向引用的模式；并且因为它不构造显示扩展，所以它不可以捕获子表达式。
传统的 NFA 引擎运行所谓的“贪婪的”匹配回溯算法，以指定顺序测试正则表达式的所有可能的扩展并接受第一个匹配项。因为传统的 NFA 构造正则表达式的特定扩展以获得成功的匹配，所以它可以捕获子表达式匹配和匹配的反向引用。但是，因为传统的 NFA 回溯，所以它可以访问完全相同的状态多次（如果通过不同的路径到达该状态）。因此，在最坏情况下，它的执行速度可能非常慢。因为传统的 NFA 接受它找到的第一个匹配，所以它还可能会导致其他（可能更长）匹配未被发现。
POSIX NFA 引擎与传统的 NFA 引擎类似，不同的一点在于：在它们可以确保已找到了可能的最长的匹配之前，它们将继续回溯。因此，POSIX NFA 引擎的速度慢于传统的 NFA 引擎；并且在使用 POSIX NFA 时，您恐怕不会愿意在更改回溯搜索的顺序的情况下来支持较短的匹配搜索，而非较长的匹配搜索。
使用DFA引擎的程序主要有：awk,egrep,flex,lex,MySQL,Procmail等；
使用传统型NFA引擎的程序主要有：GNU Emacs,Java,ergp,less,more,.NET语言,PCRE library,Perl,PHP,Python,Ruby,sed,vi；
使用POSIX NFA引擎的程序主要有：mawk,Mortice Kern Systems’ utilities,GNU Emacs(使用时可以明确指定)；
也有使用DFA/NFA混合的引擎：GNU awk,GNU grep/egrep,Tcl。
举例简单说明NFA与DFA工作的区别：
比如有字符串this is yansen’s blog，正则表达式为 /ya(msen|nsen|nsem)/ (不要在乎表达式怎么样，这里只是为了说明引擎间的工作区别)。 NFA工作方式如下，先在字符串中查找 y 然后匹配其后是否为 a ，如果是 a 则继续，查找其后是否为 m 如果不是则匹配其后是否为 n (此时淘汰msen选择支)。然后继续看其后是否依次为 s,e，接着测试是否为 n ，是 n 则匹配成功，不是则测试是否为 m 。为什么是 m ？因为 NFA 工作方式是以正则表达式为标准，反复测试字符串，这样同样一个字符串有可能被反复测试了很多次！
而DFA则不是如此，DFA会从 this 中 t 开始依次查找 y，定位到 y ，已知其后为a，则查看表达式是否有 a ，此处正好有a 。然后字符串a 后为n ，DFA依次测试表达式，此时 msen 不符合要求淘汰。nsen 和 nsem 符合要求，然后DFA依次检查字符串，检测到sen 中的 n 时只有nsen 分支符合，则匹配成功！
由此可以看出来，两种引擎的工作方式完全不同，一个(NFA)以表达式为主导，一个(DFA)以文本为主导！一般而论，DFA引擎则搜索更快一些！但是NFA以表达式为主导，反而更容易操纵，因此一般程序员更偏爱NFA引擎！ 两种引擎各有所长，而真正的引用则取决与你的需要以及所使用的语言。
[2]
（摘自《正则表达式之道》）
正则表达式由一些普通字符和一些元字符（metacharacters）组成。普通字符包括大小写的字母和数字，而元字符则具有特殊的含义，我们下面会给予解释。
在最简单的情况下，一个正则表达式看上去就是一个普通的查找串。例如，正则表达式"testing"中没有包含任何元字符，它可以匹配"testing"和"testing123"等字符串，但是不能匹配"Testing"。
要想真正的用好正则表达式，正确的理解元字符是最重要的事情。下表列出了所有的元字符和对它们的一个简短的描述。
元字符
描述
\
将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\n。“\n”匹配换行符。序列“\\”匹配“\”而“\(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。
^
匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。
$
匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。
*
匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。*等价于{0,}。
+
匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。
?
匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。?等价于{0,1}。
{n}
n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。
{n,}
n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。
{n,m}
m和n均为非负整数，其中n<=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。
?
当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多地匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少地匹配“o”，得到结果 ['o', 'o', 'o', 'o']
.点
匹配除“\n”和"\r"之外的任何单个字符。要匹配包括“\n”和"\r"在内的任何字符，请使用像“[\s\S]”的模式。
(pattern)
匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“\(”或“\)”。
(?:pattern)
非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
(?=pattern)
非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
(?!pattern)
非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
(?<=pattern)
非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。
*python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等
(?<!patte_n)
非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。
*python的正则表达式没有完全按照正则表达式规范实现，所以一些高级特性建议使用其他语言如java、scala等
x|y
匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[z|f]ood”则匹配“zood”或“food”。
[xyz]
字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。
[^xyz]
负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”任一字符。
[a-z]
字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。
注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.
[^a-z]
负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。
\b
匹配一个单词的边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”；“\b1_”可以匹配“1_23”中的“1_”，但不能匹配“21_3”中的“1_”。
\B
匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。
\cx
匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。
\d
匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持
\D
匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持
\f
匹配一个换页符。等价于\x0c和\cL。
\n
匹配一个换行符。等价于\x0a和\cJ。
\r
匹配一个回车符。等价于\x0d和\cM。
\s
匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。
\S
匹配任何可见字符。等价于[^ \f\n\r\t\v]。
\t
匹配一个制表符。等价于\x09和\cI。
\v
匹配一个垂直制表符。等价于\x0b和\cK。
\w
匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的"单词"字符使用Unicode字符集。
\W
匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。
\xn
匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。
\num
匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。
\n
标识一个八进制转义值或一个向后引用。如果\n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。
\nm
标识一个八进制转义值或一个向后引用。如果\nm之前至少有nm个获得子表达式，则nm为向后引用。如果\nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\nm将匹配八进制转义值nm。
\nml
如果n为八进制数字（0-7），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。
\un
匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（&copy;）。
\p{P}
小写 p 是 property 的意思，表示 Unicode 属性，用于 Unicode 正表达式的前缀。中括号内的“P”表示Unicode 字符集七个字符属性之一：标点字符。
其他六个属性：
L：字母；
M：标记符号（一般不会单独出现）；
Z：分隔符（比如空格、换行等）；
S：符号（比如数学符号、货币符号等）；
N：数字（比如阿拉伯数字、罗马数字等）；
C：其他字符。
*注：此语法部分语言不支持，例：javascript。
\<
\>
匹配词（word）的开始（\<）和结束（\>）。例如正则表达式\<the\>能够匹配字符串"for the wise"中的"the"，但是不能匹配字符串"otherwise"中的"the"。注意：这个元字符不是所有的软件都支持的。( )将( 和 ) 之间的表达式定义为“组”（group），并且将匹配这个表达式的字符保存到一个临时区域（一个正则表达式中最多可以保存9个），它们可以用 \1 到\9 的符号来引用。|将两个匹配条件进行逻辑“或”（or）运算。例如正则表达式(him|her) 匹配"it belongs to him"和"it belongs to her"，但是不能匹配"it belongs to them."。注意：这个元字符不是所有的软件都支持的。
最简单的元字符是点，它能够匹配任何单个字符（注意不包括换行符）。假定有个文件test.txt包含以下几行内容：
he is arat
he is in a rut
the food is Rotten
I like root beer
我们可以使用grep命令来测试我们的正则表达式，grep命令使用正则表达式去尝试匹配指定文件的每一行，并将至少有一处匹配表达式的所有行显示出来。命令
grep r.t test.txt
在test.txt文件中的每一行中搜索正则表达式r.t，并打印输出匹配的行。正则表达式r.t匹配一个r接着任何一个字符再接着一个t。所以它将匹配文件中的rat和rut，而不能匹配Rotten中的Rot，因为正则表达式是大小写敏感的。要想同时匹配大写和小写字母，应该使用字符区间元字符（方括号）。正则表达式[Rr]能够同时匹配R和r。所以，要想匹配一个大写或者小写的r接着任何一个字符再接着一个t就要使用这个表达式：[Rr].t。
要想匹配行首的字符要使用抑扬字符（^）——有时也被叫做插入符。例如，想找到text.txt中行首"he"打头的行，你可能会先用简单表达式he，但是这会匹配第三行的the，所以要使用正则表达式^he，它只匹配在行首出现的he。
有时候指定“除了×××都匹配”会比较容易达到目的，当抑扬字符（^）出方括号中时，它表示“排除”，例如要匹配he ，但是排除前面是t or s的情形（也就是the和she），可以使用：[^st]he。
可以使用方括号来指定多个字符区间。例如正则表达式[A-Za-z]匹配任何字母，包括大写和小写的；正则表达式[A-Za-z][A-Za-z]* 匹配一个字母后面接着0或者多个字母（大写或者小写）。当然我们也可以用元字符+做到同样的事情，也就是：[A-Za-z]+ ，和[A-Za-z][A-Za-z]*完全等价。但是要注意元字符+ 并不是所有支持正则表达式的程序都支持的。关于这一点可以参考后面的正则表达式语法支持情况。
要指定特定数量的匹配，要使用大括号（注意并不是所有扩展正则表达式的实现都支持大括号。此外，根据具体的实现，您可能需要先使用反斜杠对其进行转义。）。想匹配所有10和100的实例而排除1和 1000，可以使用：10\{1,2\} 或 10{1, 2}，这个正则表达式匹配数字1后面跟着1或者2个0的模式。在这个元字符的使用中一个有用的变化是忽略第二个数字，例如正则表达式0\{3,\} 或 0{3,} 将匹配至少3个连续的0。
[2]
例1
将所有方法foo(a,b,c)的实例改为foo(b,a,c)。这里a、b和c可以是任何提供给方法foo()的参数。也就是说我们要实现这样的转换：
之前 之后
foo(10,7,2) foo(7,10,2)
foo(x+13,y-2,10) foo(y-2,x+13,10)
foo( bar(8), x+y+z, 5) foo( x+y+z, bar(8), 5)
下面这条替换命令能够实现这一方法：
:%s/foo\(([^,]*),([^,]*),([^,]*)\)/foo\(\2,\1,\3\)/g
让我们把它打散来加以分析。写出这个表达式的基本思路是找出foo()和它的括号中的三个参数的位置。第一个参数是用这个表达式来识别的：：([^,]*)，我们可以从里向外来分析它：
[^,] 除了逗号之外的任何字符
[^,]* 0或者多个非逗号字符
([^,]*) 将这些非逗号字符标记为\1，这样可以在之后的替换模式表达式中引用它
([^,]*), 我们必须找到0或者多个非逗号字符后面跟着一个逗号，并且非逗号字符那部分要标记出来以备后用。
正是指出一个使用正则表达式常见错误的最佳时机。为什么我们要使用[^,]*这样的一个表达式，而不是更加简单直接的写法，例如：.*，来匹配第一个参数呢？设想我们使用模式.*来匹配字符串"10,7,2"，它应该匹配"10,"还是"10,7,"？为了解决这个两义性（ambiguity），正则表达式规定一律按照最长的串来，在上面的例子中就是"10,7,"，显然这样就找出了两个参数而不是我们期望的一个。所以，我们要使用[^,]*来强制取出第一个逗号之前的部分。
这个表达式我们已经分析到了：foo\(([^,]*)，这一段可以简单的翻译为“当你找到foo(就把其后直到第一个逗号之前的部分标记为\1”。然后我们使用同样的办法标记第二个参数为\2。对第三个参数的标记方法也是一样，只是我们要搜索所有的字符直到右括号。我们并没有必要去搜索第三个参数，因为我们不需要调整它的位置，但是这样的模式能够保证我们只去替换那些有三个参数的foo()方法调用，在foo()是一个重载（overloading）方法时这种明确的模式往往是比较保险的。然后，在替换部分，我们找到foo()的对应实例，然后利用标记好的部分进行替换，是把第一和第二个参数交换位置。
正则表达式语法支持情况
命令或环境
.
[ ]
^
$
\( \)
\{ \}
?
+
|
( )
vi
√
√
√
√
√
Visual C++
√
√
√
√
√
awk
√
√
√
√
awk是支持该语法的，只是要在命令
行加入 --posix or --re-interval参数即可，可见
man awk中的interval expression
√
√
√
√
sed
√
√
√
√
√
√
delphi
√
√
√
√
√
√
√
√
√
python
√
√
√
√
√
√
√√√√java
√
√
√
√
√
√
√√√√javascript
√
√
√
√
√
√
√
√
√
php
√
√
√
√
√
perl
√
√
√
√
√
√
√
√
√
C#
√
√
√
√
√√√
√
√
√
.
[ ]
^
$
四个字符是所有语言都支持的正则表达式，所以这四个是基础的正则表达式。正则难理解因为里面有一个等价的概念，这个概念大大增加了理解难度，让很多初学者看起来会懵，如果把等价都恢复成原始写法，自己书写正则就超级简单了，就像说话一样去写你的正则了：
等价：
等价是等同于的意思，表示同样的功能，用不同符号来书写。
?,*,+,\d,\w 都是等价字符　　?等价于匹配长度{0,1}　　*等价于匹配长度{0,} 　　+等价于匹配长度{1,}　　\d等价于[0-9]
\D等价于[^0-9]　　\w等价于[A-Za-z_0-9]
\W等价于[^A-Za-z_0-9]。
常用运算符与表达式：　　^ 开始　　（） 域段　　[] 包含,默认是一个字符长度　　[^] 不包含,默认是一个字符长度　　{n,m} 匹配长度 　　. 任何单个字符(\. 字符点)　　| 或　　\ 转义　　$ 结尾　　[A-Z] 26个大写字母　　[a-z] 26个小写字母　　[0-9] 0至9数字
[A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字　　， 分割　　.　　　　分割语法：　　[A,H,T,W] 包含A或H或T或W字母　　[a,h,t,w] 包含a或h或t或w字母　　[0,3,6,8] 包含0或3或6或8数字
语法与释义：　　基础语法 "^([]{})([]{})([]{})$"　　正则字符串 = "开始（[包含内容]{长度}）（[包含内容]{长度}）（[包含内容]{长度}）结束" 　　　　?,*,+,\d,\w 这些都是简写的,完全可以用[]和{}代替，在(?:)(?=)(?!)(?<=)(?<!)(?i)(*?)(+?)这种特殊组合情况下除外。　　初学者可以忽略?,*,+,\d,\w一些简写标示符，学会了基础使用再按表自己去等价替换
实例：　　字符串；tel:086-0666-88810009999　　原始正则："^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$" 　　速记理解：开始 "tel:普通文本"[0-9数字]{1至3位}"-普通文本"[0数字][0-9数字]{2至3位}"-普通文本"[0-9数字]{8至11位} 结束"　　等价简写后正则写法："^tel:\d{1,3}-[0]\d{2,3}-\d{8,11}$" ，简写语法不是所有语言都支持。
正则表达式实例目录
【1】 正则表达式应用——替换指定内容到行尾
【2】 正则表达式应用——数字替换
【3】 正则表达式应用——删除每一行行尾的指定字符
【4】 正则表达式应用——替换带有半角括号的多行
【5】 正则表达式应用——删除空行
【6】 正则表达式应用——实例应用
正则表达式应用实例
【1】正则表达式应用——替换指定内容到行尾
原始文本如下面两行
abc aaaaa
123 abc 444
希望每次遇到“abc”，则替换“abc”以及其后到行尾的内容为“abc efg”
即上面的文本最终替换为：
abc efg
123 abc efg
解决：
① 在替换对话框，查找内容里输入“abc.*”，替换内容输入为“abc efg”
② 同时勾选“正则表达式”复选框，然后点击“全部替换”按钮
其中，符号的含义如下：
“.” =匹配任意字符
“*” =匹配0次或更多
注意：其实就是正则表达式替换，这里只是把一些曾经提出的问题加以整理，单纯从正则表达式本身来说，就可以引申出成千上万种特例。
【2】正则表达式应用——数字替换
希望把
asdadas123asdasdas456asdasdasd789asdasd
替换为:
asdadas[123]asdasdas[456]asdasdasd[789]asdasd
在替换对话框里面，勾选“正则表达式”复选框；
在查找内容里面输入“([0-9])([0-9])([0-9])”，不含引号
“替换为:”里面输入“[\1\2\3]”，不含引号
####备注####：查找（[0-9]+） 替换：[\1] 更简单通用些
范围为你所操作的范围，然后选择替换即可。
实际上这也是正则表达式的使用特例，“[0-9]”表示匹配0～9之间的任何特例，同样“[a-z]”就表示匹配a～z之间的任何特例
上面重复使用了“[0-9]”，表示连续出现的三个数字
括号用来选择原型，进行分组，替换时要用
“\1”代表第一个“[0-9]”对应的原型，“\2”代表第二个“[0-9]”对应的原型，依此类推
“[”|“]”为单纯的字符，表示添加“[”或“]”，如果输入“其它\1\2\3其它”，则替换结果为：
asdadas其它123其它asdasdas其它456其它asdasdasd其它789其它asdasd
功能增强：
如果将查找内容“[0-9][0-9][0-9]”改为“[0-9]*[0-9]”，对应1 或 123 或 12345 或 ...
大家根据需要定制
相关内容还有很多，可以自己参考正则表达式的语法仔
【3】正则表达式应用——删除每一行行尾的指定字符
因为这几个字符在行中也是出现的,所以肯定不能用简单的替换实现
比如
12345 1265345
2345
需要删除每行末尾的“345”
这个也算正则表达式的用法，其实仔细看正则表达式应该比较简单，不过既然有这个问题提出，说明对正则表达式还得有个认识过程，解决方法如下
解决：
在替换对话框中，启用“正则表达式”复选框
在查找内容里面输入“345$”
这里“$”表示从行尾匹配
如果从行首匹配，可以用“^”来实现，不过 EditPlus 有另一个功能可以很简单的删除行首的字符串
a. 选择要操作的行
b. 编辑－格式－删除行注释
c. 在弹出对话框里面输入要清除的行首字符，确定
【4】正则表达式应用——替换带有半角括号的多行
几百个网页中都有下面一段代码：
<script LANGUAGE="JavaScript1.1">
<!--
htmlAdWH('93163607', '728', '90');
//-->
</SCRIPT>
我想把它们都去掉，可是找了很多search & replace的软件，都是只能对“一行”进行操作。
EditPlus 打开几百个网页文件还是比较顺畅的，所以完全可以胜任这个工作。
具体解决方法，在 Editplus 中使用正则表达式，由于“(”、“)”被用做预设表达式（或者可以称作子表达式）的标志，所以查找
“<script LANGUAGE="JavaScript1.1">\n<!--\nhtmlAdWH('93163607', '728', '90'.);\n//-->\n</SCRIPT>\n”
时会提示查找不到，所以也就无法进行替换了，这时可以把“(”、“)”使用任意字符标记替代，即半角句号：“.”。替换内容为
<script LANGUAGE="JavaScript1.1">\n<!--\nhtmlAdWH.'93163607', '728', '90'.;\n//-->\n</SCRIPT>\n
在替换对话框启用“正则表达式”选项，这时就可以完成替换了
补充：
对( ) 这样的特殊符号，应该用\( \)来表示，这也是很标准的regexp语法，可以写为
<script LANGUAGE="JavaScript1.1">\n<!--\nhtmlAdWH\('93163607', '728', '90'\);\n//-->\n</SCRIPT>\n
【5】正则表达式应用——删除空行
启动EditPlus，打开待处理的文本类型文件。
①、选择“查找”菜单的“替换”命令，弹出文本替换对话框。选中“正则表达式”复选框，表明我们要在查找、替换中使用正则表达式。然后，选中“替换范围”中的“当前文件”，表明对当前文件操作。
②、单击“查找内容”组合框右侧的按钮，出现下拉菜单。
③、下面的操作添加正则表达式，该表达式代表待查找的空行。（技巧提示：空行仅包括空格符、制表符、回车符，且必须以这三个符号之一作为一行的开头，并且以回车符结尾，查找空行的关键是构造代表空行的正则表达式）。
直接在"查找"中输入正则表达式“^[ \t]*\n”，注意\t前有空格符。
（1）选择“从行首开始匹配”，“查找内容”组合框中出现字符“^”，表示待查找字符串必须出文本中一行的行首。
（2）选择“字符在范围中”，那么在“^”后会增加一对括号“[]”，当前插入点在括号中。括号在正则表达式中表示，文本中的字符匹配括号中任意一个字符即符合查找条件。
（3）按一下空格键，添加空格符。空格符是空行的一个组成成分。
（4）选择“制表符”，添加代表制表符的“\t”。
（5）移动光标，将当前插入点移到“]”之后，然后选择“匹配 0 次或更多”，该操作会添加星号字符“*”。星号表示，其前面的括号“[]”内的空格符或制表符，在一行中出现0个或多个。
（6）选择“换行符”，插入“\n”，表示回车符。
④、“替换为”组合框保持空，表示删除查找到的内容。单击“替换”按钮逐个行删除空行，或单击“全部替换”按钮删除全部空行（注意：EditPlus有时存在“全部替换”不能一次性完全删除空行的问题，可能是程序BUG，需要多按几次按钮）。
【6】 正则表达式应用——实例应用
1.验证用户名和密码：（"^[a-zA-Z]\w{5,15}$"）正确格式："[A-Z][a-z]_[0-9]"组成,并且第一个字必须为字母6~16位；
2.验证电话号码：（"^(\d{3,4}-)\d{7,8}$"）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx；
3.验证手机号码（包含虚拟号码和新号码段）："^1([38][0-9]|4[5-9]|5[0-3,5-9]|66|7[0-8]|9[89])[0-9]{8}$"；
4.验证身份证号（15位）："\d{14}[[0-9],0-9xX]"，（18位）："\d{17}(\d|X|x)"；
5.验证Email地址：("^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$")；
6.只能输入由数字和26个英文字母组成的字符串：("^[A-Za-z0-9]+$")；
7.整数或者小数：^[0-9]+([.][0-9]+){0,1}$
8.只能输入数字："^[0-9]*$"。
9.只能输入n位的数字："^\d{n}$"。
10.只能输入至少n位的数字："^\d{n,}$"。
11.只能输入m~n位的数字："^\d{m,n}$"。
12.只能输入零和非零开头的数字："^(0|[1-9][0-9]*)$"。
13.只能输入有两位小数的正实数："^[0-9]+(\.[0-9]{2})?$"。
14.只能输入有1~3位小数的正实数："^[0-9]+(\.[0-9]{1,3})?$"。
15.只能输入非零的正整数："^\+?[1-9][0-9]*$"。
16.只能输入非零的负整数："^\-[1-9][0-9]*$"。
17.只能输入长度为3的字符："^.{3}$"。
18.只能输入由26个英文字母组成的字符串："^[A-Za-z]+$"。
19.只能输入由26个大写英文字母组成的字符串："^[A-Z]+$"。
20.只能输入由26个小写英文字母组成的字符串："^[a-z]+$"。
21.验证是否含有^%&',;=?$\"等字符："[%&',;=?$\\^]+"。
22.只能输入汉字："^[\u4e00-\u9fa5]{0,}$"。
23.验证URL："^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$"。
24.验证一年的12个月："^(0?[1-9]|1[0-2])$"正确格式为："01"～"09"和"10"～"12"。
25.验证一个月的31天："^((0?[1-9])|((1|2)[0-9])|30|31)$"正确格式为；"01"～"09"、"10"～"29"和“30”~“31”。
26.获取日期正则表达式：\\d{4}[年|\-|\.]\d{\1-\12}[月|\-|\.]\d{\1-\31}日?
评注：可用来匹配大多数年月日信息。
27.匹配双字节字符(包括汉字在内)：[^\x00-\xff]
评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
28.匹配空白行的正则表达式：\n\s*\r
评注：可以用来删除空白行
29.匹配HTML标记的正则表达式：<(\S*?)[^>]*>.*?</>|<.*? />
评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
30.匹配首尾空白字符的正则表达式：^\s*|\s*$
评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
31.匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*
评注：网上流传的版本功能很有限，上面这个基本可以满足需求
32.匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$
评注：表单验证时很实用
33.匹配腾讯QQ号：[1-9][0-9]{4,}
评注：腾讯QQ号从10 000 开始
34.匹配中国邮政编码：[1-9]\\d{5}(?!\d)
评注：中国邮政编码为6位数字
35.匹配ip地址：([1-9]{1,3}\.){3}[1-9]。
评注：提取ip地址时有用
36.匹配MAC地址：([A-Fa-f0-9]{2}\:){5}[A-Fa-f0-9]
Function IsRegu(Regu,s)
'正则表达式校验
If Regu="" Then
Exit Function
End if
Dim Re,Sre
Set Re = New RegExp
Re.Pattern = Regu
Sre = Re.Test(s)
If Sre = True Then
IsRegu = True
Else
IsRegu = False
End If
End Function
tmp=" "
if (IsRegu("\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*",tmp )) =false then
msgbox "E-mail地址不合法 ！"
FieldCheck#N=false
不同的语言（如PHP和JAVA）、相同语言的不同类库（如来自Sun的Java Regular Expression类库跟Apache Jakarta的正则表达式类库）间，用法会有所差别，在使用的时候，要注意这些差别。
正则表达式验证URL
function IsValidUrl(str){
varregu="^(https?://)"
+"?(([0-9a-z_!~*'().&=+$%-]+:)?[0-9a-z_!~*'().&=+$%-]+@)?"
+"(([0-9]{1,3}\.){3}[0-9]{1,3}"
+"|"
+"([0-9a-z_!~*'()-]+\.)*"
+"([0-9a-z][0-9a-z-]{0,61})?[0-9a-z]\."
+"[a-z]{2,6})"
+"(:[0-9]{1,4})?"
+"((/?)|"
+"(/[0-9a-z_!~*'().;?:@&=+$,%#-]+)+/?)$";
varre=newRegExp(regu);
if(!re.test(str)){
return false;
}
return true;
}
参考：
用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：
(?=exp)也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I'm singing while you're dancing.时，它会匹配sing和danc。
(?<=exp)也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\D)\D{3})+\b，用它对xxxxxxxxxx进行查找时结果是xxxxxxxxx
下面这个例子同时使用了这两种断言：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)
断言用来声明一个应该为真的事实。正则表达式中只有当断言为真时才会继续进行匹配。
如果我们只是想要确保某个字符没有出现，但并不想去匹配它时怎么办？例如，如果我们想查找这样的单词--它里面出现了字母q，但是q后面跟的不是字母u,我们可以尝试这样：
\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词。但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w*\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
零宽度负预测先行断言(?!exp)，断言此位置的后面不能匹配表达式exp。例如：\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字；\b((?!abc)\w)+\b匹配不包含连续字符串abc的单词。
同理，我们可以用(?<!exp),零宽度负回顾后发断言来断言此位置的前面不能匹配表达式exp：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字。
请详细分析表达式(?<=<(\w+)>).*(?=<\/\1>)，这个表达式最能表现零宽断言的真正用途。
一个更复杂的例子：(?<=<(\w+)>).*(?=<\/\1>)匹配不包含属性的简单HTML标签内里的内容。(?<=<(\w+)>)指定了这样的前缀：被尖括号括起来的单词(比如可能是<b>)，然后是.*(任意的字符串),最后是一个后缀(?=<\/\1>)。注意后缀里的\/，它用到了前面提过的字符转义，将”/“转义；\1则是一个反向引用，引用的正是捕获的第一组，前面的(\w+)匹配的内容，这样如果前缀实际上是<b>的话，后缀就是</b>了。整个表达式匹配的是<b>和</b>之间的内容(再次提醒，不包括前缀和后缀本身)。
效率定义
含义
1.单位时间完成的工作量。
2.指最有效地使用社会资源以满足人类的愿望和需要。
示例
1.上课认真听讲有助于提高学习效率。
2.对待学习的态度、习惯与专注的程度及办事的效率，将直接决定你是否是一个有智慧的人，你的生命是否有价值。
3.如果我是董事长，那我的公司就只要做事效率高的人。
4.身为一个领导，一定要懂得如何提高员工的效率。
[1]
效率与效能的关系
效率指在单位时间里完成的工作量，或者说是某一工作所获的成果与完成这一工作所花时间和人力的比值。
"效能"这个词的原意是指事物所蕴藏的有利的作用。而"效能监察"中的"效能"实际指的是行政管理的效能，即行政管理活动这一事物所蕴藏的有利的作用。
效率和效能两者是不相等的，效率是从战略（比较而言）角度考虑的，而效能则是从战术层面考虑的，也就是说，就是大处着眼、小处着手的关系。在现实生活中，不管是企业还是个人，人们关注的重点都在前者，及效率和正确的做事。比如，老板一有什么想法，就发动大家开动脑筋鼓足干劲的工作，同时提出各种提高工作效率的方式方法来指导大家，期望大家能尽快达成某个目标。其实，如果先冷静下来，对问题进行认真分析，也许会发现，这是并不值得做的事情，甚至是对公司业务有害的事情（比如占用公司资源，而没有把资源投入到真正需要的地方），这就是个不考虑效能的例子。
管理大师彼得·德鲁克曾在《有效的主管》一书中简明扼要地指出：“效率是‘以正确的方式做事’，而效能则是‘做正确的事’。效率和效能不应偏废，可这并不意味着效率和效能具有同样的重要性。我们当然希望同时提高效率和效能,但在效率与效能无法兼得时，我们首先应着眼于效能，然后再设法提高效率。”
[2]
效率提高方法
很简单的三步：
1.不浪费时间——积极的做事，不要消极怠工。这一点基本属于时间管理的范畴，时间管理的概念很多，如GTD等。
2.把时间用来干正确的事情--保证自己所做的事情确实能够帮助自己完成目标。
3.从管理学的角度而言，提高效率的途径在于资源的有序分配。通过设立标准流程、操作规程、分工协作等规范化体系，以实现管理系统的良性运作。
[2]
效率概念
1、它指最有效地使用社会资源以满足人类的愿望和需要。
2、给定投入和技术的条件下，经济资源没有浪费，或对经济资源做了能带来最大可能性的满足程度的利用，也是配置效率（allocative efficiency）的一个简化表达。
[1]
效率内涵
鉴于人的欲望的无限性，就一项经济活动而言，最重要的事情当然就是最好地利用其有限的资源。这使




效率

我们不得不面对效率这个关键性的概念。在经济学中我们这样讲：在不会使其他人境况变坏的前提下，如果一项经济活动不再有可能增进任何人的经济福利，则该项经济活动就被认为是有效率的。相反的情况包括：“无法遏制的垄断”，或“恶性无度的污染”，或“没有制衡的政府干预”，等等。这样的经济当然只能生产少于“无上述问题”时该经济原本可以生产的物品，或者还会生产出一大堆不对路的物品。这些都会使消费者的境遇比本该出现的情况要差。这些问题都是资源未能有效配置的后果。
1.它是指的单位时间里实际完成的工作量。因此，所谓效率高，就是在单位时间里实际完成的工作量多，对个人而言，意味着节约了时间。
2.它是输出瓦特数与输入瓦特数之比，若此数越接近 1 ，则显示其效率越好，以在线式 UPS 而言，一般的效率约在 70%~80% 之间，即输入 1000W ，输出约 700W~800W 之间， UPS 本身即消耗 200W~300W 的功率；而离线式与在线交互式 UPS ，其效率约在 80%~95% 之间，其效率较在线式高。
3.效率是指对于有限资源(如原材料，人力现金等)的最佳分配方法.当某些特定的标准被达到的时候，就说达到了效率。
4.达到结果与使用的资源之间的关系。
5.从管理学角度来讲，效率是指在特定时间内，组织的各种投入与产出之间的比率关系。效




效率达人

率与投入成反比，与产出成正比。公共部门的效率包括两方面：一是生产效率，它指生产或者提供服务的平均成本；二是配置效率它指组织所提供的产品或服务是否能够满足利害关系人的不同偏好。
[1]
模拟退火算法(Simulated Annealing，SA)最早的思想是由N. Metropolis
[1] 
等人于1953年提出。1983 年,S. Kirkpatrick 等成功地将退火思想引入到组合优化领域。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法，其出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。模拟退火算法从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。模拟退火算法是一种通用的优化算法，理论上算法具有概率的全局优化性能,目前已在工程中得到了广泛应用，诸如VLSI、生产调度、控制工程、机器学习、神经网络、信号处理等领域。
模拟退火算法是通过赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优的串行结构的优化算法。
模拟退火算法来源于固体退火原理，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。根据Metropolis准则，粒子在温度T时趋于平衡的概率为e(-ΔE/(kT))，其中E为温度T时的内能，ΔE为其改变量，k为Boltzmann常数。用固体退火模拟组合优化问题，将内能E模拟为目标函数值f，温度T演化成控制参数t，即得到解组合优化问题的模拟退火算法：由初始解i和控制参数初值t开始，对当前解重复“产生新解→计算目标函数差→接受或舍弃”的迭代，并逐步衰减t值，算法终止时的当前解即为所得近似最优解，这是基于蒙特卡罗迭代求解法的一种启发式随机搜索过程。退火过程由冷却进度表(Cooling Schedule)控制，包括控制参数的初值t及其衰减因子Δt、每个t值时的迭代次数L和停止条件S。
模拟退火算法的模型
1模拟退火算法可以分解为解空间、目标函数和初始解三部分。
2模拟退火的基本思想:
(1) 初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L
(2) 对k=1, …, L做第(3)至第6步：
(3) 产生新解S′
(4) 计算增量ΔT=C(S′)-C(S)，其中C(S)为评价函数
(5) 若ΔT<0则接受S′作为新的当前解，否则以概率exp(-ΔT/T)接受S′作为新的当前解.
(6) 如果满足终止条件则输出当前解作为最优解，结束程序。
终止条件通常取为连续若干个新解都没有被接受时终止算法。
(7) T逐渐减少，且T->0，然后转第2步。
模拟退火算法的步骤
模拟退火算法新解的产生和接受可分为如下四个步骤：
第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。
第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。
第三步是判断新解是否被接受,判断的依据是一个接受准则，最常用的接受准则是Metropolis准则: 若ΔT<0则接受S′作为新的当前解S，否则以概率exp(-ΔT/T)接受S′作为新的当前解S。
第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。
模拟退火算法与初始值无关，算法求得的解与初始解状态S(是算法迭代的起点)无关；模拟退火算法具有渐近收敛性，已在理论上被证明是一种以概率l 收敛于全局最优解的全局优化算法；模拟退火算法具有并行性。
模拟退火算法作为一种通用的随机搜索算法，现已广泛用于VLSI设计、图像识别和神经网计算机的研究。模拟退火算法的应用如下：
[2]
1、模拟退火算法在VLSI设计中的应用
[2]
利用模拟退火算法进行VLSI的最优设计，是目前模拟退火算法最成功的应用实例之一。用模拟退火算法几乎可以很好地完成所有优化的VLSI设计工作。如全局布线、布板、布局和逻辑最小化等等。
2、模拟退火算法在神经网计算机中的应用
[2]
模拟退火算法具有跳出局部最优陷阱的能力。在Boltzmann机中，即使系统落入了局部最优的陷阱，经过一段时间后，它还能再跳出来，再系统最终将往全局最优值的方向收敛。
3、模拟退火算法在图像处理中的应用
[2]
模拟退火算法可用来进行图像恢复等工作，即把一幅被污染的图像重新恢复成清晰的原图，滤掉其中被畸变的部分。因此它在图像处理方面的应用前景是广阔的。
4、模拟退火算法的其他应用
[2]
除了上述应用外，模拟退火算法还用于其它各种组合优化问题，如TSP和Knapsack问题等。大量的模拟实验表明，模拟退火算法在求解这些问题时能产生令人满意的近似最优解，而且所用的时间也不很长。
模拟退火算法 伪代码
s:=s0;e:=E(s)//设定目前状态为s0，其能量E(s0)
k:=0//评估次数k
while k<kmax and e>emax//若还有时间（评估次数k还不到kmax）且结果还不够好（能量e不够低）则：
sn:=neighbour(s)//随机选取一临近状态sn
en:=Esn)//sn的能量为E(sn)
if random()<P(e,en,temp(k/kmax)) then//决定是否移至临近状态sn
s:=sn; e:=en//移至临近状态sn
k:=k+1//评估完成，次数k加一
returns//回转状态s
以英语为例：Verb（动词）+-ment（后缀）—> Noun（名词）：借由后缀-ment 的使用，使原本的动词词素转为名词，为语言的衍生，是后缀的一种用途
后缀是置于单词或词干后用于构成新词的一个或一组音节。也就是说，用作一种词类的词，例如名词经添加后缀之后可以转变为不同的词类，例如形容词。
后缀名词
常见的此类后缀及其具体含义如下：
-ster，-eer，-er（or） 意为：从事某种职业或参与某种活动的人（person engaged in an occupation or activity）例词：gamester，gangster，songster，engineer，profiteer，mountaineer，auctioneer，driver，teacher，director，actor，professor
-let 意为：小或者不重要的东西（small，unimportant things）例词：booklet，leaflet，starlet
-ette 意为：1）小的东西（small）例词：cigarette 2）假的东西（imitation）例词：leatherette,usherette
-ess 意为：女性（female）例词：actress，poetess，hostess，paintress
-hood 意为：时期（status；etc．）例词：boyhood，childhood，manhood
-ship 意为：才能，状态，资格，品质等（skill，state，condition，status，quality）例词：leadership，friendship，membership，lectureship，sportsmanship
-ful 意为：量（the amount which noun contains）例词：cupful，handful， mouthful，spoonful
-tion，-ion 意为：1）状态，行动等（state；action；etc．）例词：action，oppression，possession，education，starva- tion 2）机构等（institution；etc．）例词： organization，foundation
-ment 意为：状态，行动等（state； action；etc．）例词：movement，enslavement，pavement
-al 意为：动作（action）例词：arrival，refusal，revival，recital，removal
-age 意为：程度，数量等（extent； amount；etc．）例词：wastage，coverage， acreage，shrinkage，breakage，hostage
-ness；-ity（ty） 意为：状态，品质（state；quality；etc．）例词：happiness， usefulness，selfishness，kindness，rapidity，activity，sanity，changeability
-ism 意为：道义，主义，学说等（doctrine of，practice of）例词：idealism， impressionism，absenteeism，racism
-ist 意为：拥护某种主义的人，某种学科专家等（the person who support the doctrine，the person who is good at the practice）例词：idealist， impressionist，absenteeist，racist
后缀动词
使一个词变为动词的后缀。
常见的此类后缀及其具体含义如下：
-ify 意为：转为，变为（to turn into，to make or become）例词：beautify， diversify，simplify
-ize；-en 意为：使……，变得……（to make or become ；to make into）例词：modernize，popularize，legalize，hospitalize，symbolize，ripen，widen，heighten，threaten
-ate 意为：增加，使……听写（give or add，make or become）例词：originate， hydrogenate，validate，differentiate
后缀形容词
常见的此类后缀及其具体含义如下：
-ful 意为：充满，有（full of；hav- ing；giving；etc．）例词：useful，pitiful， hopeful，careful,helpful，forgetful，thankful， fearful
-less 意为：没有，无（without；not giving）例词：speechless，childless，harmless，hopeless，meaningless ，homeless
-ly 意为：有……品质的（having the qualities of）例词：beastly，manly， brotherly，friendly
-like 意为：像……的（like）例词： childlike，statesmanlike，tiger-like
-y；-ish 意为：像……一般的（somewhat like）例词：meaty，sandy， silky，hairy，leafy，watery，foolish，girlish，blackish，thinnish
-some 意为：像……一样的；引起……的；有……品质的（like；causing； having the quality of）例词：troublesome，burdensome，wholesome，tiresome，bothersome
-able（ible） 意为：能……的；可以……的（able to be ；capable）例词： changeable，reliable,readable，drinkable，comfortable，expansible，convincible
-ed 意为：有……的（having，etc．）例词：wooded，pointed，moneyed， odd-shaped
-al 意为：有……属性的，……类型的（nature of，typical of）例词：cultural，personal，regional，musical
-ary（ory） 意为：属于……的，与……相连的（belonging to；connected with）例词：revolutionary，imaginary， contradictory
-ous 意为：富含……的；有……品质的；像……的（full of；having the quality of；like）例词：glorious，erroneous，malicious，gracious，dangerous
-ic（ical） 意为：……类的；属于……的（typical of；belonging to）例词： historic，historical，methodic，methodical，dramatic，heroic
-ive 意为：有……属性的；有某种倾向的（having the nature or quality of；given or tending to）例词：attractive， talkative，restrictive，defensive，preventive，constructive，sensitive
后缀副词
常见的此类后缀及其具体含义如下：
-ly 意为：以……方式（in a...manner；etc．）例词：happily， boldly，attentive- ly，strangely
-ward（s） 意为：表示方式或动作的方向（manner and direction of movement）例词：onward（s），backward（s），earthward（s），homeward（s），eastward（s）
-wise 意为：1）按照……方式（in the manner of）例词：crabwise，clockwise2）就……而言（as far as...is concerned）例词：weatherwise ，educationwise
以ly后缀结尾的副词，比较级都是+more，如more carefully，more usefully最高级+most 如most carefully，most usefully
zǐ sūn
1、儿子和孙子，泛指后代
子孙荷担者三夫。——《列子·汤问》
子孙相继为王。——《战国策·赵策》
子孙侯者。
人主之子孙。
远者及其子孙。
《书·洪范》：“身其康强，子孙其逢吉。”
《史记·孝武本纪》：“平原君往祠，其后子孙以尊显。”
汉 贾谊 《过秦论》上：“自以为 关中 之固，金城千里，子孙帝王万世之业也。”
宋 吴曾 《能改斋漫录·记事一》：“侍郎于京师，遇乡人至，必命子孙出见，而列侍焉。”
明 张居正 《请戒谕群臣疏》：“尔等亦皆垂功名於竹帛，緜禄廕於子孙，顾不美欤！”
明王铎《太子少保兵部尚书节寰袁公神道碑》：呜呼，袁公（袁可立）庶几不陨其功名矣，夫人子孙皆见志中。
明冯梦龙《东周列国志》第一百一回：于是乎寻川岩之乐，享乔松之寿，子孙世世，长为应侯，孰与据轻重之势，而蹈不可知之祸哉？
《儿女英雄传》第一回：“便是将来的子孙，有命作官固好。不然，守着这点地方，也还可以耕种读书，不至冻饿。”
2、仅指儿子
《隋书·西域传·附国》：有死者……子孙不哭，带甲儛剑而呼云：我父为鬼所取，我欲报寃杀鬼。
后代、后裔、子息、儿女
children and grandchildren; descendants; brat
旅行商问题(TravelingSalesmanProblem，TSP)是一个经典的组合优化问题。经典的TSP可以描述为：一个商品推销员要去若干个城市推销商品，该推销员从一个城市出发，需要经过所有城市后，回到出发地。应如何选择行进路线，以使总的行程最短。从图论的角度来看，该问题实质是在一个带权完全无向图中，找一个权值最小的Hamilton回路。由于该问题的可行解是所有顶点的全排列，随着顶点数的增加，会产生组合爆炸，它是一个NP完全问题。由于其在交通运输、电路板线路设计以及物流配送等领域内有着广泛的应用，国内外学者对其进行了大量的研究。早期的研究者使用精确算法求解该问题，常用的方法包括：分枝定界法、线性规划法、动态规划法等。但是，随着问题规模的增大，精确算法将变得无能为力，因此，在后来的研究中，国内外学者重点使用近似算法或启发式算法，主要有遗传算法、模拟退火法、蚁群算法、禁忌搜索算法、贪婪算法和神经网络等。
[2]
TSP的研究历史很久，最早的描述是1759年欧拉研究的骑士环游问题，即对于国际象棋棋盘中的64个方格，走访64个方格一次且仅一次，并且最终返回到起始点。1954年，Geo~eDanzig等人用线性规划的方法取得了旅行商问题的历史性的突破——解决了美国49个城市的巡回问题。这就是割平面法，这种方法在整数规划问题上也广泛应用。后来还提出了一种方法叫做分枝限界法，所谓限界，就是求出问题解的上、下界，通过当前得到的限界值排除一些次优解，为最终获得最优解提示方向。每次搜索下界最小的分枝，可以减小计算量。
[3]
旅行商问题经典TSP
CTSP是在一个带权无向完全图中找一个权值最小的Hamilton回路。在各类TSP中，该类问题的研究成果最多。近几年来，研究者或者基于数学理论构造近似算法，或者使用各种仿自然的算法框架结合不同的局部搜索方法构造混合算法。同时，神经网络和自组织图方法在该问题上的应用研究也引起了研究者的关注。
旅行商问题不对称TSP
若在CTSP模型中，两个顶点i和j间的距离d不一定相等，则称为 ATSP。ATSP由于两点间距离的不对称性，所以求解更困难，但由于现实生活中多数实际场景都为不对称的TSP，所以对于基于实际交通网络的物流配送来说，其比CTSP更具有实际应用价值 。
旅行商问题配送收集TSP
TSPPD是由CTSP适应物流配送领域的实际需求而产生的。这个问题涉及到两类顾客需要：一类是配送需求，要求将货物从配送中心送到需求点；另一类是收集需求，要求将货物从需求点运往配送中心。当所有的配送和收集需求都由一辆从配送中心出发、限定容量的车辆来完成时，怎样安排行驶路线才能构成一条行程最短的 Hamilton回路。
旅行商问题多人旅行商问题
即多个旅行商遍历多个城市，在满足每个城市被一个旅行商经过一次的前提下，求遍历全部城市的最短路径。解决 MTSP对解决 “车辆调度路径安排 ”问题具有重要意义。过去的研究大多将 MTSP转化成多个TSP，再使用求解 TSP的算法进行求解。Hong Qu等人结合胜者全取 (winner—take—all)的竞争机制设计了一个柱形竞争的神经网络模型来求解MTSP，并对网络收敛于可行解进行了分析和论证。
[4]
旅行商问题多目标旅行商问题
CRISP的路径上只有一个权值 (即距离)，而 MoTSP研究的是路径上有多个权值的 TSP，要求找一条通过所有顶点并最终回到起点的回路，使回路上的各个权值都尽可能小。由于在多目标情况下，严格最优解并不存在，研究 MoTSP的目的是找到Pareto最优解，这是一个解集，而不是一个单一解。现阶段算法为构造一个求解单目标的遗传局部搜索算法，然后基于此求解多目标组合优化问题算法。
[5]
旅行推销员的问题，我们称之为巡行（Tour），此种问题属于NP完全问题，所以旅行商问题大多集中在启发式解法。
[6] 
Bodin（1983）等人将旅行推销员问题的启发式解法分成三种：
1、途程建构法（TourConstructionProcedures）
从距离矩阵中产生一个近似最佳解的途径，有以下几种解法：
1）最近邻点法（NearestNeighborProcedure）：一开始以寻找离场站最近的需求点为起始路线的第一个顾客，此后寻找离最后加入路线的顾客最近的需求点，直到最后。
2）节省法（ClarkandWrightSaving）：以服务每一个节点为起始解，根据三角不等式两边之和大于第三边之性质，其起始状况为每服务一个顾客后便回场站，而后计算路线间合并节省量，将节省量以降序排序而依次合并路线，直到最后。
3）插入法（Insertion procedures）：如最近插入法、最省插入法、随意插入法、最远插入法、最大角度插入法等。
2、途程改善法（TourImprovementProcedure）
先给定一个可行途程，然后进行改善，一直到不能改善为止。有以下几种解法：
1）K-Opt(2/3Opt)：把尚未加入路径的K条节线暂时取代目前路径中K条节线，并计算其成本（或距离），如果成本降低（距离减少），则取代之，直到无法改善为止，K通常为2或3。
2）Or-Opt：在相同路径上相邻的需求点，将之和本身或其它路径交换且仍保持路径方向性，并计算其成本（或距离），如果成本降低（距离减少），则取代之，直到无法改善为止。
3、合成启发法（CompositeProcedure）
先由途程建构法产生起始途程，然后再使用途程改善法去寻求最佳解，又称为两段解法（twophasemethod）。有以下几种解法：
1）起始解求解+2-Opt：以途程建构法建立一个起始的解，再用2-Opt的方式改善途程，直到不能改善为止。
2）起始解求解+3-Opt：以途程建构法建立一个起始的解，再用3-Opt的方式改善途程，直到不能改善为止。
蜜蜂试验
旅行推销员的问题，我们称之为巡行（Tour），此种问题属于NP完全问题（NP-Complete），所以旅行商问题大多集中在启发式解法。Bodin（1983）等人将旅行推销员问题的启发式解法分成三种：
旅行商问题途程建构法
算法的核心从距离矩阵中产生一个近似最佳解的途径，有以下几种解法：
1、近邻点法（Nearest Neighbor Procedure）：一开始以寻找离场站最近的需求点为起始路线的第一个顾客，此后寻找离最后加入路线的顾客最近的需求点，直到最后。
2、节省法（ClarkandWright Saving）：以服务每一个节点为起始解，根据三角不等式两边之和大于第三边之性质，其起始状况为每服务一个顾客后便回场站，而后计算路线间合并节省量，将节省量以降序排序而依次合并路线，直到最后。
3、插入法（Insertion procedures）：如插入法、最省插入法、随意插入法、最远插入法、最大角度插入法等。
旅行商问题途程改善法
先给定一个可行途程，然后进行改善，一直到不能改善为止。有以下几种解法：
1、K-Opt(2/3Opt)：把尚未加入路径的K条节线暂时取代如今路径中K条节线，并计算其成本（或距离），如果成本降低（距离减少），则取代之，直到无法改善为止，K通常为2或3。
2、Or-Opt：在相同路径上相邻的需求点，将之和本身或其它路径交换且仍保持路径方向性，合成启发法
先由途程建构法产生起始途程，然后再使用途程改善法去寻求最佳解，又称为两段解法（twophasemethod）。有以下几种解法：
1、起始解求解+2-Opt：以途程建构法建立一个起始的解，再用2-Opt的方式改善途程，直到不能改善为止。
2、起始解求解+3-Opt：以途程建构法建立一个起始的解，再用3-Opt的方式改善途程，直到不能改善为止。
2010年10月25日，英国一项最新研究说，在花丛中飞来飞去的小蜜蜂显示出了轻易破解“旅行商问题”的能力，而这是一个吸引全世界数学家研究多年的大问题，如能理解蜜蜂的解决方式，将有助于人们改善交




小蜜蜂解决大问题

通规划和物流等领域的工作。英国伦敦大学皇家霍洛韦学院等机构研究人员报告说，小蜜蜂显示出了轻而易举破解这个问题的能力。他们利用人工控制的假花进行了实验，结果显示，不管怎样改变花的位置，蜜蜂在稍加探索后，很快就可以找到在不同花朵间飞行的最短路径。这是首次发现能解决这个问题的动物，研究报告即将发表在《美国博物学家》杂志上。
进行研究的奈杰尔·雷恩博士说，蜜蜂每天都要在蜂巢和花朵间飞来飞去，为了采蜜而在不同花朵间飞行是一件很耗精力的事情，因此实际上蜜蜂每天都在解决“旅行商问题”。尽管蜜蜂的大脑只有草籽那么大，也没有电脑的帮助，但它已经进化出了一套很好的解决方案，如果能理解蜜蜂怎样做到这一点，对人类的生产、生活将有很大帮助。
据介绍，“旅行商问题”的应用领域包括：如何规划最合理高效的道路交通，以减少拥堵；如何更好地规划物流，以减少运营成本；在互联网环境中如何更好地设置节点，以更好地让信息流动等。
旅行商问题要从图G的所有周游路线中求取最小成本的周游路线，而从初始点出发的周游路线一共有(n-1)!条，即等于除初始结点外的n-1个结点的排列数，因此旅行商问题是一个排列问题。通过枚举(n-1)!条周游路线，从中找出一条具有最小成本的周游路线的算法，其计算时间显然为O(n!)。
旅行商问题枚举法
程序中采用深度优先策略。（采用隐式和显式两种形式）
枚举算法的特点是算法简单，但运算量大，当问题的规模变大，循环的阶数越大，执行的速度越慢。如果枚举范围太大（一般以不超过两百万次为限），在时间上就难以承受。在解决旅行商问题时，以顶点1为起点和终点，然后求{2…N}的一个全排列，使路程1→{2…N}的一个全排列→1上所有边的权（代价）之和最小。所有可能解由（2，3，4，…，N）的不同排列决定。
为便于讨论，介绍一些关于解空间树结构的术语。
[7] 
在下面分析回溯法和分支限界法时都直接或间接用到解空间树。在解空间树中的每一个结点确定所求问题的一个问题状态（problem state）。由根结点到其它结点的所有路径则确定了这个问题的状态空间（state space）。解状态（solution states）表示一些问题状态S，对于这些问题状态，由根到S的那条路径确定了这解空间中的一个元组。答案状态（answer states）表示一些解状态S，对于这些解状态而言，由根到S的这条路径确定了这问题的一个解（即，它满足隐式约束条件）。解空间的树结构称为状态空间树（state pace tree）。
对于旅行商问题，一旦设想出一种状态空间树，那么就可以先系统地生成问题状态，接着确定这些问题状态中的哪些状态是解状态，最后确定哪些解状态是答案状态，从而将问题解出。为了生成问题状态，采用两种根本不同的方法。如果已生成一个结点而它的所有儿子结点还没有全部生成，则这个结点叫做活结点。当前正在生成其儿子结点的活结点叫E-结点。不再进一步扩展或者其儿子结点已全部生成的生成结点就是死结点。在生成问题状态的两种方法中，都要用一张活结点表。在第一种方法中，当前的E-结点R一旦生成一个新的儿子C，这个儿子结点就变成一个新的E-结点，当完全检测了子树C之后，R结点就再次成为E-结点。这相当与问题状态的深度优先生成。在第二种状态生成方法中，一个E-结点一直保持到死结点为止。这两种方法中，将用限界函数去杀死还没有全部生成其儿子结点的那些活结点。如果旅行商问题要求找出全部解，则要生成所有的答案结点。使用限界函数的深度优先结点生成方法称为回溯法。E-结点一直保持到死为止的状态生成方法称为分支限界法。
旅行商问题回溯法
为了应用回溯法，所要求的解必须能表示成一个n-元组(x1,…,Xn)，其中x1是取自某个有穷集Si。通常，所求解的问题需要求取一个使某一规范函数P(x1,…,Xn)取极大值（或取极小值或满足该规范函数条件）的向量。
假定集合Si的大小是mi，于是就有m=m1 m2…mn个n元组可能满足函数P。所谓硬性处理是构造这m个n元组并逐一测试它们是否满足P，从而找出该问题的所有最优解。而回溯法的基本思想是，不断地用修改过的函数Pi(x1,…Xi)（即限界函数）去测试正在构造中的n-元组的部分向量(x1,…,Xi)，看其是否可能导致最优解。如果判定(x1,…,Xi)不可能导致最优解，那么就可能要测试的后n-i个元素组成的向量一概略去。因此回溯法作的次数比硬性处理作的测试次数（m次）要少得多。用回溯法求解的旅行商问题，即在枚举法的基础上多了一个约束条件，约束条件可以分为两种类型：显式约束和隐式约束。
旅行商问题分支限界法
采用FIFO分支限界法，分支限界法是在生成当前E-结点全部儿子之后再生成其它活结点的儿子，且用限界函数帮助避免生成不包含答案结点子树的状态空间的检索方法。在总的原则下，根据对状态空间树中结点检索的次序的不同又将分支限界设计策路分为数种不同的检索方法。在求解旅行商问题时，程序中采用FIFO检索（First In First Out），它的活结点表采用一张先进先出表（即队列）。可以看出，分支限界法在两个方面加速了算法的搜索速度，一是选择要扩展的节点时，总是选择选择一个最小成本的结点，尽可能早的进入最有可能成为最优解的分支；二是扩展节点的过程中，舍弃导致不可行解或导致非最优解的子结点。
旅行商问题贪心法
贪心法是一种改进了的分级处理方法。它首先旅行商问题描述，选取一种度量标准。然后按这种度量标准对n个输入城市排序，并按序一次输入一个城市。如果这个输入和当前已构成在这种量度意义下的部分最优解加在一起不能产生一个可行解，则不把这个城市加入到这部分解中。这种能够得到某种量度意义下的最优解的分级处理方法成为贪心方法。
获得最优路径的贪心法应一条边一条边地构造这棵树。根据某种量度来选择将要计入的下一条边。最简单的量度标准是选择使得迄今为止计入的那些边的成本的和有最小增量的那条边。
旅行商问题具有重要的实际意义和工程背景。它一开始是为交通运输而提出的，比如飞机航线安排、送邮件、快递服务、设计校车行进路线等等。实际上其应用范围扩展到了许多其他领域．下面举几个实例。
印制电路板转孔是TSP应用的经典例子，在一块电路板上打成百上千个孔，转头在这些孔之间移动，相当于对所有的孔进行一次巡游。把这个问题转化为TSP，孔相当于城市．孔到孔之问的移动时间就是距离。
为了避免大气干扰，使光学系统达到其衍射极限分辨率．欧美发达国家提出发展空间光干涉仪和综合孔径望远镜的计划。美国航空航天局有一个卫星群组成空间天文台(Space—basedObservatories)的计划，用来探测宇宙起源和外星智慧生命。欧洲空间局也有类似的Darwin计划。对天体成像的时候，需要对两颗卫星的位置进行调整，如何控制卫星，使消耗的燃料最少，可以用TSP来求解。这里把天体看作城市，距离就是卫星移动消耗的燃料。
美国国家卫生协会在人类基因排序工作中用TSP方法绘制放射性杂交图。把DNA片段作为城市．它们之间的相似程度作为城市间的距离。法国科学家已经用这种办法作出了老鼠的放射性杂交图。
此外，旅行商问题还有电缆和光缆布线、晶体结构分析、数据串聚类等多种用途。更重要的是．它提供了一个研究组合优化问题的理想平台。很多组合优化问题，比如背包问题、分配问题、车间调度问题都和TSP同属NP完全问题，它们都是同等难度的．如果其中一个能用多项式确定性算法解决，那么其他所有的NP完全问题也能用多项式算法解决。很多方法本来是从TSP发展起来的．后来推广到其他NP完全问题上去。
[8]
1998年的石溪布鲁克大学算法库的研究表明，在75个算法问题中，背包问题是第18个最受欢迎，第4个最需要解决的问题（前三为后kd树，后缀树和bin包装问题）。
[3]
背包问题出现在各种领域的现实世界的决策过程中，例如寻找最少浪费的方式来削减原材料，
[4] 
选择投资和投资组合，
[5] 
选择资产支持资产证券化
[6] 
，和生成密钥为Merkle-Hellman
[7] 
和其他背包密码系统。
背包算法的一个早期应用是在测试的构建和评分中，测试者可以选择他们回答哪些问题。对于小例子来说，这是一个相当简单的过程，为测试者提供这样的选择。例如，如果考试包含12个问题，每个问题的价值为10分，测试者只需回答10个问题即可获得100分的最高分。然而，在点值的异质分布的测试 - 即不同的问题值得不同的点值 - 更难以提供选择。 Feuerman和Weiss提出了一个系统，其中学生被给予一个异质测试，共有125个可能的点。学生被要求尽可能回答所有的问题。在总点数加起来为100的问题的可能子集中，背包算法将确定哪个子集给每个学生最高的可能得分。
[8]
我们有n种物品，物品j的重量为wj，价格为pj。
我们假定所有物品的重量和价格都是非负的。背包所能承受的最大重量为W。
如果限定每种物品只能选择0个或1个，则问题称为0-1背包问题
[9] 
。
可以用公式表示为：
最大化
受限于
如果限定物品j最多只能选择bj个，则问题称为有界背包问题。
可以用公式表示为：
最大化
受限于
如果不限定每种物品的数量，则问题称为无界背包问题。
各类复杂的背包问题总可以变换为简单的0-1背包问题进行求解。
[9]
背包问题题目
有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。
背包问题基本思路
这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。
用子问题定义状态：即f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
f[i][v]=max{ f[i-1][v], f[i-1][v-w[i]]+v[i] }。
可以压缩空间，f[v]=max{f[v],f[v-w[i]]+v[i]}
这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”，价值为f[i-1][v]；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为v-w[i]的背包中”，此时能获得的最大价值就是f [i-1][v-w[i]]再加上通过放入第i件物品获得的价值v[i]。
注意f[v]有意义当且仅当存在一个前i件物品的子集，其费用总和为f[v]。所以按照这个方程递推完毕后，最终的答案并不一定是f[N] [V]，而是f[N][0..V]的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项f[v-1]，这样就可以保证f[N] [V]就是最后的答案。至于为什么这样就可以，由你自己来体会了。
背包问题空间复杂
以上方法的时间和空间复杂度均为O(N*V），其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V）。
先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？
f[i][v]是由f[i-1][v]和f [i-1][v-w[i]]两个子问题递推而来，能否保证在推f[v]时（也即在第i次主循环中推f[v]时）能够得到f[v]和f[v -w[i]]的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推f[v]，这样才能保证推f[v]时f[v-w[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：
for i=1..N
for v=V..0
f[v]=max{f[v],f[v-w[i]]+v[i]};
其中的f[v]=max{f[v],f[v-w[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]}，因为的
f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。
[10]
背包问题示例程序
(完全背包问题求解)
#include<iostream>
using namespace std;
int findM(int N,int K,int G[],int W[])
{    int *M=new int[N+1],i,j,k;   
      for(i=0;i<N+2;i++)
          M[i]=0;
      for(i=0;i<K;i++)
      {        
          for(j=N;j>=G[i];j--)
               {            
                   for(k=1;j-k*G[i]>=0;k++)
                       {
                          M[j]=M[j]>k*W[i]+M[j-k*G[i]]?M[j]:k*W[i]+M[j-k*G[i]];   
                        }    
               } 
       }  
           return M[N];
}
int main(){
        int N,K,i;
        while(cin>>N>>K)
        {
        int *G=new int[K];        
        int *W=new int[K];        
        for(i=0;i<K;i++)       
        cin>>G[i]>>W[i];        
        cout<<findM(N,K,G,W)<<endl;        
        delete []G;       
        delete []W;    
        }    
     return 0;
}
背包问题递归实现
//现在设A[i][v]表示在剩余空间为v时选取当前物品i的最大值，B[i][v]表示不选取当前物品i的最大值，所以总的最大值必然是max(A[n][v],B[n][v]），详细程序见如下：
#include<fstream>
#include<iostream>
using namespace std;
#define MAXSIZE 1000
int A[MAXSIZE+1][MAXSIZE+1],B[MAXSIZE+1][MAXSIZE+1];
int c[MAXSIZE+1],w[MAXSIZE+1];
int F(int n ,int v){
if(n==0)return 0;
if(!A[n][v]&&v>=c[n])
A[n][v]=F(n-1,v-c[n])+w[n];
if(!B[n][v])B[n][v]=F(n-1,v);
return A[n][v]>B[n][v]?A[n][v]:B[n][v];
}
int main(int argc,char*argv[])
{
int n,v;
memset(A,0,sizeof(A));
memset(B,0,sizeof(B));
ifstreamin("in.txt");
ofstreamout("out.txt");
cin>>n>>v;
for(int i=1;i<=n;i++)
cin>>c[i]>>w[i];
cout<<F(n,v);
return 0;
}
背包问题程序
程序一：
var
i,j,v,n:longint;
f,c,w:array[0..100] of longint;
function max(a,b:longint):longint;
begin
if a>b then exit(a) else exit(b);
end;
begin
read(n,v);
fillchar(f,sizeof(f),0);
for i:=1 to n do
read(c[i],w[i]);
for i:=1 to n do
for j:=v downto c[i] do
f[j]:=max(f[j],f[j-c[i]]+w[i]);
writeln(f[v]);
end.
程序二（顺推法）：
var m,n,x,i:integer;
c,w:array[1..30] of integer;
f:array[0..30,0..300] of integer;
function max(x,y:integer):integer;
begin
if x>y then max:=x else max:=y;
end;
begin
readln(n,m);
for i:=1 to n do
readln(c[i],w[i]);
for i:=1 to n do
for x:=1 to m do
if x>=c[i] then f[i,x]:=max(f[i-1,x-c[i]]+w[i],f[i-1,x])
else f[i,x]:=f[i-1,x];
writeln(f[n,m]);
end.
背包问题测试数据
//in.txt：
5 100
77 92
22 22
29 87
50 46
99 90
//out.txt
133
//in.txt：
8 200
79 83
58 14
86 54
11 79
28 72
62 52
15 48
68 62
//out.txt
334
C动态规划算法的实现（完整代码）
#include<stdio.h>
#include<malloc.h>
typedefstruct
{
intobject;
intweight;
intvalue;
}KnapSack;
KnapSack*knapsack;//背包数组，用malloc或new动态创建
intnum;//物体的个数
intcontainer;//背包的最大容量
int**array=NULL;//用来存放子问题的结果
//动态创建背包
voidCreate_KnapSack()
{
charc;
printf("inputthenumberofobjects\n");
scanf("%d",&num);
knapsack=newKnapSack[num+1];
printf("inputweightandvalueof%dobjects,like1:410\n",num);
for(inti=1;i<=num;i++)
{
scanf("%d%c%d%c%d",&knapsack[i].object,&c,&knapsack[i].weight,&c,&knapsack[i].value);
getchar();//为了获取空格或其他输入，声明下scanf挺恶心
}
intk=knapsack[num].value;
printf("%d",k);
printf("inputthevolumeoftheknapsack:\n");
scanf("%d",&container);
}
//确定最优子问题
voidResolve_KnapSack()
{
intk=knapsack[num].value;
printf("%d",k);
//创建动态二维数组m[num][container]
array=(int**)malloc((num+1）*sizeof(int*));
for(inti=0;i<=num;i++)
array[i]=(int*)malloc((container+1）*sizeof(int));
//
for(intj=0;j<=container;j++)
array[num][j]=(j>=knapsack[num].weight)?knapsack[num].value:0;
//子问题的最优结果
for(intm=num-1;m>0;m--)
for(intn=0;n<=container;n++)
if(n>knapsack[m].weight&&array[m+1][n]<=array[m+1][n-knapsack[m].weight]+knapsack[m].value)
array[m][n]=array[m+1][n-knapsack[m].weight]+knapsack[m].value;
//else包括两种情况，共同点是该物体没有被使用
else
array[m][n]=array[m+1][n];
}
//往回找，确定某个物体i是否被使用
bool*Trace_back()
{
intc=container;
bool*used;
used=(bool*)malloc(sizeof(bool)*(num+1））；
for(inti=1;i<num;i++)
if(array[i][c]==array[i+1][c])
used[i]=0;
else
{
used[i]=1;
c-=knapsack[i].weight;
}
used[num]=(c>=knapsack[num].weight)?1:0;
returnused;
}
//用来输出被使用的物体及其相关值
voidPrint_KnapSack(bool*used)
{
printf("theobjectsusedasfollows:\n");
for(inti=1;i<=num;i++)
if(used[i])
printf("%d:%d%d\n",knapsack[i].object,knapsack[i].weight,knapsack[i].value);
}
voidmain()
{
bool*used;
Create_KnapSack();
Resolve_KnapSack();
used=Trace_back();
Print_KnapSack(used);
}
背包问题总结
0/1背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成0/1背包问题求解。
[9] 
故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。
背包问题题目
有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的体积是c，价值是w。将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。
背包问题基本思路
这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令f[i,v]表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：f[i,v]=max{f[i,v-vi]+wi,f[i-1,v]}。这跟01背包问题一样有O(N*V）个状态需要求解，但求解每个状态的时间则不是常数了，求解状态f[v]的时间是O(v/c），总的复杂度是超过O(VN）的。
将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。
背包问题简单有效
完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足c<=c[j]且w>=w[j]，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小体积高的j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。
完全背包还有另一种优化，代码如下：
var p,t:array[1..10000] of integer;
m,n:integer;
min:longint;

procedure init;
var i:integer;
begin
readln(m,n);
min:=maxlongint;
for i:=1 to n do
begin
readln(p[i],t[i]);
if t[i]<min then min:=t[i];
end;
end;

procedure qsort(l,r:integer);
var i,j,x,temp:longint;
begin
i:=l;
j:=r;
x:=t[(l+r)div2];
while i<jdo
begin
while(i<j)and(t[i]<x) do inc(i);
while(i<j)and(x<t[j]) do dec(j);
if i<=j then
begin
temp:=t[i];
t[i]:=t[j];
t[j]:=temp;
temp:=p[i];
p[i]:=p[j];
p[j]:=temp;
inc(i);
dec(j);
end;
end;
if i<r then qsort(i,r);
if l<j then qsort(l,j);
end;

function max(a,b:longint):longint;
begin
if a>b then max:=a else max:=b;
end;

procedure work;
var f:array[0..10000] of longint;
i,j:longint;
begin
fillchar(f,sizeof(f),0);
for i:=min to m do
begin
f[i]:=f[i-1];
for j:=1 to n do
if i-t[j]>=0 then f[i]:=max(f[i],f[i-t[j]]+p[j]) else break;
end;
writeln(f[m]);
end;

begin
init;
qsort(1,n);
work;
end.
背包问题转为问题
既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选V/c 件，于是可以把第i种物品转化为V/c件体积及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。
更高效的转化方法是：把第i种物品拆成体积为c*2^k、价值为w*2^k的若干件物品，其中k满足c*2^k<V。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成O(log(V/c））件物品，是一个很大的改进。但我们有更优的O(VN）的算法。* O(VN）的算法 这个算法使用一维数组，先看伪代码：<pre class"example"> for i=1..N for v=0..V f[v]=max{f[v],f[v-c]+w};
你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态f[v]是由状态f[v-c]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[v-c]。而完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[v-c]，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。
这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：f[v]=max{f[v],f[v-c]+w}，将这个方程用一维数组实现，便得到了上面的伪代码。
背包问题实现
var
i,j,v,n:longint;
f,c,w:array[0..100] of longint;
functionmax(a,b:longint):longint;
begin
ifa>bthenexit(a)elseexit(b);
end;
begin
read(n,v);
fillchar(f,sizeof(f),0);
fori:=1tondo
read(c[i],w[i]);
fori:=1tondo
forj:=c[i]tovdo
f[j]:=max(f[j],f[j-c[i]]+w[i]);
writeln(f[v]);
end.
背包问题总结
完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“O(VN）的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。
背包问题题目
有N种物品和一个容量为V的背包。第i种物品最多有n件可用，每件体积是c，价值是w。求解将哪些物品装入背包可使这些物品的体积总和不超过背包容量，且价值总和最大。
背包问题基本算法
这题目和完全背包问题很类似。基本的方程只需将完全背包问题的方程略微一改即可，因为对于第i种物品有n+1种策略：取0件，取1件……取 n件。令f[v]表示前i种物品恰放入一个容量为v的背包的最大权值，则：f[v]=max{f[v-k*c]+ k*w|0<=k<=n}。复杂度是O(V*∑n）。
背包问题转为问题
另一种好想好写的基该方法是转化为01背包求解：把第i种物品换成n件01背包中的物品，则得到了物品数为∑n的01背包问题，直接求解，复杂度仍然是O(V*∑n）。
但是我们期望将它转化为01背包问题之后能够像完全背包一样降低复杂度。仍然考虑二进制的思想，我们考虑把第i种物品换成若干件物品，使得原问题中第i种物品可取的每种策略——取0..n件——均能等价于取若干件代换以后的物品。另外，取超过n件的策略必不能出现。
方法是：将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为 1,2,4,...,2^(k-1），n-2^k+1，且k是满足n-2^k+1>0的最大整数。例如，如果n为13，就将这种物品分成系数分别为1,2,4,6的四件物品。
分成的这几件物品的系数和为n，表明不可能取多于n件的第i种物品。另外这种方法也能保证对于0..n间的每一个整数，均可以用若干个系数的和表示，这个证明可以分0..2^k-1和2^k..n两段来分别讨论得出，并不难，希望你自己思考尝试一下。
这样就将第i种物品分成了O(log n）种物品，将原问题转化为了复杂度为O(V*∑log n）的01背包问题，是很大的改进。
背包问题算法
多重背包问题同样有O(VN）的算法。这个算法基于基本算法的状态转移方程，但应用单调队列的方法使每个状态的值可以以均摊O⑴的时间求解。由于用单调队列优化的DP已超出了NOIP的范围，故本文不再展开讲解。我最初了解到这个方法是在楼天成的“男人八题”幻灯片上。
背包问题小结
这里我们看到了将一个算法的复杂度由O(V*∑n）改进到O(V*∑log n）的过程，还知道了存在应用超出NOIP范围的知识的O(VN）算法。希望你特别注意“拆分物品”的思想和方法，自己证明一下它的正确性，并用尽量简洁的程序来实现。
背包问题问题
如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？
背包问题背包混合
考虑到在P01和P02中最后给出的伪代码只有一处不同，故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次，那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可，复杂度是O(VN）。伪代码如下：
for i=1..N
if 第i件物品是01背包
for v=V..0
f[v]=max{f[v],f[v-c]+w};
else if 第i件物品是完全背包
for v=0..V
f[v]=max{f[v],f[v-c]+w};
再加上多重背包
如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN）的解法：遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话，用P03中将每个这类物品分成O(log n）个01背包的物品的方法也已经很优了。
背包问题小结
有人说，困难的题目都是由简单的题目叠加而来的。这句话是否公理暂且存之不论，但它在本讲中已经得到了充分的体现。本来01背包、完全背包、多重背包都不是什么难题，但将它们简单地组合起来以后就得到了这样一道一定能吓倒不少人的题目。但只要基础扎实，领会三种基本背包问题的思想，就可以做到把困难的题目拆分成简单的题目来解决。
[10]
背包问题问题
二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第i件物品所需的两种代价分别为a和b。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为w。
背包问题算法
费用加了一维，只需状态也加一维即可。设f[v]表示前i件物品付出两种代价分别为v和u时可获得的最大价值。状态转移方程就是：fi[i][v][u]=max{f[i-1][v][u],f[i-1][v-a[i]][u-b[i]]+w[i]}。如前述方法，可以只使用二维的数组：当每件物品只可以取一次时变量v和u采用逆序的循环，当物品有如完全背包问题时采用顺序的循环。当物品有如多重背包问题时拆分物品。
背包问题限制
有时，“二维费用”的条件是以这样一种隐含的方式给出的：最多只能取M件物品。这事实上相当于每件物品多了一种“件数”的费用，每个物品的件数费用均为1，可以付出的最大件数费用为M。换句话说，设f[v][m]表示付出费用v、最多选m件时可得到的最大价值，则根据物品的类型（01、完全、多重）用不同的方法循环更新，最后在f[0..V][0..M]范围内寻找答案。
另外，如果要求“恰取M件物品”，则在f[0..V][M]范围内寻找答案。
背包问题小结
事实上，当发现由熟悉的动态规划题目变形得来的题目时，在原来的状态中加一维以满足新的限制是一种比较通用的方法。希望你能从本讲中初步体会到这种方法。
[10]
背包问题问题
有N件物品和一个容量为V的背包。第i件物品的费用是c，价值是w。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
背包问题算法
这个问题变成了每组物品有若干种策略：是选择本组的某一件，还是一件都不选。也就是说设f[k][v]表示前k组物品花费费用v能取得的最大权值，则有f[k][v]=max{f[k-1][v],f[k-1][v-c]+w|物品i属于第k组}。
使用一维数组的伪代码如下：
for 所有的组k
for v=V..0
for 所有的i属于组k （我觉得循环顺序应改成这样，大家可以看一下以前的版本自己判断）
f[v]=max{f[v],f[v-c]+w}
另外，显然可以对每组中的物品应用P02中“一个简单有效的优化”。
背包问题小结
分组的背包问题将彼此互斥的若干物品称为一个组，这建立了一个很好的模型。不少背包问题的变形都可以转化为分组的背包问题（例如P07），由分组的背包问题进一步可定义“泛化物品”的概念，十分有利于解题。
[10]
背包问题简化问题
这种背包问题的物品间存在某种“依赖”的关系。也就是说，i依赖于j，表示若选物品i，则必须选物品j。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。
背包问题算法
这个问题由NOIP2006金明的预算方案一题扩展而来。遵从该题的提法，将不依赖于别的物品的物品称为“主件”，依赖于某主件的物品称为“附件”。由这个问题的简化条件可知所有的物品由若干主件和依赖于每个主件的一个附件集合组成。
按照背包问题的一般思路，仅考虑一个主件和它的附件集合。可是，可用的策略非常多，包括：一个也不选，仅选择主件，选择主件后再选择一个附件，选择主件后再选择两个附件……无法用状态转移方程来表示如此多的策略。（事实上，设有n个附件，则策略有2^n+1个，为指数级。）
考虑到所有这些策略都是互斥的（也就是说，你只能选择一种策略），所以一个主件和它的附件集合实际上对应于P06中的一个物品组，每个选择了主件又选择了若干个附件的策略对应于这个物品组中的一个物品，其费用和价值都是这个策略中的物品的值的和。但仅仅是这一步转化并不能给出一个好的算法，因为物品组中的物品还是像原问题的策略一样多。
再考虑P06中的一句话：可以对每组中的物品应用P02中“一个简单有效的优化”。这提示我们，对于一个物品组中的物品，所有费用相同的物品只留一个价值最大的，不影响结果。所以，我们可以对主件i的“附件集合”先进行一次01背包，得到费用依次为0..V-c所有这些值时相应的最大价值f'[0..V-c]。那么这个主件及它的附件集合相当于V-c+1个物品的物品组，其中费用为c+k的物品的价值为f'[k]+w。也就是说原来指数级的策略中有很多策略都是冗余的，通过一次01背包后，将主件i转化为 V-c+1个物品的物品组，就可以直接应用P06的算法解决问题了。
背包问题一般问题
更一般的问题是：依赖关系以图论中“森林”的形式给出（森林即多叉树的集合），也就是说，主件的附件仍然可以具有自己的附件集合，限制只是每个物品最多只依赖于一个物品（只有一个主件）且不出现循环依赖。
解决这个问题仍然可以用将每个主件及其附件集合转化为物品组的方式。唯一不同的是，由于附件可能还有附件，就不能将每个附件都看作一个一般的01 背包中的物品了。若这个附件也有附件集合，则它必定要被先转化为物品组，然后用分组的背包问题解出主件及其附件集合所对应的附件组中各个费用的附件所对应的价值。
事实上，这是一种树形DP，其特点是每个父节点都需要对它的各个儿子的属性进行一次DP以求得自己的相关属性。这已经触及到了“泛化物品”的思想。看完P08后，你会发现这个“依赖关系树”每一个子树都等价于一件泛化物品，求某节点为根的子树对应的泛化物品相当于求其所有儿子的对应的泛化物品之和。
背包问题小结
NOIP2006的那道背包问题我做得很失败，写了上百行的代码，却一分未得。后来我通过思考发现通过引入“物品组”和“依赖”的概念可以加深对这题的理解，还可以解决它的推广问题。用物品组的思想考虑那题中极其特殊的依赖关系：物品不能既作主件又作附件，每个主件最多有两个附件，可以发现一个主件和它的两个附件等价于一个由四个物品组成的物品组，这便揭示了问题的某种本质。
我想说：失败不是什么丢人的事情，从失败中全无收获才是。
[10]
背包问题定义
考虑这样一种物品，它并没有固定的费用和价值，而是它的价值随着你分配给它的费用而变化。这就是泛化物品的概念。
更严格的定义之。在背包容量为V的背包问题中，泛化物品是一个定义域为0..V中的整数的函数h，当分配给它的费用为v时，能得到的价值就是h(v）。
这个定义有一点点抽象，另一种理解是一个泛化物品就是一个数组h[0..V]，给它费用v，可得到价值h[V]。
一个费用为c价值为w的物品，如果它是01背包中的物品，那么把它看成泛化物品，它就是除了h(c)=w其它函数值都为0的一个函数。如果它是完全背包中的物品，那么它可以看成这样一个函数，仅当v被c整除时有h(v)=v/c*w，其它函数值均为0。如果它是多重背包中重复次数最多为n的物品，那么它对应的泛化物品的函数有h(v)=v/c*w仅当v被c整除且v/c<=n，其它情况函数值均为0。
一个物品组可以看作一个泛化物品h。对于一个0..V中的v，若物品组中不存在费用为v的的物品，则h(v)=0，否则h(v）为所有费用为v的物品的最大价值。P07中每个主件及其附件集合等价于一个物品组，自然也可看作一个泛化物品。
背包问题泛化物品
如果面对两个泛化物品h和l，要用给定的费用从这两个泛化物品中得到最大的价值，怎么求呢？事实上，对于一个给定的费用v，只需枚举将这个费用如何分配给两个泛化物品就可以了。同样的，对于0..V的每一个整数v，可以求得费用v分配到h和l中的最大价值f(v）。也即f(v)=max{h(k) +l(v-k)|0<=k<=v}。可以看到，f也是一个由泛化物品h和l决定的定义域为0..V的函数，也就是说，f是一个由泛化物品h和 l决定的泛化物品。
由此可以定义泛化物品的和：h、l都是泛化物品，若泛化物品f满足f(v)=max{h(k)+l(v-k)|0<=k<=v}，则称f是h与l的和，即f=h+l。这个运算的时间复杂度是O(V^2）。
泛化物品的定义表明：在一个背包问题中，若将两个泛化物品代以它们的和，不影响问题的答案。事实上，对于其中的物品都是泛化物品的背包问题，求它的答案的过程也就是求所有这些泛化物品之和的过程。设此和为s，则答案就是s[0..V]中的最大值。
背包问题问题泛化
一个背包问题中，可能会给出很多条件，包括每种物品的费用、价值等属性，物品之间的分组、依赖等关系等。但肯定能将问题对应于某个泛化物品。也就是说，给定了所有条件以后，就可以对每个非负整数v求得：若背包容量为v，将物品装入背包可得到的最大价值是多少，这可以认为是定义在非负整数集上的一件泛化物品。这个泛化物品——或者说问题所对应的一个定义域为非负整数的函数——包含了关于问题本身的高度浓缩的信息。一般而言，求得这个泛化物品的一个子域（例如0..V）的值之后，就可以根据这个函数的取值得到背包问题的最终答案。
综上所述，一般而言，求解背包问题，即求解这个问题所对应的一个函数，即该问题的泛化物品。而求解某个泛化物品的一种方法就是将它表示为若干泛化物品的和然后求之。
背包问题小结
本讲可以说都是我自己的原创思想。具体来说，是我在学习函数式编程的 Scheme 语言时，用函数编程的眼光审视各类背包问题得出的理论。这一讲真的很抽象，也许在“模型的抽象程度”这一方面已经超出了NOIP的要求，所以暂且看不懂也没关系。相信随着你的OI之路逐渐延伸，有一天你会理解的。
我想说：“思考”是一个OIer最重要的品质。简单的问题，深入思考以后，也能发现更多。
[10]
以上涉及的各种背包问题都是要求在背包容量（费用）的限制下求可以取到的最大价值，但背包问题还有很多种灵活的问法。
例如，求解最多可以放多少件物品或者最多可以装满多少背包的空间。这都可以根据具体问题利用前面的方程求出所有状态的值（f数组）之后得到。
还有，如果要求的是“总价值最小”“总件数最小”，只需简单的将上面的状态转移方程中的max改成min即可。
下面说一些变化更大的问法。
背包问题输出方案
一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。
还是以01背包为例，方程为f[v]=max{f[v],f[v-c]+w}。再用一个数组g [v]，设g[v]=0表示推出f[v]的值时是采用了方程的前一项（也即f[v]=f[v]），g[v]表示采用了方程的后一项。注意这两项分别表示了两种策略：未选第i个物品及选了第i个物品。那么输出方案的伪代码可以这样写（设最终状态为f[N][V]）：
i=N
v=V
while(i>0)
if(g[v]==0)
print "未选第i项物品"
else if(g[v]==1）
print "选了第i项物品"
v=v-c
另外，采用方程的前一项或后一项也可以在输出方案的过程中根据f[v]的值实时地求出来，也即不须纪录g数组，将上述代码中的g [v]==0改成f[v]==f[v]，g[v]==1改成f[v]==f[v-c]+w也可。
输出字典序最小的最优方案
这里“字典序最小”的意思是1..N号物品的选择方案排列出来以后字典序最小。以输出01背包最小字典序的方案为例。
一般而言，求一个字典序最小的最优方案，只需要在转移时注意策略。首先，子问题的定义要略改一些。我们注意到，如果存在一个选了物品1的最优方案，那么答案一定包含物品1，原问题转化为一个背包容量为v-c[1]，物品为2..N的子问题。反之，如果答案不包含物品1，则转化成背包容量仍为V，物品为2..N的子问题。不管答案怎样，子问题的物品都是以i..N而非前所述的1..i的形式来定义的，所以状态的定义和转移方程都需要改一下。但也许更简易的方法是先把物品逆序排列一下，以下按物品已被逆序排列来叙述。
在这种情况下，可以按照前面经典的状态转移方程来求值，只是输出方案的时候要注意：从N到1输入时，如果f[v]==f及f[v]==f[f-c]+w同时成立，应该按照后者（即选择了物品i）来输出方案。
背包问题求方案总
对于一个给定了背包容量、物品费用、物品间相互关系（分组、依赖等）的背包问题，除了再给定每个物品的价值后求可得到的最大价值外，还可以得到装满背包或将背包装至某一指定容量的方案总数。
对于这类改变问法的问题，一般只需将状态转移方程中的max改成sum即可。例如若每件物品均是01背包中的物品，转移方程即为f[v]=sum{f[v],f[v-c]+w}，初始条件f[0][0]=1。
事实上，这样做可行的原因在于状态转移方程已经考察了所有可能的背包组成方案。
背包问题最优方案
这里的最优方案是指物品总价值最大的方案。还是以01背包为例。
结合求最大总价值和方案总数两个问题的思路，最优方案的总数可以这样求：f[v]意义同前述，g[v]表示这个子问题的最优方案的总数，则在求f[v]的同时求g[v]的伪代码如下：
for i=1..N
for v=0..V
f[v]=max{f[v],f[v-c]+w}
g[v]=0
if(f[v]==f[v])
inc(g[v],g[v]
if(f[v]==f[v-c]+w)
inc(g[v],g[v-c])
如果你是第一次看到这样的问题，请仔细体会上面的伪代码。
背包问题小结
显然，这里不可能穷尽背包类动态规划问题所有的问法。甚至还存在一类将背包类动态规划问题与其它领域（例如数论、图论）结合起来的问题，在这篇论背包问题的专文中也不会论及。但只要深刻领会前述所有类别的背包问题的思路和状态转移方程，遇到其它的变形问法，只要题目难度还属于NOIP，应该也不难想出算法。
触类旁通、举一反三，应该也是一个OIer应有的品质吧。
[10]
设A是一个确定性算法，当它的输入实例为x时所需的计算时间记为tA(x)。设Xn是算法A的输入规模为n的实例的全体，则当问题的输入规模为n时，算法A所需的平均时间为



这显然不能排除存在x∈Xn使得 tA(x)>>tA(n)的可能性。
希望获得一个概率算法B，使得对问题的输入规模为n的每一个实例均有
这就是舍伍德算法设计的基本思想。当s(n)与tA(n)相比可忽略时，舍伍德算法可获得很好的平均性能。
舍伍德算法总能求得问题的一个解，且所求得的解总是正确的。当一个确定性算法在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时，可以在这个确定算法中引入随机性将它改造成一个舍伍德算法，消除或减少问题的好坏实例间的这种差别。舍伍德算法精髓不是避免算法的最坏情况行为，而是设法消除这种最坏行为与特定实例之间的关联性。
在现实世界中，线性表的例子枚不胜举，如一幅扑克牌的点数(2,3,4，…,J，Q，K，A)可构成一个线性表；数据库表中的记录也可以构成一个线性表，只不过是该线性表中的数据元索稍复杂一点罢了。正因为线性表如此重要，ANSl和ISO于1998年制定的STL(Standard Template Library)中提供了对线性表的支持。STL的容器是用来放置各种类型的对象，其中每一个容器类就是计算机的一个基本数据结构。STL有以下7个最基本的容器类：向量(Vector)，列表(List)，双端队列(Deque)，集合(Set)，多重集合(Multiset)，映像(Map)，多重映像(Multimap)等。
线性表的存储有两种方式：顺序存储和链式存储。从空间的角度看，链式存储的存储密度低，因为它需要存储附加的指针域的数据。而顺序存储不需要存储附加信息，因而存储效率比较高；从时间角度来看，由于顺序存储的逻辑顺序与物理顺序一致，其存储可采用其索引号来加以存取，因此是一种随机存取结构，表中的任意一个结点都可在O(1)的时间内直接存取，但是在表中插入和删除元索时耍移动大量的元素，该结构适合经常进行查找，很少做插入和删除运算操作的场台。而链式存储与它恰恰相反，插入和删除不需要移动元素，只需要修改指针即可，但其查找的时间复杂度却为O(n)．在STL中容器类中的Vector类采用顺序存储，List类采用链式存储。后面的程序测试就是采用这两个类来进行的。
有没有这样的一个数据结构，即能像链式存错储结构那样，插入和删除不需移动大量元素，在查找时也能像顺序存储结构相似，不会比较报多的数据?况且在一些不包含指针的程序设计语言如Java和VB中，如何实现链式存储结构呢?
在不包含指针的程序设计语言如VB中，可以采用数组来实现链表，实现了“虚假”的指针操作。但就是这种“虚假”指针，恰恰不仅弥补某些指针的某些缺结，还发挥了这种“虚假”指针的优点。采用这种数据结构，抛弃了顺序存储在插入运算中需要移动大量元素的缺点。采用这种数据结构，利用,舍伍德算法进行查找、插入和删除操作，其效率在传统的顺序存储和链式存储之间。
在所有的程序设计语言中都有数组，可以利用两个数组
m_pData和m_pLink来表示所给的含有多个元素的有序集。用m_pData存储有序链表的数据，用m_pLink存储有序链表的数据元索的直接后继的指针(在数组中的索引号)。m_pLink[O]指向有序链表的第一个元素，换句话说，m_pData[m_plink[0]]是有序链表中的最小元素。一般来说，如果m_pData[i】是有序链表中的第k个元素，则m_pData[m_plink[i]]是有序链表中的第k+1个元素。有序链表的有序性表现在：对于任意的I≤i≤n，有m_pData[i]≤m_pData[m_plink[i]]。有序链表中的最大元素m_pData[k]有m_plink[k]-O(无后继，指向第零个结点，第零个结点是监视哨)且m_pDaIa[0]为一个大数。
倘若采用顺序搜索的方式在这种有序链表中查找指定的元素，每次查找与有序链表建立的顺序有关，此时采用舍伍德算法可以消除这种联系。
利用数组下标的索引性质，可以设计一个随机化的搜索算法，以改进搜索的时间复杂性。该算法的基本思想是随机选取数组元素若干次，从较接近搜索元素x的位置开始进行顺序查找，而没有必要从有序链表的开始位置进行搜索，从而较大幅度地提高查找效率。
遗憾的是在STL容器类中的Voctor类采用顺序存储，List类采用链式存储，并没有这样的一种数据结构一用数组模拟有序链表。模仿标准STL中的类模板的实现，我们编制了一个类模板COrderList，并实现了用舍伍德算法进行查找、插入等算法。
用类模板实现的算法如下：
template<classType>
boolCOrderlist<Type>：：Search(Type x, int&index)
//搜索有序链袭中的指定元素x、并将其位置放在index变量中
{//mCnrrentNumber为当前有序链表中元素的个数，它为类模
//板CorderLisl的数据成员,m为随机搜索的次数；
int m=(int)sqrt(double(m_CurmntNumber));
int j;
index=O;
//m_LowBound为当前有序链表中最小元素的值．它为类模板
//CorderList的数据成员;
Type max=m_LowBound;
for(int i=l；i<=m，i++}
{j=randl();
//产生一个随机数j，在数组m_pData[]随机中找一个值
Type y-m—pDataU]：
If((max<y)&&(y<x))
//找最靠近查找元素x的索引位置Index
{max=y；
index=j；}
}
//从最靠近查找元素x的Index所指向的位置升妯进行顺序搜索
while(m_pData[m_pLink[index]]<x)
index=m_pLink[index]；∥指针后移
return(n_pData[m_pLink[indcx]==x)；//是否找到
}
利用VC6.0编制程序，测试其查找几十万个元素用不同的算法所需要的运行时问(机器为赛扬633．内存128MB)，结果如表1所示。
表1 数组模拟有序链表的查找时间
万个元素
算法
10
20
30
40
50
舍伍德算法（s）
1
2
3
4
5
顺序查找顺序表(s)
4
8
13
18
21
顺序查找链式表(s)
4
8
12
16
20
采用数组模拟有序链表，它本质上是利用两个数组，一个存储数据，一个存储其后继在数组中的位置，对于查找指定元素，采用舍伍德算法可在0(n)时间内完成，采用顺序存储结构时，若数组元素无序，则只能顺序查找，需O(n)时间，若数组元素有序，可进行二分法查找，其时问复杂度虽然降为0(logn)，但却在进行插入和删除元素时，需要移动大量元素。与链式存储相比，插入和删除时虽然都不需要移动元素，但在查找上，其时间性能由0(n)降为O(n)，可见采用数组模拟有序链表，并采用舍伍德算法进行查找删除具有比较高的效率。它不失为一种高效韵数据结构。
平面图是地图的一种。 可以用水平面代替水准面。在这个前提下，可以把测区内的地面景物沿铅垂线方向投影到平面上，按规定的符号和比例缩小而构成的相似图形，称为平面图。
面的概念可以这样加以描述：假设把一个平面图画在平面上，然后用一把小刀沿着图的边切开，那么平面就被切成许多块，每一块就是图的一个面。更确切地说，平面图的一个面就是平面的一块，它用边做边界线，切不能再分成更小的块。
[1]
虽然地球表面是个曲面，但在极小的范围内，可以把它当做平面，因为地面实形和图上实形间的误差已经非
常小，可以忽略不计（如在2600KM2的范围内进行地行测量，要绘成1∶5000的大比例尺图上，半径误差小到0.072mm）。在平面图上，各种图形和面积都应保持与实物完全相似，各个方向的比例尺统一。在图上应反映出地物确切的位置、大小和相互间的距离。可以根据比例尺量算距离，用指向标来确定方向。
[1]
平面图 一个图能画在平面上，除结点之外，再没有边与边相交面、边界和面的次数 由连通平面图G的边围成的其内部不含G的结点和边的区域是面，常用r表示. 围成面的各边组成的回路是边界。边界回路的长度是面的次数，记作deg(r).
平面图定义：将地面上各种地物的平面位置按一定比例尺、用规定的符号缩绘在图纸上，并注有代表性的高程点的这种图。
[2]
建筑平面图简称平面图，是建筑施工中比较重要的基本图。平面图是建筑物各层的水平剖切图，假想通过一




建筑平面图

栋房屋的门窗洞口水平剖开（移走房屋的上半部分），将切面以下部分向下投影，所得的水平剖面图，就称平面图。
[3]
建筑平面图既表示建筑物在水平方向各部分之间的组合关系，又反映各建筑空间与围合它们的垂直构件之间的相关关系。
在图论中，平面图是可以画在平面上并且使得不同的边可以互不交叠的图。而如果一个图无论怎样都无法画在平面上，并使得不同的边互不交叠，那么这样的图不是平面图，或者称为非平面图。完全图K5 和完全二分图K3,3 是最“小”的非平面图。
[4]

库拉托夫斯基定理
波兰数学家卡齐米日·库拉托夫斯基提出的一类禁忌准则（指满足某种条件的图就一定无法具有某个性质）中，也包括了平面图的情况。他提出的一个定理说明：
一个有限图（顶点数和边数有限的图）是平面图当且仅当它并不包含一个是（有五个顶点的完全图）或（三个顶点的二部图）的分割的子图。
其中，一个图A是另一个图B的分割是指：A是在B的基础上，在某些边的中间加上顶点

而得到的新的图。用图的同胚理论来说，就是：一个有限图是平面图当且仅当这个图不包含任何同胚于 或 的子图。
这个定理的一般化是罗伯森－西摩定理。
欧拉公式
一个平面图将平面分成若干个互不相通的封闭区域，以及图的外部的区域。其中，图的外面的区域称为图的外部面，而图里面每个被顶点和边分割出来的封闭并连通的区域称为图的内部面。围成每个面图的每个面至少对应着三条边。
平面图的顶点个数、边数和面的个数之间有一个以大数学家莱昂哈德·欧拉命名的公式：
V-E+F=C+1
其中，V是顶点的数目，E是边的数目，F是面的数目，C是组成图形的连通部分的数目。当图是单连通图的时候，公式简化为：
V-E+F=2
贝尔曼-福特算法（英语：Bellman–Ford algorithm），求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和莱斯特·福特创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为Edward F. Moore也为这个算法的发展做出了贡献。它的原理是对图进行



 次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达



 。但算法可以进行若干种优化，提高了效率。
贝尔曼-福特算法与迪科斯彻算法类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以贪心法选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共



 次，其中



 是图的点的数量。在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。
贝尔曼-福特算法的最多运行



 （大O符号）次，



 和



 分别是节点和边的数量）。
贝尔曼-福特算法伪代码表示
procedure BellmanFord(list vertices, list edges, vertex source)
   // 该实现读入边和节点的列表，并向两个数组（distance和predecessor）中写入最短路径信息

   // 步骤1：初始化图
   for each vertex v in vertices:
       if v is source then distance[v] := 0
       else distance[v] := infinity
       predecessor[v] := null

   // 步骤2：重复对每一条边进行松弛操作
   for i from 1 to size(vertices)-1:
       for each edge (u, v) with weight w in edges:
           if distance[u] + w < distance[v]:
               distance[v] := distance[u] + w
               predecessor[v] := u

   // 步骤3：检查负权环
   for each edge (u, v) with weight w in edges:
       if distance[u] + w < distance[v]:
           error "图包含了负权环"
贝尔曼-福特算法松弛
每次松弛操作实际上是对相邻节点的访问，第



次松弛操作保证了所有深度为n的路径最短。由于图的最短路径最长不会经过超过



条边，所以可知贝尔曼-福特算法所得为最短路径。
贝尔曼-福特算法负边权操作
与迪科斯彻算法不同的是，迪科斯彻算法的基本操作“拓展”是在深度上寻路，而“松弛”操作则是在广度上寻路，这就确定了贝尔曼-福特算法可以对负边进行操作而不会影响结果。
贝尔曼-福特算法负权环判定
因为负权环可以无限制的降低总花费，所以如果发现第



次操作仍可降低花销，就一定存在负权环。
[1]
贝尔曼-福特算法循环的提前跳出
在实际操作中，贝尔曼-福特算法经常会在未达到



次前就出解，



其实是最大值。于是可以在循环中设置判定，在某次循环不再进行松弛时，直接退出循环，进行负权环判定。
贝尔曼-福特算法队列优化
主条目：最短路径快速算法
西南交通大学的段凡丁于1994年提出了用队列来优化的算法。松弛操作必定只会发生在最短路径前导节点松弛成功过的节点上，用一个队列记录松弛过的节点，可以避免了冗余计算。原文中提出该算法的复杂度为



，



是个比较小的系数，但该结论未得到广泛认可。
[2]
贝尔曼-福特算法Pascal语言示例
Begin
 2   initialize-single-source(G,s);
 3   initialize-queue(Q);
 4   enqueue(Q,s);
 5   while not empty(Q) do 
 6     begin
 7       u:=dequeue(Q);
 8       for each v∈adj[u] do 
 9         begin
10           tmp:=d[v];
11           relax(u,v);
12           if (tmp<>d[v]) and (not v in Q) then
13             enqueue(Q,v);
14         end;
15     end;
16 End;
贝尔曼-福特算法C++语言示例
int SPFA(int s) {
 2     queue<int> q;
 3     bool inq[maxn] = {false};
 4     for(int i = 1; i <= N; i++) dis[i] = 2147483647;
 5     dis[s] = 0;
 6     q.push(s); inq[s] = true;
 7     while(!q.empty()) {
 8         int x = q.front(); q.pop();
 9         inq[x] = false;
10         for(int i = front[x]; i !=0 ; i = e[i].next) {
11             int k = e[i].v;
12             if(dis[k] > dis[x] + e[i].w) {
13                 dis[k] = dis[x] + e[i].w;
14                 if(!inq[k]) {
15                     inq[k] = true;
16                     q.push(k);
17                 }
18             }
19         }
20     }
21     for(int i =  1; i <= N; i++) cout << dis[i] << ' ';
22     cout << endl;
23     return 0;
24 }
算法是一组有穷的规则，它们规定了解决某一特定类型问题的一系列运算，是对解题方案内的准确与完整地描述。制定一个算法，一般要经过设计、确认、分析、编码、测试、调试、计时等阶段。
[1]
算法+数据结构=程序，求解一个给定的可计算或可解的问题，不同的人可以编写出不同的程序，来解决同一个问题，这里存在两个问题：一是与计算方法密切相关的算法问题；二是程序设计的技术问题。算法和程序之间存在密切的关系。分析算法可以预测这一算法适合在什么样的环境中有效地运行，对解决同一问题的不同算法的有效性作出比较。
[1]
通常对于一个实际问题的解决，可以提出若干个算法，如何从这些可行的算法中找出最有效的算法呢？或者有了一个解决实际问题的算法后，如何来评价它的好坏呢？这些问题都需要通过算法分析来确定。评价算法分析性能的标准主要从算法执行时间和占用存储空间两个方面进行考虑，即通过分析算法执行所需要的时间和存储空间来判断一个算法的优劣。
[2]
一个程序的时间复杂度是指程序运行从开始到结束所需要的时间。
算法分析影响因素
一个算法是由控制结构（顺序、分支和循环3种）和原操作（指固定数据类型的操作）构成的，其执行时间取决于两者的综合效果。为了便于比较同一问题的不同算法，通常的做法是：从算法中选取一种对于所研究的问题来说基本运算的原操作，以该原操作重复执行的次数作为算法的时间度量。一般情况下，算法中原操作重复执行次数是规模n的某个函数T(n)。许多时候要精确的计算T(n)是困难的，引入渐进时间复杂度在数量上估计一个算法的执行时间，也能够达到分析算法的目的。
[3]
算法分析计算方法
计算时间复杂度的时候，主要考虑算法中最高阶项的开销，只要找出算法中最高阶的复杂度，就可以忽略低阶和常数的复杂度。
[3]
引入数学符号“O”来估算算法时间复杂度，渐进时间复杂度的表示方法：F(n)=O(g(n))，其定义为，若F(n)和g(n)是定义在正整数集合上的两个函数，则F(n)=O(g(n))表示存在正的常数C和



 ，使得当



 时，都满足



 。换句话说，就是这两个函数当整形自变量n趋于无穷大时，两者的比值是一个不等于0的常数。
[3]
当要计算某个算法的时间复杂度F(n)时，可以找一个更简单的、阶数相同的简单算法g(n)等同计算，这里的g(n)是指替代函数，它具有和原算法一样更高阶复杂度。
[3]
例如，一个程序的实际执行时间为：



 ，则



 。使用O记号表示的算法的时间复杂度，称为算法的渐进时间复杂度。
[3]
算法分析常见的渐进时间复杂度
通常用O(1)表示常数计算时间。常见的渐进时间复杂度有：

算法分析规则
为了便于估算一个算法的时间复杂度，我们约定一下几条可操作的规则：
（1）读写单个常量或单个变量、赋值、算术运算、关系运算、逻辑运算等，计为一个单位时间。
（2）条件语句if(C){s}，执行时间为（条件C的执行时间）+（语句块s的执行时间）。
（3）条件语句if(C)s1 else s2，执行时间为（条件C的执行时间）+（语句块s1和s2中执行时间最长的那个时间）。
（4）switch...case语句的执行时间是所有case子句中，执行时间最长的语句块。
（5）访问一个数据的单个元素或一个结构体变量的单个元素只需要一个单位时间。
（6）执行一个for循环语句需要的时间等于执行该循环体所需要时间乘上循环次数。
（7）执行一个while(C){s}循环语句或者执行一个do{s} while(C)语句，需要的时间等于计算条件表达式C的时间与执行循环s的时间之和再乘以循环的次数。
（8）对于嵌套结构，算法的时间复杂度由嵌套最深层语句的执行次数决定的。
（9）对于函数调用语句，它们需要的时间包括两部分，一部分用于实现控制转移，另一部分用于执行函数本身。
[3]
一个算法的空间复杂度是指程序运行从开始到结束所需的存储空间大小。程序的一次运行是针对所求解的问题的某一特定实例而言的。例如，求解排序问题的排序算法每次执行是对一组特定个数的元素进行排序。对该组元素的排序是排序问题的一个实例。元素个数可视为该实例的特征。程序运行所需要的存储空间主要包括两部分。
[3]
算法分析固定部分
这部分空间与所处理数据的大小和个数无关，或者称与问题的实例的特征无关。主要包括程序代码、常量、简单变量、定长成分的结构变量所占的空间。
[3]
算法分析可变部分
这部分空间大小与算法在某次执行中处理的特定数据的大小和规模有关。例如100个数据元素的排序算法与1000个数据元素的排序算法所需要的存储空间显然是不同的。
[3]
算法在运行过程中临时占用的存储空间随算法的不同而异。有的算法只需要占用少量的存储空间，而且不随问题规模的大小而改变，有的算法需要占用的存储空间数随着问题规模n的增大而增大，此时按照最坏情况来分析
在查找引擎优化范畴里边有一个疑问常常让人感受捉摸不透，到底是什么样的排序要素结尾决议了网页的排名。而每个查找引擎公司都将其的查找引擎算法维护的极端紧密，只要很少很少的一有些的公司能有时机看到这些算法的全貌。并且就算是有时机看到这些算法的真实容貌，要想领悟到话，还得具有深沉的数学功底。这使得对查找引擎优化整个概念的晓得变得很艰难
算法分析算法应用和问题解决
为了更快的回来查找成果给用户，查找引擎公司通常都会将巨大的运算简化，查找引擎所运用的这些算法都会设置一个用于比拟判别网站价值的根底准则。不一样的查找引擎所运用的基准是不一样的。例如，在Google的算法中就运用了200多个要从来构建这个基准。经过很多查找引擎爱好者的研讨与查找引擎的共享，大家也大约的晓得了查找引擎算法中的重要有些。可是要想晓得查找引擎的各个细节那是不能够的工作，更何况Google简直每天都会对算法做出很多的修改。有些修正会形成很大的影响，有些则仅仅一些细微的修正。查找算法的不断改变使得大家更难知晓算法的各个细节。
算法分析算法优化
在确定了算法之后，在构建网站(或是为SEO更新网站)时就能有一些能够遵照的准则。在这些准则中，最重要的就是要以人为本，而不要为查找引擎描绘网站。所以，若是创立的网站是关于春季休假的，就应该为用户供给与春季休假有关的信息和连接。在爬虫检索网站时，若是网站中含有指向机票预订网站、假目网站、花园展现网站或其他与春季休假有关的网站的连接，爬虫就会跟踪这些连接，并经过算法判别这些网站的关联性。若是这些网站都与春季休假有亲近的联系，网站就能取得较高的排名。若是网站连接的都是一些无关的网站，就有能够查找爬虫视为连接场，网站排名会很差，乃至遭到屏蔽。其间难以确定的是，究竟网站中必须有多少关联网站的连接，又能够有多少无关网站的连接。从常理上说，若是描绘一个关于春季休假的网页，抱负的状况是进出这个网页的连接来自关联的网页。广告能够是一个破例，但这会被明确地标明为广告。另一种状况就是网站上一切的连接都是指向无关网站的广告。这样的网页显然是不受欢迎的，网页在查找引擎中的排名天然也会降低。
关键词也有相同的疑问。查找引擎偏心关键词密度较高的网站。无论是什么查找引擎，内容都是重要的，但在怎么判别内容对网页排名的影响这个疑问上，各个查找引擎都有不一样的办法。相同，元标签在各个查找引擎中的重要性也不尽相同。
从20世纪70年代初开始,装箱问题就引起了广泛的探讨和研究。然而装箱问题可以追溯到1831年高斯(Gauss)开始研究布局问题，因为装箱问题和布局问题本质上是一样的,到现在已有百余年的历史。虽然经过几代人的努力,但迄今尚无成熟的理论和有效的数值计算方法。由于目前NP完全问题不存在有效时间内求得精确解的算法,装箱问题的求解极为困难,因此,从70~80年代开始,陆续提出的装箱算法都是各种近似算法,如下次适应、首次适应、降序下次适应和调和算法等。
装箱问题广泛存在于工业生产,包括服装行业的面料裁剪、运输行业的集装箱货物装载、加工行业的板材型材下料、印刷行业的排样和现实生活中包装、整理物件等。在计算机科学中,多处理器任务调度、资源分配、文件分配、内存管理等底层操作均是装箱问题的实际应用,甚至还出现在一些棋盘形、方块形的数学智力游戏中。装箱问题的研究文献分布面很广,在运筹学、计算机辅助设计、计算机图形学、人工智能、图像处理、大规模集成电路逻辑布线设计、计算机应用科学等诸多领域都有装箱问题最新的研究动态和成果出现,从这个角度来讲,布局问题涉及到了工业生产的方方面面,也足以证明了装箱问题的应用前景日趋广泛而重要。
设有许多具有同样结构和负荷的箱子 B1，B2，… ，其数量足够供所达到
装箱问题

目的之用。每个箱子的负荷（可为长度、重量等等.）为 C ，今有 n 个负荷为 wj，0 < wj < C ， j = 1，2，…，n 的物品 J1，J2，…，Jn 需要装入箱内。装箱问题就是指寻找一种方法，使得能以最小数量的箱子数将J1，J2，…，Jn 全部装入箱内。
装箱问题按照装箱物体所属装箱空间
装箱问题可分为一维装箱问题，二维装箱问题，三维装箱问题三种。现实生活中常见的应该是三维装箱问题。
一维装箱问题只考虑一个因素，比如重量、体积、长度等。
二维装箱问题考虑两个因素——给定一张矩形的纸（布料、皮革），要求从这张纸上剪出给定的大小不一的形状，求一种剪法使得剪出的废料的面积总和最小。常见问题包括堆场中考虑长和宽进行各功能区域划分、停车场区位划分、包装材料裁切时考虑怎样裁切使得材料浪费最少、服装布料裁切、皮鞋制作中的皮革裁切等。
三维装箱问题考虑三个因素——一般指长、宽、高。装车、装船、装集装箱等要考虑这三个维度都不能超。
根据目标的不同,三维装箱问题可分成以下几类
[2] 
：
箱柜装载问题(three-dimensional bin packing problem，简称3D-BPP)：给定一些不同类型的方型箱子和一些规格统一的方型容器，问题是要把所有箱子装入最少数量的容器中。
容器装载问题(three-dimensional container-packing problems，简称3D-CPP)：在该问题中，所有箱子要装入一个不限尺寸的容器中，目标是要找一个装填，使得容器体积最小。
背包装载问题(three-dimensional knapsack loading problems，简称3D-KLP)：每个箱子有一定的价值，背包装载是选择一部分箱子装入容器中，使得装入容器中的箱子总价值最大。如果把箱子的体积作为价值，则目标转化为使容器浪费的体积最小。
装箱问题按照装箱物体的形状
1).规则物体的装箱
包括二维规则物体的装载和三维规则物体的装载。规则物体是指具有规则外形的物体,例如圆柱体、矩形体等。在以前及现在的装载研究中,研究较多的仍然是规则体的装载问题,如:工业应用中的底盘装载;三维布局中的集装箱的货物摆放问题。
货物底盘装载问题广泛存在于工业生产和交通运输中。由于箱子的大小和形状完全相同,且箱子的边平行于底盘的边,因此该问题也可简化为二维问题。对于该问题,有的学者使用精确的方法求解。在运输生产中,常见的集装箱装载要求有两类,一是集装箱数量无限,而待装的货物有限,要使集装箱利用率最高;二是集装箱数量固定,待装货物数量无限,远远超过己有集装箱的承载能力,一般是其几倍,要求在有限的集装箱空间内尽可能地多装货物,使集装箱利用率最高,生产实际中更多地遇到的是第2类问题。集装箱布局要考虑货物重量、空间利用率、货物易碎性、以及吊装的可能性等等,为多目标多约束优化问题。
2).不规则物体的装箱
包括二维不规则物体的装载和三维不规则物体的装载。不规则物体是指具有任意几何形状的物体。不规则物体的装箱问题在工业生产中大量存在,但同时也是难度最大的装箱问题。二维不规则物体的装箱如服装样本的下料、皮革下料等。三维不规则物体的装箱如向具有任意几何形状的容器中放置任意几何外形的装箱物体,并满足特定的约束条件,达到装箱目标最优。该问题的求解算法基本上是启发式的。
[3]
装箱问题按照装箱物体达到情况
1).在线装箱问题
如果一个装箱算法在装入物品时，只利用前面物品的信息，而不知道后继元素的任何信息，即按照元素到达顺序随到随装，则称该算法为在线(online)算法。这种情况下的装箱问题称为在线装箱问题。在实际应用中，往往要求装载具有在线特性。例如对从传送带上下来的物体进行装载。
2).离线装箱问题
物品装载以前就已得到所有物品信息,之后统一处理所有物品的近似算法称为离线(offline)装箱算法。这种情况下的装箱问题称为离线装箱问题。现代化的物流配送中,很多都要求按订单送货,因此物品的信息提前都是知道的。该问题广泛地出现在铁路货车车厢装载、汽车车厢装载、轮船配载、集装箱装载等情况中。
装箱问题数学规划法(Mathematieal Programming)
数学规划法包括分枝定界法(Branch一and一boundAlgorithm)、动态规划法(Dynamic programming)、整数规划法(Integer Programming)和线性规划法(Linear programming)等。该方法利用某一优化问题的数学模型,通过修改该模型的精确求解过程得到有效的启发式算法。这四种方法中分枝定界法应用较广泛。该方法的基本思想是试图通过枚举解空间中的有限个解来获得NP完全问题的局部最优解。它由分枝和定界两个操作步骤组成,分枝操作用于将规模较大的原始问题逐步分解为规模较小且易于求解的子问题;而定界操作主要用于评价各分枝的优劣,来减小搜索范围。二维切割问题中,“一刀切”问题是该方法的经典应用,如玻璃切割、纸张裁剪等。
装箱问题构造法(Construetion Algorithms)
装箱启发式算法中使用最多的方法是构造性算法。构造启发式算法通过一个一个地增加解的构造元素来求得一个可行解。构造性算法的循环次数与问题解的构造元素个数成正比,而与解空间的大小无关,因此其计算速度通常很快。
装箱问题中构造法基本上由两类规则组成。第一类为定序规则(orderingrules),它被用来确定待布局物体放入布局空间的先后顺序:第二类为定位规则(Placement rules),它用来确定每一个布局物体在布局空间摆放的位置。由于定序规则和定位规则的不同,也就产生不同的构造布局方法。常用的定序规则有:




装箱问题求解
(l)按照待装物体最短边边长递减的顺序进行定序:
(2)按照待装物体最长边边长递减的顺序进行定序;
(3)按照待装物体体积递减的顺序进行定序;
(4)按照待装物体最小面积递减的顺序进行定序;
(5)按照待装物体可行域递减的顺序进行定序:
许多学者对布局问题中定位规则进行了研究,提出了如下一些规则和策略:
(1)占角策略,即将待装物体摆放在布局容器的某一角:
(2)顺放策略,即从布局容器的某一角开始将待装物体沿着容器某一边摆放;
(3)在底盘装载中,将待装物体先沿着边放置,最后摆放到底盘中心;
(4)在三维规则装箱中,从布局容器的某一面墙开始,一层一层地布局;在某一面墙上,再确定一条边,最后归结为一个角:
(5)在三维规则装箱中,先按“右、前、上”的顺序找寻剩余空间,然后按照“左、后、下”的顺序摆待装局物体:
装箱问题数值优化方法(optimal Algorithms)
数值优化方法具有较为成熟的理论和算法,广泛应用于工程设计领域；取得了许多有效成果,装箱问题是它的一个应用分支,但是数值优化方法依赖于数学模型,且只能找到局部最优解,它只适用于小规模物体的装箱问题。对于规模大的装箱问题用数学模型很难准确描述,即使能用简化的数学模型来描述,由于局部最优解数目的急剧增加,其求解质量也将严重变坏。此外,数值优化方法所得解的质量在很大程度上还依赖于初始解的选择。
装箱问题现代优化方法
主要有遗传算法(GenetiC Algorithm,GA),模拟退火法(SimulatedAnnealing,SA)两种。其中，遗传算法是一种基于生物学进化原理的搜索算法。在解决高维空间、高复杂及非线性问题的优化中具有全局最优、效率高及易于并行计算等优点,有很强的解决问题的能力,但有着收敛速度慢和易陷入局部最优解的缺点。
[4]
由于一般组合优化问题与物质的退火过程具有很大的相似性,因此,模拟退火算法被广泛的用来解决组合优化问题,在这方面已有一些成功的应用实例,模拟退火算法可用来解决连续、离散等优化问题,尤其是解空间状态不良的问题。尽管模拟退火算法是一种有可能得到优化问题的全局最优解的问题求解方法,并且已经逐步成为一种用于优化问题求解的一般、通用的方法,但是这是以极其漫长的退火过程即问题求解过程为代价的。
堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
[1]
在堆的数据结构中，堆中的最大值总是位于根节点（在优先队列中使用堆的话堆中的最小值位于根节点）。堆中定义以下几种操作：
最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点
创建最大堆（Build Max Heap）：将堆中的所有数据重新排序
堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算
[1]
堆排序C语言
#include <stdio.h>
#include <stdlib.h>

void swap(int* a, int* b)
{
    int temp = *b;
    *b = *a;
    *a = temp;
}

void max_heapify(int arr[], int start, int end) 
{
    //建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end)  //若子节点指标在范围内才做比较
        {
            if (son + 1 <= end && arr[son] < arr[son + 1]) 
            //先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] > arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数
            return;
        else  //否则交换父子内容再继续子节点和孙节点比较
        {
            swap(&arr[dad], &arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) 
{
    int i;
    //初始化，i从最後一个父节点开始调整
    for (i = len / 2 - 1; i >= 0; i--)
        max_heapify(arr, i, len - 1);
    //先将第一个元素和已排好元素前一位做交换，再重新调整，直到排序完毕
    for (i = len - 1; i > 0; i--) 
    {
        swap(&arr[0], &arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

int main() {
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    int i;
    for (i = 0; i < len; i++)
        printf("%d ", arr[i]);
    printf("\n");
    return 0;
}
堆排序C++
#include <iostream>
#include <algorithm>
using namespace std;

void max_heapify(int arr[], int start, int end) 
{
    //建立父节点指标和子节点指标
    int dad = start;
    int son = dad * 2 + 1;
    while (son <= end)  //若子节点指标在范围内才做比较
    {    
        if (son + 1 <= end && arr[son] < arr[son + 1]) //先比较两个子节点大小，选择最大的
            son++;
        if (arr[dad] > arr[son]) //如果父节点大於子节点代表调整完毕，直接跳出函数
            return;
        else  //否则交换父子内容再继续子节点和孙节点比较
        {
            swap(arr[dad], arr[son]);
            dad = son;
            son = dad * 2 + 1;
        }
    }
}

void heap_sort(int arr[], int len) 
{
    //初始化，i从最後一个父节点开始调整
    for (int i = len / 2 - 1; i >= 0; i--)
        max_heapify(arr, i, len - 1);
    //先将第一个元素和已经排好的元素前一位做交换，再从新调整(刚调整的元素之前的元素)，直到排序完毕
    for (int i = len - 1; i > 0; i--) 
    {
        swap(arr[0], arr[i]);
        max_heapify(arr, 0, i - 1);
    }
}

void main() 
{
    int arr[] = { 3, 5, 3, 0, 8, 6, 1, 5, 8, 6, 2, 4, 9, 4, 7, 0, 1, 8, 9, 7, 3, 1, 2, 5, 9, 7, 4, 0, 2, 6 };
    int len = (int) sizeof(arr) / sizeof(*arr);
    heap_sort(arr, len);
    for (int i = 0; i < len; i++)
        cout << arr[i] << ' ';
    cout << endl;
    system("pause");
}
堆排序Java语言
/**
    * 选择排序-堆排序
    * @param array 待排序数组
    * @return 已排序数组
    */
    public static int[] heapSort(int[] array) {
        //这里元素的索引是从0开始的,所以最后一个非叶子结点array.length/2 - 1
        for (int i = array.length / 2 - 1; i >= 0; i--) {  
            adjustHeap(array, i, array.length);  //调整堆
        }
 
        // 上述逻辑，建堆结束
        // 下面，开始排序逻辑
        for (int j = array.length - 1; j > 0; j--) {
            // 元素交换,作用是去掉大顶堆
            // 把大顶堆的根元素，放到数组的最后；换句话说，就是每一次的堆调整之后，都会有一个元素到达自己的最终位置
            swap(array, 0, j);
            // 元素交换之后，毫无疑问，最后一个元素无需再考虑排序问题了。
            // 接下来我们需要排序的，就是已经去掉了部分元素的堆了，这也是为什么此方法放在循环里的原因
            // 而这里，实质上是自上而下，自左向右进行调整的
            adjustHeap(array, 0, j);
        }
        return array;
    }
 
    /**
    * 整个堆排序最关键的地方
    * @param array 待组堆
    * @param i 起始结点
    * @param length 堆的长度
    */
    public static void adjustHeap(int[] array, int i, int length) {
        // 先把当前元素取出来，因为当前元素可能要一直移动
        int temp = array[i];
        for (int k = 2 * i + 1; k < length; k = 2 * k + 1) {  //2*i+1为左子树i的左子树(因为i是从0开始的),2*k+1为k的左子树
            // 让k先指向子节点中最大的节点
            if (k + 1 < length && array[k] < array[k + 1]) {  //如果有右子树,并且右子树大于左子树
                k++;
            }
            //如果发现结点(左右子结点)大于根结点，则进行值的交换
            if (array[k] > temp) {
                swap(array, i, k);
                // 如果子节点更换了，那么，以子节点为根的子树会受到影响,所以，循环对子节点所在的树继续进行判断
                    i  =  k;
                        } else {  //不用交换，直接终止循环
                break;
            }
        }
    }
 
    /**
    * 交换元素
    * @param arr
    * @param a 元素的下标
    * @param b 元素的下标
    */
    public static void swap(int[] arr, int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
堆排序Python语言
def big_endian(arr,start,end):    
    root=start    
    child=root*2+1 #左孩子    
    while child<=end:
    #孩子比最后一个节点还大，也就意味着最后一个叶子节点了，就得跳出去一次循环，已经调整完毕     
        if child+1<=end and arr[child]<arr[child+1]:
        #为了始终让其跟子元素的较大值比较，如果右边大就左换右，左边大的话就默认           
            child+=1            
        if arr[root]<arr[child]:
        #父节点小于子节点直接交换位置，同时坐标也得换，这样下次循环可以准确判断：是否为最底层，
        #是不是调整完毕                
            arr[root],arr[child]=arr[child],arr[root]                
            root=child                
            child=root*2+1            
        else:               
        break
        
def heap_sort(arr): #无序区大根堆排序    
    first=len(arr)//2 - 1    
    for start in range(first,-1,-1):
    #从下到上，从左到右对每个节点进行调整，循环得到非叶子节点        
        big_endian(arr,start,len(arr)-1) #去调整所有的节点    
    for end in range(len(arr)-1,0,-1):        
        arr[0],arr[end]=arr[end],arr[0] #顶部尾部互换位置        
        big_endian(arr,0,end-1) #重新调整子节点的顺序，从顶开始调整    
    return arr
    
def main():    
    l=[3,1,4,9,6,7,5,8,2,10]    
    print(heap_sort(l))

if __name__=="__main__":    
    main()
数学规划的基本概念之一。指在数学规划问题中，使目标函数取最小值（对极大化问题取最大值）的可行解。使目标函数取最小值的可行解称为极小解，使其取最大值的可行解称为极大解。极小解或极大解均称为最优解。相应地，目标函数的最小值或最大值称为最优值。有时，也将最优解和最优值一起称为相应数学规划问题的最优解。
线性规划的最优解不一定只有一个，若其有多个最优解，则所有最优解所构成的集合称为该线性规划的最优解域。
例如:已知变量x，y满足约束条件：
1、y≤3;
2、x+y≥1;
3、x-y≤1，
则z=2x-y的最优解为（4，3）或（-2，3）；
[1]
设D = 



非空， 则它的极点集非空且包含有限多个点



 而且D 的极方向集非空当且仅当D 无界。若D 无界， 则它的极方向集包含有限个向量



 此外， x ∈D 当且仅当x 可以表示为



 的凸组合与



的非负线性组合之和， 即
其中



，



，



；



，
设（SL P）有最优解， 则必存在基最优解（最优极点） ， 记（SL P）的最优极点集为



另外， 由(1) 式不难看出，（SL P）有最优解当且仅当对于所有的极方向



有



。
设



 为（SL P） 的最优解， 若D 的某极方向



 满足



 （即



与c正交） ， 则易见， 对于任意的，



 都是最优解。 我们称满足



的极方向为最优极方向。 记（SL P）的最优极方向集为



。
最优解最小二乘法估计
最小二乘法估计是建立在模型服从高斯分布的假设之上。当从模型总体随机抽取M组样本观测值后，最合理的参数估计值应该使得模型能最好地拟合样本数据，也就是估计值和观测值之差的平方和最小。而对于最大似然估计，当从模型总体随机抽取M组样本观测值后，最合理的参数估计值应该使得从模型中抽取该M组样本观测值的概率最大。
最优解最大似然估计
最大似然估计代表了频率派的观点：参数虽然未知但是客观存在的，当参数求出来后，x，y也就知道了。
假设我们观察的变量是x，观察的变量取值（样本）为



，要估计的模型参数是θ，x的分布函数是



。那么最大似然函数就是θ的一个估计值，它使得事件发生的可能性最大：
通常认为x是独立同分布的：
所以最大似然估计的一般求解流程就是：
最大似然估计中，参数θ是一个固定的值，只要能够拟合样本数据就可以了。但是当样本过少的时候就容易出现过拟合现象，会得到诸如只要没见过飞机相撞，飞机就一定不会相撞的扭曲事实。
最优解贝叶斯估计
贝叶斯派将参数θ作为随机变量，服从某一分布。正因为参数是不固定的，对于给定的x无法用确定的y来表示，而是用概率的方式来表达。
我们希望求出观察到样本x的情况下，θ的分布情况



。根据贝叶斯定理可得：
上面的后验概率通常是很难计算的，因为要对所有的参数进行积分，而且，这个积分其实就是所有θ的后验概率的汇总，其实它是与最优θ是无关的，而我们只关心最优θ（



相同）。在这种情况下，我们采用了一种近似的方法求后验概率，这就是最大后验估计：
最大后验估计相比最大似然估计，只是多了一项先验概率，它正好体现了贝叶斯认为参数也是随机变量的观点，在实际运算中通常通过超参数给出先验分布。最大似然估计其实是经验风险最小化的一个例子，而最大后验估计是结构风险最小化的一个例子。如果样本数据足够大，最大后验概率和最大似然估计趋向于一致，如果样本数据为0，最大后验就仅由先验概率决定。尽管最大后验估计看着要比最大似然估计完善，但是由于最大似然估计简单，很多方法还是使用最大似然估计。
分布式计算简单来说，是把一个大计算任务拆分成多个小计算任务分布到若干台机器上去计算，然后再进行结果汇总。 目的在于分析计算海量的数据，从雷达监测的海量历史信号中分析异常信号(外星文明)，淘宝双十一实时计算各地区的消费习惯等。
海量计算最开始的方案是提高单机计算性能，如大型机，后来由于数据的爆发式增长、单机性能却跟不上，才有分布式计算这种妥协方案。 因为计算一旦拆分，问题会变得非常复杂，像一致性、数据完整、通信、容灾、任务调度等问题也都来了。
举个例子，产品要求从数据库中100G的用户购买数据，分析出各地域的消费习惯金额等。 如果没什么时间要求，程序员小明就写个对应的业务处理服务程序，部署到服务器上，让它慢慢跑就是了，小明预计10个小时能处理完。 后面产品嫌太慢，让小明想办法加快到3个小时。　　平常开发中类似的需求也很多，总结出来就是，数据量大、单机计算慢。 如果上Hadoop、storm之类成本较高、而且有点大才小用。 当然让老板买更好的服务器配置也是一种办法。
分布性和并发性是分布式算法的两个最基本的特征。分布式系统的执行存在着许多非稳定性的因素。由于这些多方面的差异，导致分布式算法的设计和分析，较之集中式算法来讲，要复杂得多，也困难得多。
所谓分布式算法，就是指在完成乘加功能时通过将各输入数据每一对应位产生的运算结果预先进行相加形成相应的部分积，然后再对各部分进行累加形成最终结果。
而传统算法则是等到所有乘积结果之后再进行相加，从而完成整个乘加运算。
分布式算法Paxos算法
1）问题描述
分布式中有这么一个疑难问题，客户端向一个分布式集群的服务端发出一系列更新数据的消息，由于分布式集群中的各个服务端节点是互为同步数据的，所以运行完客户端这系列消息指令后各服务端节点的数据应该是一致的，但由于网络或其他原因，各个服务端节点接收到消息的序列可能不一致，最后导致各节点的数据不一致。
2）算法本身
算法本身我就不进行完整的描述和推导，网上有大量的资料做了这个事情，但我学习以后感觉莱斯利·兰伯特（Leslie Lamport，paxos算法的奠基人，此人现在在微软研究院）的Paxos Made Simple是学习paxos最好的文档，它并没有像大多数算法文档那样搞一堆公式和数学符号在那里吓唬人，而是用人类语言让你搞清楚Paxos要解决什么问题，是如何解决的。这里也借机抨击一下那些学院派的研究者，要想让别人认可你的成果，首先要学会怎样让大多数人乐于阅读你的成果，而这个描述Paxos算法的文档就是我们学习的榜样。
言归正传，透过Paxos算法的各个步骤和约束，其实它就是一个分布式的选举算法，其目的就是要在一堆消息中通过选举，使得消息的接收者或者执行者能达成一致，按照一致的消息顺序来执行。其实，以最简单的想法来看，为了达到大伙执行相同序列的指令，完全可以通过串行来做，比如在分布式环境前加上一个FIFO队列来接收所有指令，然后所有服务节点按照队列里的顺序来执行。这个方法当然可以解决一致性问题，但它不符合分布式特性，如果这个队列down掉或是不堪重负这么办？而Paxos的高明之处就在于允许各个client互不影响地向服务端发指令，大伙按照选举的方式达成一致，这种方式具有分布式特性，容错性更好。
说到这个选举算法本身，可以联想一下现实社会中的选举，一般说来都是得票者最多者获胜，而Paxos算法是序列号更高者获胜，并且当尝试提交指令者被拒绝时（说明它的指令所占有的序列号不是最高），它会重新以一个更好的序列参与再次选举，通过各个提交者不断参与选举的方式，达到选出大伙公认的一个序列的目的。也正是因为有这个不断参与选举的过程，所以Paxos规定了三种角色（proposer，acceptor，和 learner）和两个阶段（accept和learn），三种角色的具体职责和两个阶段的具体过程就见Paxos Made Simple，另外一个国内的哥们写了个不错的PPT，还通过动画描述了paxos运行的过程。不过还是那句话不要一开始就陷入算法的细节中，一定要多想想设计这些游戏规则的初衷是什么。
Paxos算法的最大优点在于它的限制比较少，它允许各个角色在各个阶段的失败和重复执行，这也是分布式环境下常有的事情，只要大伙按照规矩办事即可，算法的本身保障了在错误发生时仍然得到一致的结果。
3）算法的实现
Paxos的实现有很多版本，最有名的就是google chubby，不过看不了源码。开源的实现可见libpaxos。另外，ZooKeeper也基于paxos解决数据一致性问题，也可以看看它是如果实现paxos的
[1] 
。
分布式算法一致性Hash算法
1）问题描述
分布式常常用Hash算法来分布数据，当数据节点不变化时是非常好的，但当数据节点有增加或减少时，由于需要调整Hash算法里的模，导致所有数据得重新按照新的模分布到各个节点中去。如果数据量庞大，这样的工作常常是很难完成的。一致性Hash算法是基于Hash算法的优化，通过一些映射规则解决以上问题
2）算法本身
实际上，在其他设计和开发领域我们也可以借鉴一致性Hash的思路，当一个映射或规则导致有难以维护的问题时，可以考虑更一步抽象这些映射或规则，通过规则的变化使得最终数据的不变。一致性hash实际就是把以前点映射改为区段映射，使得数据节点变更后其他数据节点变动尽可能小。这个思路在操作系统对于存储问题上体现很多，比如操作系统为了更优化地利用存储空间，区分了段、页等不同纬度，加了很多映射规则，目的就是要通过灵活的规则避免物理变动的代价
3）算法实现
一致性Hash算法本身比较简单，不过可以根据实际情况有很多改进的版本，其目的无非是两点：
节点变动后其他节点受影响尽可能小
节点变动后数据重新分配尽可能均衡
[2]
在应用程序中引用的任何数据结构元素，如文件、数据、变量等都称为数据对象，简称为对象。它是使用编程语言允许的字符命名。在Fortran90或95中，数据对象是一种数据实体，它是一个常量、一个变量或常量的子对象。FORTRAN语言处理的数据对象都有类型(显式或隐式地规定)、数据值和属性(对象的特征和被使用的方式)。子对象是某些有名对象的一部分，可由其他部分引用和独立地定义。子对象包括数组的部分(数组元素)、字符串的部分(子串)和结构的部分(成分)。
[2]
数据属性定义了数据对象的性质，可以用来：①为数据对象的实例命名：②描述这个实例：③建立对另一个表中的另一个实例的引用。另外，必须把一个或多个属性定义为标识符。也就是说，当要找到数据对象的一个实例时，标识符属性成为一个“键”。在某些情况下，标识符的值是唯一的，但不是必需的。在数据对象“汽车”的例子中，标识号是一个合理的标识符。
通过对问题环境的理解，可以恰当地确定特定数据对象的一组属性。“汽车”的属性可以用于汽车运输部门的应用系统，而汽车制造公司需要制造中的控制软件。在后一种情况下，“汽车”的属性可能也包括标识号、车体类型和颜色，但为了使汽车在制造的控制环境下成为一个有用的对象，必须增加许多其他属性(如内部代码、驱动系统类型、车内包装设计师和传动类型等)。
[1]
数据对象彼此之间相互连接的方式称为联系，也称为关系。二元联系即只有两个实体型参与的联系，可分为三种类型：
(1) 一对一联系
例如，一个部门有一个经理．而每个经理只在一个部门任职，则部门和经理这两个实体的联系是一对一的；一个人只能拥有一张有效的身份证，一张身份证也只对应一个法律意义上的人，个人和身份证这两个实体的联系是一对一的；一个班级有一位班长．一个班长只能在一个班级任职，班级和班长这两个实体的联系是一对一的。
从上面的例子，我们可以得出结论：如果对于实体集A中的每一个实体．实体集B中至多有一个实体与之联系，反之亦然．那么实体集A与实体集B具有一对一联系。
(2) 一对多联系
例如，一个班级有多个班干部，一个班干部只能在一个班级任职，班级和班干部这两个实体的联系是一对多的；一个班级有多名学生，一名学生只能在一个班级中，班级和学生这两个实体的联系是一对多的；一种商品类别包含多种商品。一种商品只属于一个商品类别，商品类别和商品这两个实体的联系是一对多的。
(3) 多对多联系
例如，一个出版社可以出版多种书．每一种书可以由多个出版社出版，出版社和书这两个实体的联系是多对多的；一个学生可以选修多门课，一门课可以有多个学生选修，学生和课程这两个实体之间的联系是多对多的。
[3]
辅助数据对象也是系统服务对象，主要任务是反映和记录系统中所使用的基础数据和常用不变的数据，根据实际需要可以增加必要的数据对象，下面列出几个常用的辅助数据对象。
(1)设施设备。设备对象是指与监理业务相关并且可用的设施设备实体，其属性有：设备编号、设备名称、功能说明、规格型号、库存数量、购置日期、设备单价、计量单位、备注说明等。
(2)往来单位。往来单位对象是指与建设工程、监理业务相关的实体，其属性有：单位编号、单位名称、单位地址、单位类型、联系人员、负责人、联系电话、备注说明等。
(3)往来单位类型。往来单位类型是动态反映往来单位特征和性质的延伸对象，服务于往来单位对象，其属性有：单位类别编号、单位类别名称、备注说明等。
另外，还有许多辅助数据对象，人员、工程级别等，根据系统需要，例如之前已介绍过的工程性质、系统用户和可随时增加所需要的辅助数据对象。
[4]
全局优化问题的一般形式是：


其中，



 是可行域，



 是目标函数。上述问题一般称为原问题，这里记为问题(1)。根据可行域X的不同情况，问题(1)又可分为多种类型。如果X=



 ，则得无约束全局优化问题，记为问题(2)；如果X={



 |



 }为一个闭箱，则得闭箱约束全局优化问题，记为问题(3)；如果X是一个多面体，则得线性约束全局优化问题。
[1]
填充函数是由西安交通大学的R.Ge(葛仁溥)教授首先提出的，填充函数法充分地利用了函数在可行域上的局部性质。
填充函数的定义如下：
函数p(x，



 )称为f(x)在局部极小点



 处的填充函数，如果满足：
(1)



 是p(x，



 )的一个严格局部极大点，f(x)在点



 处的盆谷



 成为p(x，



 )的峰的一部分；
(2) p(x，



 )在比



 高的盆谷里没有平稳点；
(3) 如果存在比



 低的盆谷



 ，则存在x'∈



 主使得p(x，



 )在x'和



 的连线上存在极小点．
由填充函数的定义可以看出，如果当前极小点不是全局极小点的话，通过极小化填充函数则可以跳出原问题当前局部极小点，并到达一个原问题函数值比当前局部极小值还要小的点。因此，从该点出发极小化原问题目标函数，必将导致一个原问题目标函数值更小的局部极小点。
填充函数算法由两个阶段组成：极小化阶段和填充阶段。这两个阶段交替使用直到找不到更好的局部极小点。在第一阶段里，可以用经典的极小化算法寻找目标函数的一个局部极小值点



 。然后进入第二阶段，在当前极小点



 处定义一个填充函数，通过极小化填充函数，找到点



 ，使得



 ，而后以x'为初始点，重复第一步，一直到找不到更好的局部极小点。为此葛仁溥给出了一个两个参数的填充函数函数：
[2]

填充函数的优点是较多地利用了函数的性质，所以收敛速度比较快，算法的设计和执行也相对容易；缺点是填充函数过多依赖一些未知参数，这就增加了算法设计之前的工作量，要经大量的实验，来确定参数的取值范围，以确保能找到满意的全局最优解，而且填充函数利用的是线搜索，所以对寻找低盆谷的点也有很大的难度。
[1]
打洞函数法是由Levy和Montalvo在1985年首先提出的，它由一系列循环组成，每个循环包括两个阶段：局部极小化阶段和打洞阶段。
首先是极小化阶段，由一个初始点出发，应用局部极小化算法，求得f(x)的一局部极小点



 。其次是打洞阶段，先定义



 处的打洞函数：

这里



 是



 的强度，然后寻找T(x，



 )≤0的点，即找到



 ，使



 ，由x'作为初始点开始下一轮循环，必将得到一个更好的极小点。
采用适当极小化打洞函数的方法找到一个局部极小点x'，并对其进行讨论：
(1) 如果x'=



 ，则增大



 ，使得x'不再是T(x，



 )的局部极小点。
(2) 如果x'≠



 ：并且



 ，那么构造新的打洞函数：

这里，



 是



 的强度，目的是使x'不再是T(x，



 )的局部极小点，防止极小化T(x，



 )时又得到x'，然后重新极小化T(x，



 )。
(3) 如果f(x')≤f(



 )，则由x'为初始点开始下一轮循环。
打洞函数存在下述缺陷：
(1) 极的强度



 与问题有关，当



 增大到足够大时算法才会有效，而增加



 ，算法必须重新开始，从而增加工作量。
(2) 打洞函数可能找到另一局部极小点x'，成立f(x')≥f(



 )。这样对于第二个局部极小点x'，必须加上另一个极，打洞过程又要重新开始，又增加了工作量。
(3) 极的增加会引起打洞函数成为平坦，这时候极小点很难求。
[1]
通过引入变量t，下面的D.C.规划问题：


可以转化为等价的凹极小化问题（记为问题(4)）：



显然，目标函数



 是凹的，可行域



 是一个凸集，因此，如果(x‘，t‘)是问题(4)的一个全局最优解，则x’是D.C.规划问题的一个全局最优解，且t‘=f(x‘)。
因此，对于任一D.C.规划问题都可以通过凹极小化算法求解。对于凹极小化问题，人们已经提出了一些算法，这些算法多以分枝定界技巧、割平面方法、最优性条件和整数规划等方法为基础，且它们的有效性依赖于所要解决问题的结构特点。
[1]
区间方法考虑的是问题(2)，其基本思想是以区间分析为基础，按照区间算术运算规则用区间变量代替点变量进行区间计算，并将分支定界法和Moore-Skelboe算法等方法相结合。对这类算法，Moore首次提出区间全局优化这一概念。在这一研究领域里，所有的算法都包含精确区间计算，以及算法的执行效率依赖于目标函数、梯度和约束区间扩张的构造方法。这类方法一般分为五个基本步骤：定界、分支、终止、删除和分裂。其中包括区间分裂规则、删除规则及区间选择规则，不同的区间算法在于这几种规则的不同处理手段上。
区间方法和其他方法(即以点搜索方式产生近似点序列)相比，它的突出优点是对于低维空间中全局优化问题，能在给定精度内求出问题的全部全局极小点。特别地，对于二维空间中的单变量目标函数，建立了计算效率很高的求一元函数全局极小的区间斜率算法。缺点是当用于高维全局优化问题时，算法的计算量很大，对于区间分裂规则、删除规则及区间选择规则以及它们的检验条件的确定，难度都很大。
[1]
在分支定界算法中，可行域得到松弛，并且把原区域逐次分割成越来越多的小区域，这个过程称为分支；在这些小区域内，确定目标函数的下界和上界，这个过程称为定界。在算法的某个阶段，对于在其内下界大于当前最小的上界的小区域，将其删除，这个过程称为剪支，因为这些小区域中显然不包含最优解。随着分支越来越细，最小上界的不断下降，最大下界的不断上升，当最大下界和最小上界之差趋于零，同时细分的小区域收缩为一个点时，我们可以得到目标函数的全局极小值和全局极小点。
各种分支定界算法在求解连续变量的全局最优化问题时，有如下共同的特点：
(1) 对目标函数和可行域有较高的要求，以便于分支和定界。算法的效率与分支和定界方法的效率紧密相关。
(2) 在算法实施时，需要储存越来越多的细分的小区域和目标函数在其上的下界，这使得在编程时，对数据结构的选择、计算机内存的使用提出了更高的要求。
[2]
在电脑运算中，拉斯维加斯算法是一种永远给出正确解的随机化算法；也就是说，它总是给出正确结果，或是返回失败。 换言之，拉斯维加斯算法不赌结果的正确性，而是赌运算所用资源。一个简单的例子是随机快速排序，他的中心点虽然是随机选择的，但排序结果永远一致。
[1]
算法如下：
GSAT(Γ∈CNF)
begin
1. for i=1 to Max-tries
2. S=random(Γ); // random assignment
3. for j=1 to Max-moves;
4. if S satisfies Γ then return(Yes);
5. else S=S with some variable flipped to minimize the
number of unsatisfied clauses;
6. end;
7. end;
8. return (No satisfying truth assignment found)
end
随机化算法（randomized algorithm），是这样一种算法，在算法中使用了随机函数，且随机函数的返回值直接或者间接的影响了算法的执行流程或执行结果。就是将算法的某一步或某几步置于运气的控制之下，即该算法在运行的过程中的某一步或某几步涉及一个随机决策，或者说其中的一个决策依赖于某种随机事件。
[2]
快速排序使用分治法（Divide and conquer）策略来把一个序列（list）分为两个子序列（sub-lists）。
步骤为：
从数列中挑出一个元素，称为“基准”（pivot），
重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分割结束之后，该基准就处于数列的中间位置。这个称为分割（partition）操作。
递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。
递归到最底部时，数列的大小是零或一，也就是已经排序好了。这个算法一定会结束，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。
[1]
图的邻接表存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。如词条概念图所示，表结点存放的是邻接顶点在数组中的索引。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。
[1]
邻接表是图的一种最主要存储结构,用来描述图上的每一个点。对图的每个顶点建立一个容器（n个顶点建立n个容器），第i个容器中的结点包含顶点Vi的所有邻接顶点。实际上我们常用的邻接矩阵就是一种未离散化每个点的边集的邻接表。
在有向图中，描述每个点向别的节点连的边（点a->点b这种情况）。
在无向图中，描述每个点所有的边(点a-点b这种情况)
与邻接表相对应的存图方式叫做边集表，这种方法用一个容器存储所有的边。
工业上有很多非常好的图库的实现,例如C++的boost graph库.如果可以，尽量用这些库，这样可以大大提高你的效率。
注意：
n个顶点e条边的无向图的邻接表表示中有n个顶点表结点和2e个边表结点。(换句话说，每条边（i,j）在邻接表 中出现两次：一次在关于i的邻接表中，另一次在关于j的邻接表中)
邻接表有向图
对于有向图，vi的邻接表中每个表结点都对应于以vi为始点射出的一条边。因此，将有向图的邻接表称为出边表。
【例】有向图G6如下图所示，其中顶点v1的邻接表上两个表结点中的顶点序号分别为0和4，它们分别表示从v1射出的两条边(简称为v1的出边)：<v1，v0>和<v1，v4>。
注意：
n个顶点e条边的有向图，它的邻接表表示中有n个顶点表结点和e个边表结点。（因为有向图是单向的）
邻接表逆邻接表
在有向图中，为图中每个顶点vi建立一个入边表的方法称逆邻接表表示法。
入边表中的每个表结点均对应一条以vi为终点(即射入vi)的边。
注意：
n个顶点e条边的有向图，它的逆邻接表表示中有n个顶点表结点和e个边表结点。
邻接表是一个二维容器，第一维描述某个点，第二维描述这个点所对应的边集们。
实现邻接表的方法绝对有100种以上。即使是前向星这种东西也是邻接表，因为它还是描述某个点和这个点所对应的边集们.
我们说说常用的邻接表存图法（静态的array就不说了.）必须有开O1以及以上编译的条件，不然没有测试的效率无任何意义。
第一维是描述点的。可以用vector,list,forward_list,deque,map,multimap,unordered_map,unordered_multimap等（一般不能用set,mutiset,unordered_set,unordered_multiset）.
按照你的要求去选择。一般来讲存完图以后不涉及点的加入与删除优先使用vector.map,multimap,unordered_map,unordered_multimap.
第二维是描述这个点的边集，可以用全部的容器。也是的一般来讲存完图以后,不涉及点的加入与删除优先使用vector,空间充足可以考虑deque.涉及点的删除用forward_list或者是list,map,multimap,unordered_map,unordered_multimap.
对于这个图存储的方法举例(对于上面的图):
第一种:
#include <vector>
#include <iostream>
using namespace std;
int main()
{
    vector<vector<size_t>> graph(5);
    graph[0].push_back(1);//V0->V1.
    graph[1].push_back(4);//V1->V4.
    graph[1].push_back(0);//V1->V0.
    graph[2].push_back(1);//V2->V1.
    graph[2].push_back(3);//V2->V3.
    graph[3].push_back(0);//V3->V0.
    graph[4].push_back(3);//V4->V3.
    //假定要访问点1.
    for(const auto &ele:graph[1])//对于全部属于graph[1]这个容器的元素
    std::cout<<ele<<'';
    std::cout<<std::endl;
    //程序运行后输出40，表示点1连接了4点和0点。
    return 0;
}
对第一种方法有种优化就是对每个点所对应的边的向量进行预估。例如有m条有向边，n个点，那么每个向量需要reserve(6*(m/n)/5);一般这样存储效率会有显著提高。
第二种(使用map,set):
#include<map>
#include<set>
#include<iostream>
#include<cstddef>
#include<map>
#include<set>
intmain()
{
std::map<std::size_t,std::set<std::size_t>>graph;
graph[0].insert(1);//V0->V1.
graph[1].insert(4);//V1->V4.
graph[1].insert(0);//V1->V0.
graph[2].insert(1);//V2->V1.
graph[2].insert(3);//V2->V3.
graph[3].insert(0);//V3->V0.
graph[4].insert(3);//V4->V3.
//假定要访问点1.
for(constauto&ele:graph[1])//对于全部属于graph[1]这个容器的元素
std::cout<<ele<<'';
std::cout<<std::endl;
//程序运行后输出04，表示点1连接了0点和4点。对map,set里的元素进行遍历是有序的
return0;
}
方法太多，不再举例了。
然而我们这样存图是不够的，对于无向图而言，可能存在一条边需要知道自己的反向边的位置。例如欧拉回路，例如网络流都是需要的。
第二种方法由于std::map<std::size_t,std::set<std::size_t>> graph;只是离散化后的邻接矩阵。对于这种存图方法，访问反向边则非常简单，例如我访问的是a->b这样一条边。那么只需要graph[b].count(a);就可以访问其反向边b->a。
然而对于第一种方法，我们没有办法解决反向边的互相访问题。
所以我们对于这种图需要存图修正。代码如下:
#include<vector>
#include<iostream>
#include<utility>
#include<cstddef>
intmain()
{
std::vector<std::vector<std::pair<std::size_t,std::size_t>>>graph(5);//每条边的第二个元素不能是迭代器！！会失效！！！！必须是下标!!!
//比如有一条a-b的边，我们得让它实现互访。我们这里假定a=2,b=4;
std::size_ta(2),b(4);
graph[a].push_back(std::make_pair(b,graph[b].size()+(a==b)));//Va->Vb.需要判定a是否等于b.
graph[b].push_back(std::make_pair(a,graph[a].size()-1));//Vb->Va,这个不需要判定a是否等于b.
//访问反向边的方法.
for(constauto&ele:graph[a])//访问点a
graph[ele.first][ele.second];//这就是边ele的反向边了
return0;
}
对于list容器可以直接存迭代器的，但是存图时也得考虑a是否等于b.forward_list存反向边的图就不好，因为用链表存图就是需要存完图后插入删除，假定一个元素前面的元素被删除了，那么根本无法访问反向边!!!!
感觉存图没问题了？NO!!!!还有一种图更奇葩，那就是对于每个点中的边得排序又得知道反向边的那种图。USACO上有个题目叫做骑马修栅栏，那个题要求字典序输出。数据量很小，以至于可以直接矩阵存图，但是我们考虑如何数据量大，这种方法就不行了。如果用第二种方法(std::map<std::size_t,std::set<std::size_t>>)存图，绝对可以，但是相对常数较大。如果我们考虑顺序容器去存储则比较快一些。
方法就是先用边集表存图，然后每条边a,b得优先以std::min(a,b)为第一关键字再按std::max(a,b)为第二关键字排序，再按照修正后的存图方法存图即可。具体代码见nocow上骑马修栅栏那题lgeecn发的题解和代码。
如果使用list存图可以先存图再用list.sort()函数进行排序，不过似乎效率会差一些,毕竟相对于vector,list常数太大了，达到6倍以上。
存图真心不简单，因为真正用的时候你可能会遇到各种问题，但是你可以加以思考，进行容器搭配使用，即可解决。
program ljb;
type node=^link
     link=record
       qu,g:longint;
       next:node;
     end;
var nd:array[1..100000]of node;
    n,m,i,u,v,w:longint;

procedure dfs(wei:longint);
var p:node;
begin
  writeln(wei);
  p:=nd[wei];
  while p<>nil do begin
    dfs(p^.g);
    p:=p^.next;
  end;
end;

procedure addd(u,v,w:longint); //建立邻接表
var p:node;
begin
  new(p);
  p^.g:=v;
  p^.next:=nd[u];
  p^.qu:=w;
  nd[u]:=p;
end;

begin
  readln(n,m); //n:结点数 m:边数
  for i:=1 to m do begin
    readln(u,v,w);
    addd(u,v,w);
  end;
  dfs(1);//从1号节点开始dfs
end.
无向图只要在addd过程中反过来再new一遍就可以了
在支持自调用的编程语言中，递归可以通过简单的函数调用来完成，如计算阶乘的程序在数学上可以定义为：
这一程序在Scheme语言中可以写作：
(define (factorial n)  (if (= n 0)      1      (* n (factorial (- n 1)))))
递归算法不动点组合子
即使一个编程语言不支持自调用，如果在这语言中函数是第一类对象（即可以在运行期创建并作为变量处理），递归可以通过不动点组合子（英语：Fixed-point combinator）来产生。以下Scheme程序没有用到自调用，但是利用了一个叫做Z 算子（英语：Z combinator）的不动点组合子，因此同样能达到递归的目的。
(define Z  (lambda (f)    ((lambda (recur) (f (lambda arg (apply (recur recur) arg))))     (lambda (recur) (f (lambda arg (apply (recur recur) arg)))))))(define fact  (Z (lambda (f)       (lambda (n)         (if (<= n 0)             1             (* n (f (- n 1))))))))
这一程序思路是，既然在这里函数不能调用其自身，我们可以用 Z 组合子应用(application)这个函数后得到的函数再应用需计算的参数。
递归算法尾部递归
尾部递归是指递归函数在调用自身后直接传回其值，而不对其再加运算。尾部递归与循环是等价的，而且在一些语言（如Scheme中）可以被优化为循环指令。 因此，在这些语言中尾部递归不会占用调用堆栈空间。以下Scheme程序同样计算一个数字的阶乘，但是使用尾部递归：
[1]
(define (factorial n)  (define (iter product counter)    (if (> counter n)        product        (iter (* counter product)              (+ counter 1))))  (iter 1 1))
数据的定义是按递归定义的。如Fibonacci函数。
问题解法按递归算法实现。如Hanoi问题。
数据的结构形式是按递归定义的。如二叉树、广义表等。
[2]
数据类型可以通过递归来进行定义，比如一个简单的递归定义为自然数的定义：“一个自然数或等于0，或等于另一个自然数加上1”。Haskell中可以定义链表为：
data ListOfStrings = EmptyList | Cons String ListOfStrings
这一定义相当于宣告“一个链表或是空串列，或是一个链表之前加上一个字符串”。可以看出所有链表都可以通过这一递归定义来达到。
[3]
定义1，设P是集合，P上的二元关系“≤”满足以下三个条件，则称“≤”是P上的偏序关系（或部分序关系）：
（1）自反性：a≤a，∀a∈P；
（2）反对称性：∀a，b∈P，若a≤b且b≤a，则a=b；
（3）传递性：∀a，b，c∈P，若a≤b且b≤c，则a≤c；
具有偏序关系的集合P为偏序集（或称半序集），记为（P，≤）。a≤b读作“a小于或等于b”或“a含于b”，a<b读作“a小于b”或“a真含于b”。这里a<b等价于a≤b且a≠b，∀a，b∈P。若a≤b或b≤a，则称a与b是可比的，否则就说a与b是不可比。a与b不可比记作a||b。
定义2，设（P，≤）是偏序集，对于P中任意二元x，y有x≤y



 yRx，则称R是≤的逆关系，记作≤-1。≤-1称为≤的逆。
定理1，设（P，≤）是偏序集，则（P，≤-1）也是偏序集，偏序集（P，≤-1）称为偏序集（P，≤）的对偶，简记作P-1。
定义3，设（P，≤）是偏序集，N



P，由于关系≤是P×P的子集，令≤N=≤∩(N×N)是≤与N×N的交集，则称≤N是关系≤在N上的限制。
定理2，设（P，≤）是偏序集，关系≤N是≤在N上的限制，则（N，≤N）是偏序集，称为（P，≤）的子偏序集。
[2]
刻画偏序关系的一种示意图。即有限集A的偏序结构<A，R>的直观图示。图中用小圆圈表示集合A的元素。在a,b∈A，aRb时，从a有一条连续上升的不必笔直的线段或折线到达b。下面各图都可以看成集合的哈塞图。设R是集合A的偏序关系，则在偏序结构<A,R>的哈塞图中：
1、aRb，当且仅当a到b有一条或几条严格上升的线段或折线连结。a与b间无线连结，或虽有折线连结但在上下起伏的时候，



且



。如图1中



，



，



，



等（



为R的补关系）。

2、无水平的线段。
3、当R是全序时，哈塞图可画成一个上升的链状图，如图4。
4、同一个集合，当偏序关系不同时，有不同的哈塞图。例如，当A={2,3,4,6,8}时，关系R=“x不大于y”，G=“x整除y”时，R与G的哈塞图分别为图5与图6。

5、集合A的两个哈塞图相同，当且仅当通过变形可以把一个变成另一个，但是必须不改变图的连接并保持线段的上升方向。例如，图6、图7是同一个哈塞图。
6、把一个关系的哈塞图上下反转，得到它的逆关系的哈塞图，但左右翻转还是原关系的哈塞图。
哈塞（Hasse，H.）是第一个使用这种通俗的图来表示偏序。
[3]
图的一一个顶点子集称为独立集，如果该子集中的任意两个项点在图中不相邻。图 G 的最大独立集所包含顶点的个数称作 G 的独立数(independence number)记作 



。
[1]
在图论中，还有一个与独立集密切相关的概念——团。图的顶点子集称为团(clique)，如果该子集中的任意两个顶点在图中相邻。图 G 的最大团所包含顶点的个数称作 G 的团数(clique number)，记作 



。不难看出，一个图的团是其补图的独立集。因此，图的团数等于其补图的独立数，即 



。
任意有关图中团的性质都能很自然的转述成独立集的性质。一般而言，寻找图的最大团是 NP困难的,从而寻找图的最大独立集也是NP 困难的。但是，对于二部图的情形，有多项式时间算法找出图的最大独立集。
有个图有n个结点，y条边，任选图中一个顶点，把它染成黑色，则和它相连的顶点必须都被染成白色，但与被染成白色的顶点相连的顶点可以被染成白色也可以被染成黑色，问：这个图最多有多少个顶点能被染成黑色？
解：相当于求图的最大独立集。求一般图的最大独立集是NP hard。
具体程序实现可以通过求最小覆盖集来求最大独立集。
图G(V,E)的覆盖集D是顶点集的一个子集，并满足：任意 <vi,vj>属于E，vi属于D或vj属于D。
定义 *，+ 满足交换率，结合率，且 * 对 + 分配 (a+b)*c = a*c + b*c
吸收率：a+ab = a，a*a = a，a+a = a
这样，求极小覆盖集：
M(连乘)(v[i] + M(所有与v[i]相邻的点))，i=0 to n
结果化简后的每个因子项即对应一个极小覆盖集。
邻接矩阵（Adjacency Matrix）是表示顶点之间相邻关系的矩阵。设G=(V,E)是一个图，其中V={v1,v2,…,vn}
[1] 
。G的邻接矩阵是一个具有下列性质的n阶方阵：
①对无向图而言，邻接矩阵一定是对称的，而且主对角线一定为零（在此仅讨论无向简单图），副对角线不一定为0，有向图则不一定如此。
②在无向图中，任一顶点i的度为第i列（或第i行）所有非零元素的个数，在有向图中顶点i的出度为第i行所有非零元素的个数，而入度为第i列所有非零元素的个数。
③用邻接矩阵法表示图共需要n^2个空间，由于无向图的邻接矩阵一定具有对称关系，所以扣除对角线为零外，仅需要存储上三角形或下三角形的数据即可，因此仅需要n（n-1）/2个空间。
无向图的邻接矩阵一定是对称的，而有向图的邻接矩阵不一定对称。因此，用邻接矩阵来表示一个具有n个顶点的有向图时需要n^2个单元来存储邻接矩阵；对有n个顶点的无向图则只存入上（下）三角阵中剔除了左上右下对角线上的0元素后剩余的元素，故只需1+2+...+(n-1)=n(n-1)/2个单元。
无向图邻接矩阵的第i行（或第i列）非零元素的个数正好是第i个顶点的度。
有向图邻接矩阵中第i行非零元素的个数为第i个顶点的出度，第i列非零元素的个数为第i个顶点的入度，第i个顶点的度为第i行与第i列非零元素个数之和。
用邻接矩阵表示图，很容易确定图中任意两个顶点是否有边相连。
用一个顺序表来存储顶点信息
int i，j，k，w;
scanf("%d%d"，&G->n，&G->e); //输入顶点数和边数
for(i = 0;i < G->n;i++) //读入顶点信息，建立顶点表
{
    G->vexs[i]=getchar();
}
for(i = 0;i < G->n;i++)
{
    for(j = 0;j < G->n;j++)
    {
        G->edges[i][j] = 0; //邻接矩阵初始化
    }
}
for(k = 0;k < G->e;k++)
{//读入e条边，建立邻接矩阵
    scanf("%d%d%d"，&i，&j，&w); //输入边(v i ,v j )上的权w
    G->edges[i][j]=w;
}
}//CreateMGraph
在图的邻接矩阵表示法中：
① 用邻接矩阵表示顶点间的相邻关系
② 用一个顺序表来存储顶点信息
图的矩阵
设G=(V，E)是具有n个顶点的图，则G的邻接矩阵是具有如下性质的n阶方阵：

【例】
下图中无向图G 5 和有向图G 6 的邻接矩阵分别为A1 和A 2 。

网络矩阵
若G是网络，则邻接矩阵可定义为：
其中：
w ij 表示边上的权值;
∞表示一个计算机允许的、大于所有边上权值的数。
【例】下面带权图的两种邻接矩阵分别为A 3 和A 4 。

图的邻接矩阵存储结构形式说明
#define MaxVertexNum l00 //最大顶点数，应由用户定义
typedef char VertexType; //顶点类型应由用户定义
typedef int EdgeType; //边上的权值类型应由用户定义
typedef struct{
VextexType vexs[MaxVertexNum] //顶点表
EdeType edges[MaxVertexNum][MaxVertexNum];//邻接矩阵，可看作边表
int n，e; //图中当前的顶点数和边数
}MGragh;
注意：
① 在简单应用中，可直接用二维数组作为图的邻接矩阵(顶点表及顶点数等均可省略)。
② 当邻接矩阵中的元素仅表示相应的边是否存在时，EdgeTyPe可定义为值为0和1的枚举类型。
③无向图的邻接矩阵是对称矩阵，对规模特大的邻接矩阵可压缩存储。
④邻接矩阵表示法的空间复杂度S(n)=0(n 2 )。
⑤建立无向网络的算法。
void CreateMGraph(MGraph *G)
{//建立无向网的邻接矩阵表示
int i，j，k，w;
scanf("%d%d"，&G->n，&G->e); //输入顶点数和边数
for(i = 0;i < n;i++) //读入顶点信息，建立顶点表
{
G->vexs=getchar();
}
for(i = 0;i < G->n;i++)
{
for(j = 0;j <G->n;j++)
{
G->edges[i][j] = 0; //邻接矩阵初始化
}
}
for(k = 0;k < G->e;k++)
{//读入e条边，建立邻接矩阵
scanf("%d%d%d"，&i，&j，&w); //输入边(v i ,v j )上的权w
G->edges[i][j]=w;
G->edges[j][i]=w;
}
}//CreateMGraph
该算法的执行时间是0(n+n 2 +e)。由于e
根据图的定义可知，图的逻辑结构分为两部分：V和E的集合。因此，用一个一维数组存放图中所有顶点数据；用一个二维数组存放顶点间关系（边或弧）的数据，称这个二维数组为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵。
Matlab表达N=4;//图中的节点数目
dag=zeros(N,N);//邻接矩阵初始化，值均为0
C=1;S=2;R=3;
W=4;//制定各节点编号
dag(C,[RS])=1;//有两条有向边：C->R,C->S
dag(R,W)=1;//有向边：R->W
dag(S,W)=1;//有向边：S->W
入度引入
如果



则称 a 为从 u 到 v 的弧(arc)，u和 v 为 a 的端点，称 u 是 a 的尾(tail)，v 是 a 的头(head)。
入度定义
顶点 v 的入度是指以 v 为头的弧的数目；顶点v的出度(outdere) 是指以 v 为尾的弧的数目。
当入度为 0 时，指有向图中的点不作为任何边的终点，也就是说，这一点所连接的边都把这一点作为起点。
在有向图的拓扑排序中，每次都选取入度为 0 的点加入拓扑队列中，再删除与这一点连接的所有边。
定理1
无向图中所有顶点的度之和等于边数的 2 倍，有向图中所有顶点的入度之和等于所有顶点的出度之和。
定理2
任意一个无向图一定有偶数个（或0个）奇点（度为奇数的顶点）。
定理3
无论无向图还是有向图，顶点数 n ，边数 e 和度之间又如下关系：E=(d[v1]+d[v2]+…+d[vn])/2。
[directed graph,digraph]
有向图 D 是指一个有序三元组 (V(D),A(D),ψD) ，其中 V(D) 是非空的顶点集， A(D) 是与 V(D) 不交的弧集， ψD是关联函数，它使 D 的每条弧对应于 D 的一个有序顶点对(不必相异)。
对应于每个有向图 D，可以在相同顶点集上构造一个新图 G，使得对于 D 的每条弧，G 有一条相同端点的边与之对应。这样的图 G 称为有向图 D 的基础图(underlying graph)，换言之，将 D 中所有边的方向去掉所得到的无向图即为 D 的基础图。
反之，对应于每个无向图G ，可以在相同顶点集上构造有向图 D ，只需把 G 中的每条边换成与该边具有相同端点，但方向相反的两条弧，由此得到的有向图称为 G 的伴随有向图(associated digraph)。特别地，完全图的伴随有向图称为完全有向图(complete digraph)。
给无向图 G 中的每条边一个方向，由此得到的有向图称为 G 的一个定向 (orientation)。特别地，简单图的定向称为定向图 (oriented graph)，完全图的定向称为竞赛图 (tournament)。
[1]
动态规划一般可分为线性动规，区域动规，树形动规，背包动规四类。
[2]
举例：
[1]
线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；
[4]
区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；
[4]
树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；
[4]
背包问题：01背包问题，完全背包问题，分组背包问题，二维背包，装箱问题，挤牛奶（同济ACM第1132题）等；
[4]
应用实例：
[3]
最短路径问题 ，项目管理，网络流优化等；
[3]
POJ动态规划题目列表：
[3]
容易：
[3]
1018,1050,1083,1088,1125,1143,1157,1163,1178,1179,1189,1191,1208,1276,1322,1414,1456,1458,1609,1644,1664,1690,1699,1740,1742,1887,1926,1936,1952,1953,1958,1959,1962,1975,1989,2018,2029,2039,2063,2081,2082,2181,2184,2192,2231,2279,2329,2336,2346,2353,2355,2356,2385,2392,2424。
不易：
[3]
1019,1037,1080,1112,1141,1170,1192,1239,1655,1695,1707,1733(区间减法加并查集),1737,1837,1850,1920(加强版汉罗塔),1934(全部最长公共子序列),1964(最大矩形面积，O(n*m)算法),2138,2151,2161,2178。
推荐：
[3]
1015,1635,1636,1671,1682,1692,1704,1717,1722,1726,1732,1770,1821,1853,1949,2019,2127,2176,2228,2287,2342,2374,2378,2384,2411。
动态规划问世以来，在经济管理、生产调度、工程技术和最优控制等方面得到了广泛的应用。例如最短路线、库存管理、资源分配、设备更新、排序、装载等问题，用动态规划方法比用其它方法求解更为方便。
[4]
虽然动态规划主要用于求解以时间划分阶段的动态过程的优化问题，但是一些与时间无关的静态规划(如线性规划、非线性规划)，只要人为地引进时间因素，把它视为多阶段决策过程，也可以用动态规划方法方便地求解。
[4]
动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。不像搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。
[4] 
因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。我们也可以通过对若干有代表性的问题的动态规划算法进行分析、讨论，逐渐学会并掌握这一设计方法。
[4]
动态规划概念引入
多阶段决策过程的最优化问题。
[1]
含有递推的思想以及各种数学原理（加法原理，乘法原理等等）。
[4]
在现实生活中，有一类活动的过程，由于它的特殊性，可将过程分成若干个互相联系的阶段，在它的每一阶段都需要作出决策，从而使整个过程达到最好的活动效果。
[2] 
当然，各个阶段决策的选取不是任意确定的，它依赖于当前面临的状态，又影响以后的发展，当各个阶段决策确定后，就组成一个决策序列，因而也就确定了整个过程的一条活动路线，如图所示：（看词条图）




多阶段决策问题

这种把一个问题看作是一个前后关联具有链状结构的多阶段过程就称为多阶段决策过程，这种问题就称为多阶段决策问题。
[1]
动态规划基本思想
动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。
[2] 
动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。
[1]
动态规划基本概念
1. 多阶段决策问题
如果一类活动过程可以分为若干个互相联系的阶段，在每一个阶段都需作出决策(采取措施)，一个阶段的决策确定以后，常常影响到下一个阶段的决策，从而就完全确定了一个过程的活动路线，则称它为多阶段决策问题。
[1]
各个阶段的决策构成一个决策序列，称为一个策略。每一个阶段都有若干个决策可供选择，因而就有许多策略供我们选取，对应于一个策略可以确定活动的效果，这个效果可以用数量来确定。策略不同，效果也不同，多阶段决策问题，就是要在可以选择的那些策略中间，选取一个最优策略，使在预定的标准下达到最好的效果。
[4]
2．动态规划问题中的术语
阶段：把所给求解问题的过程恰当地分成若干个相互联系的阶段，以便于求解，过程不同，阶段数就可能不同．描述阶段的变量称为阶段变量。在多数情况下，阶段变量是离散的，用k表示。此外，也有阶段变量是连续的情形。如果过程可以在任何时刻作出决策，且在任意两个不同的时刻之间允许有无穷多个决策时，阶段变量就是连续的。
[3]
在前面的例子中，第一个阶段就是点A，而第二个阶段就是点A到点B，第三个阶段是点B到点C，而第四个阶段是点C到点D。
[1]
状态：状态表示每个阶段开始面临的自然状况或客观条件，它不以人们的主观意志为转移，也称为不可控因素。在上面的例子中状态就是某阶段的出发位置，它既是该阶段某路的起点，同时又是前一阶段某支路的终点。




不可控因素

在前面的例子中，第一个阶段有一个状态即A，而第二个阶段有两个状态B1和B2，第三个阶段是三个状态C1，C2和C3，而第四个阶段又是一个状态D。
[4]
过程的状态通常可以用一个或一组数来描述，称为状态变量。一般，状态是离散的，但有时为了方便也将状态取成连续的。当然，在现实生活中，由于变量形式的限制，所有的状态都是离散的，但从分析的观点，有时将状态作为连续的处理将会有很大的好处。
[4] 
此外，状态可以有多个分量(多维情形)，因而用向量来代表；而且在每个阶段的状态维数可以不同。




状态变量

当过程按所有可能不同的方式发展时，过程各段的状态变量将在某一确定的范围内取值。状态变量取值的集合称为状态集合。
[3]
无后效性：我们要求状态具有下面的性质：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响，所有各阶段都确定时，整个过程也就确定了。
[3] 
换句话说，过程的每一次实现可以用一个状态序列表示，在前面的例子中每阶段的状态是该线路的始点，确定了这些点的序列，整个线路也就完全确定。从某一阶段以后的线路开始，当这




无后效性

段的始点给定时，不受以前线路（所通过的点）的影响。状态的这个性质意味着过程的历史只能通过当前的状态去影响它的未来的发展，这个性质称为无后效性。
[4]
决策：一个阶段的状态给定以后，从该状态演变到下一阶段某个状态的一种选择（行动）称为决策。在最优控制中，也称为控制。在许多问题中，决策可以自然而然地表示为一个数或一组数。
[3] 
不同的决策对应着不同的数值。描述决策的变量称决策变量，因状态满足无后效性，故在每个阶段选择决策时只需考虑当前的状态而无须考虑过程的历史。
[1]
决策变量的范围称为允许决策集合。




允许决策集合

策略：由每个阶段的决策组成的序列称为策略。对于每一个实际的多阶段决策过程，可供选取的策略有一定的范围限制，这个范围称为允许策略集合。
最优策略(2张)



允许策略集合中达到最优效果的策略称为最优策略。
[3]
给定k阶段状态变量x(k)的值后，如果这一阶段的决策变量一经确定，第k+1阶段的状态变量x(k+1)也就完全确定，即x(k+1)的值随x(k)和第k阶段的决策u(k)的值变化而变化，那么可以把这一关系看成(x(k)，u(k))与x(k+1)确定的对应关系，用x(k+1)=Tk(x(k),u(k))表示。这是从k阶段到k+1阶段




状态转移方程

的状态转移规律，称为状态转移方程。
[3] 
最优化原理:作为整个过程的最优策略，它满足：相对前面决策所形成的状态而言，余下的子策略必然构成“最优子策略”。一个问题满足最优化原理也称其拥有最优子结构性质。最优性原理实际上是要求问题的最优策略的子策略也是最优。让我们通过对前面的例子再分析来具体说明这一点：从A到D，我们知道，最短路径是AB1C2D，这些点的选择构成了这个例子的最优策略，根据最优性原理，这个策略的每个子策略应是最优：
[1]
最优化原理

AB1C2是A到C2的最短路径，B1C2D也是B1到D的最短路径……──事实正是如此，因此我们认为这个例子满足最优性原理的要求。
[2]
动态规划基本结构
多阶段决策问题中，各个阶段采取的决策，一般来说是与时间有关的，决策依赖于当前状态，又随即引起状态的转移，一个决策序列就是在变化的状态中产生出来的，故有“动态”的含义，称这种解决多阶段决策最优化问题的方法为动态规划方法。
[2]
动态规划基本模型
根据上例分析和动态规划的基本概念，可以得到动态规划的基本模型如下：
[2]
(1)确定问题的决策对象。 (2)对决策过程划分阶段。 (3)对各阶段确定状态变量。 (4)根据状态变量确定费用函数和目标函数。 (5)建立各阶段状态变量的转移过程，确定状态转移方程。
[1]
状态转移方程的一般形式：
[4]
一般形式： U：状态； X：策略
[2]
顺推：f[Uk]=opt{f[Uk-1]+L[Uk-1,Xk-1]} 其中， L[Uk-1,Xk-1]： 状态Uk-1通过策略Xk-1到达状态Uk 的费用 初始f[U1]；结果：f[Un]。
[4]
倒推：　　f[Uk]=opt{f[Uk+1]+L[Uk,Xk]}
[4]
L[Uk,Xk]： 状态Uk通过策略Xk到达状态Uk+1 的费用
[1]
初始f[Un]；结果：f(U1)
[4]
动态规划适用条件
任何思想方法都有一定的局限性，超出了特定条件，它就失去了作用。同样，动态规划也并不是万能的。适用动态规划的问题必须满足最优化原理和无后效性。
[1]
1.最优化原理（最优子结构性质） 最优化原理可这样阐述：一个最优化策略具有这样的性质，不论过去状态和决策如何，对前面的决策所形成的状态而言，余下的诸决策必须构成最优策略。简而言之，一个最优化策略的子策略总是最优的。一个问题满足最优化原理又称其具有最优子结构性质。
[3]
2.无后效性将各阶段按照一定的次序排列好之后，对于某个给定的阶段状态，它以前各阶段的状态无法直接影响它未来的决策，而只能通过当前的这个状态。换句话说，每个状态都是过去历史的一个完整总结。这就是无后向性，又称为无后效性。
[1]
3.子问题的重叠性 动态规划将原来具有指数级时间复杂度的搜索算法改进成了具有多项式时间复杂度的算法。其中的关键在于解决冗余，这是动态规划算法的根本目的。动态规划实质上是一种以空间换时间的技术，它在实现的过程中，不得不存储产生过程中的各种状态，所以它的空间复杂度要大于其它的算法。
[2]
算法实现是比较好考虑的。但有时也会遇到一些问题，而使算法难以实现。
[3] 
动态规划思想设计的算法从整体上来看基本都是按照得出的递推关系式进行递推，这种递推相对于计算机来说，只要设计得当，效率往往是比较高的，这样在时间上溢出的可能性不大，而相反地，动态规划需要很大的空间以存储中间产生的结果，这样可以使包含同一个子问题的所有问题共用一个子问题解，从而体现动态规划的优越性，但这是以牺牲空间为代价的，为了有效地访问已有结果，数据也不易压缩存储，因而空间矛盾是比较突出的。另一方面，动态规划的高时效性往往要通过大的测试数据体现出来（以与搜索作比较），因而，对于大规模的问题如何在基本不影响运行速度的条件下，解决空间溢出的问题，是动态规划解决问题时一个普遍会遇到的问题。
[3]
一个思考方向是尽可能少占用空间。如从结点的数据结构上考虑，仅仅存储必不可少的内容，以及数据存储范围上精打细算(按位存储、压缩存储等)。当然这要因问题而异，进行分析。另外，在实现动态规划时，一个我们经常采用的方法是用一个与结点数一样多的数组来存储每一步的决策，这对于倒推求得一种实现最优解的方法是十分方便的，而且处理速度也有一些提高。
[1] 
但是在内存空间紧张的情况下，我们就应该抓住问题的主要矛盾。省去这个存储决策的数组，而改成在从最优解逐级倒推时，再计算一次，选择某个可能达到这个值的上一阶段的状态，直到推出结果为止。这样做，在程序编写上比上一种做法稍微多花一点时间，运行的时效也可能会有一些(但往往很小)的下降，但却换来了很多的空间。因而这种思想在处理某些问题时，是很有意义的。
[2]
但有时，即使采用这样的方法也会发现空间溢出的问题。这时就要分析，这些保留下来的数据是否有必要同时存在于内存之中。
[4] 
因为有很多问题，动态规划递推在处理后面的内容时，前面比较远处的内容实际上是用不着的。对于这类问题，在已经确信不会再被使用的数据上覆盖数据，从而使空间得以重复利用，如果能有效地使用这一手段，对于相当大规模的问题，空间也不至于溢出（为了求出最优方案，保留每一步的决策仍是必要的，这同样需要空间）。
[4]
一般地说，这种方法可以通过两种思路来实现：一种是递推结果仅使用Data1和Data2这样两个数组，每次将Data1作为上一阶段，推得Data2数组，然后，将Data2通过复制覆盖到Data1之上，如此反复，即可推得最终结果。这种做法有一个局限性，就是对于递推与前面若干阶段相关的问题，这种做法就比较麻烦；而且，每递推一级，就需要复制很多的内容，与前面多个阶段相关的问题影响更大。
[3] 
另外一种实现方法是，对于一个可能与前N个阶段相关的问题，建立数组Data[0..N]，其中各项为前面N个阶段的保存数据。这样不采用这种内存节约方式时对于阶段k的访问只要对应成对数组Data中下标为k mod (N+1)的单元的访问就可以了。这种处理方法对于程序修改的代码很少，速度几乎不受影响，而且需要保留不同的阶段数也都能很容易实现。
[4]
当采用以上方法仍无法解决内存问题时，也可以采用对内存的动态申请来使绝大多数情况能有效出解。而且，使用动态内存还有一点好处，就是在重复使用内存而进行交换时，可以只对指针进行交换，而不复制数据，这在实践中也是十分有效的。
[3]
动态规划常用软件
MATLAB、LINGO
[4]
动态规划作用
在编程中常用解决最长公共子序列问题、矩阵连乘问题、凸多边形最优三角剖分问题、电路布线等问题。
[4]
动态规划搜索
记忆化
[4]
给你一个数字三角形, 形式如下:
[1]
1
2 3
4 5 6
7 8 9 10
找出从第一层到最后一层的一条路,使得所经过的权值之和最小或者最大。
[4]
无论对于新手还是老手，这都是再熟悉不过的题了，很容易地，我们写出状态转移方程：
[4]
f[i][j]=a[i][j] + min{f[i+1][j]，f[i+1][j+1]}(a[i][j]表示当前状态,f[i][j]表示指标函数)
[1]
对于动态规划算法解决这个问题，我们根据状态转移方程和状态转移方向，比较容易地写出动态规划的循环表示方法。但是，当状态和转移非常复杂的时候，也许写出循环式的动态规划就不是那么简单了。
[4]
解决方法：
[1]
我们尝试从正面的思路去分析问题，如上例，不难得出一个非常简单的递归函数:
[2]
int f(int i, int j, int (*a)[4])
{
    int f1, f2, tmp=0, k;
    if(i==0||j==0)
    return a[0][0];
    if(j==i)
    {
        for(k=0;k<=i;k++)
        tmp+=a[k][k];
        return tmp;
    }
    f1=f(i-1, j, a);
    f2=f(i-1, j-1, a);
    if(f1<f2)
        return f2+a[i][j];
    else
        return f1+a[i][j];
}
显而易见，这个算法就是最简单的搜索算法。时间复杂度为2n，明显是会超时的。分析一下搜索的过程，实际上，很多调用都是不必要的，也就是把产生过的最优状态，又产生了一次。
[4] 
为了避免浪费，很显然，我们存放一个opt数组：Opt[i, j] - 每产生一个f(i, j)，将f(i, j)的值放入opt中，以后再次调用到f(i, j)的时候，直接从opt[i, j]来取就可以了。于是动态规划的状态转移方程被直观地表示出来了，这样节省了思维的难度，减少了编程的技巧，而运行时间只是相差常数的复杂度，避免了动态规划状态转移先后的问题，而且在相当多的情况下，递归算法能更好地避免浪费，在比赛中是非常实用的。
[2]
并且记忆搜索占的内存相对来说较少。
[3]
计算核心片段：
[4]
for(inti=n-1;i>=1;--i)//从倒数第二行开始
{
    for(intj=1;j<=i;j++)
    {
        if(a[i+1][j][1]>a[i+1][j+1][1])//左边大
    {
        a[i][j][2]=0;//选择左边
        a[i][j][1]+=a[i+1][j][1];
    }
    else//右边大
    {
        a[i][j][2]=1;//选择右边
        a[i][j][1]+=a[i+1][j+1][1];
    }
练习题
[1]
USACO2.2 Subset Sums
题目如下：
[1]
对于从1到N的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。
[1]
举个例子，如果N=3，对于{1，2，3}能划分成两个子集合，他们每个的所有数字和是相等的：
[1]
{3}and {1,2}
这是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）
[1]
如果N=7，有四种方法能划分集合{1，2，3，4，5，6，7}，每一种分发的子集合各数字和是相等的:
[1]
{1,6,7} and {2,3,4,5} {注 1+6+7=2+3+4+5}
{2,5,7} and {1,3,4,6}
{3,4,7} and {1,2,5,6}
{1,2,4,7} and {3,5,6}
给出N，你的程序应该输出划分方案总数，如果不存在这样的划分方案，则输出0。程序不能预存结果直接输出。
[4]
PROGRAM NAME: subset
INPUT FORMAT
输入文件只有一行，且只有一个整数N
[4]
SAMPLE INPUT (file subset . in)
7
OUTPUT FORMAT
输出划分方案总数，如果不存在则输出0。
[4]
SAMPLE OUTPUT (file subset.out)
4
参考程序如下（C++语言）：
#include<fstream>
usingnamespacestd;
constunsignedintMAX_SUM=1024;
intn;
unsignedlonglongintdyn[MAX_SUM];
ifstreamfin("subset.in");
ofstreamfout("subset.out");
intmain(){
fin>>n;
fin.close();
ints=n*(n+1);
if(s%4){
fout<<0<<endl;
fout.close();
return0;
}
s/=4;
inti,j;
dyn[0]=1;
for(i=1;i<=n;i++)
for(j=s;j>=i;j--)
if(j-i>0){
dyn[j]+=dyn[j-i];
}
fout<<(dyn[s]/2)<<endl;
fout.close();
return0;
}
USACO2.3LongestPrefix
题目如下：
[4]
在生物学中，一些生物的结构是用包含其要素的大写字母序列来表示的。生物学家对于把长的序列分解成较短的（称之为元素的）序列很感兴趣。
[4]
如果一个集合 P 中的元素可以通过并运算（允许重复；并，即∪，相当于 Pascal 中的 “+” 运算符）组成一个序列 S ，那么我们认为序列 S 可以分解为 P 中的元素。并不是所有的元素都必须出现。举个例子，序列 ABABACABAAB 可以分解为下面集合中的元素：
[4]
{A, AB, BA, CA, BBC}
序列 S 的前面 K 个字符称作 S 中长度为 K 的前缀。设计一个程序，输入一个元素集合以及一个大写字母序列，计算这个序列最长的前缀的长度。
[4]
PROGRAM NAME: prefix
INPUT FORMAT
输入数据的开头包括 1..200 个元素（长度为 1..10 ）组成的集合，用连续的以空格分开的字符串表示。字母全部是大写，数据可能不止一行。元素集合结束的标志是一个只包含一个 “.” 的行。集合中的元素没有重复。接着是大写字母序列 S ，长度为 1..200,000 ，用一行或者多行的字符串来表示，每行不超过 76 个字符。换行符并不是序列 S 的一部分。
[4]
SAMPLE INPUT (file prefix. in)
A AB BA CA BBC
.
ABABACABAABC
OUTPUT FORMAT
只有一行，输出一个整数，表示 S 能够分解成 P 中元素的最长前缀的长度。
[4]
SAMPLE OUTPUT (file prefix.out)
11
示例程序如下：
[1]
#include <stdio.h>
#define MAXP 200
#define MAXL 10
char prim[MAXP+1][MAXL+1];
int nump;
int start[200001];
char data[200000];
int ndata;
int main(int argc, char **argv)
{
FILE *fout, *fin;
int best;
int lv,lv2, lv3;
if ((fin = fopen("prim. in", "r")) == NULL)
{
perror ("fopen fin");
exit(1);
}
if((fout = fopen("prim.out", "w")) == NULL)
{
perror ("fopen fout");
exit(1);
}
while (1)
{
fscanf (fin, "%s", prim[nump]);
if (prim[nump][0] != '.')
nump++;
else
break;
}
ndata = 0;
while (fscanf (fin, "%s", data+ndata) == 1)
ndata += strlen(data+ndata);
start[0] = 1;
best = 0;
for (lv = 0; lv < ndata; lv++)
if (start[lv])
{
best = lv;
for (lv2 = 0; lv2 < nump; lv2++)
{
for (lv3 = 0; lv + lv3 < ndata && prim[lv2][lv3] == data[lv+lv3]; lv3++)
if (!prim[lv2][lv3])
start[lv + lv3] = 1;
}
}
if (start[ndata])
best = ndata;
fprintf (fout, "%i\n", best);
return 0;
}
动态规划作为一种重要的信息学竞赛算法，具有很强的灵活性。以上提供的是一些入门练习题，深入的学习还需要逐步积累经验。
[1]
解决0-1背包问题时使用动态规划的实现（c++）
[1]
#include <stdio.h>
typedef struct Object{
int weight;
int value; // float rate;
}
Object;
Object * array; //用来存储物体信息的数组
int num; //物体的个数
int container; //背包的容量
int ** dynamic_table; //存储动态规划表
bool * used_table; //存储物品的使用情况
//ouput the table of dynamic programming, it's for detection
void print_dynamic_table(){
printf("动态规划表如下所示:\n");
/* for(int j=0; j<=container; j++) printf("%d ",j); printf("\n");*/
for(int i=1; i<=num; i++) {
for(int j=0; j<=container; j++)
printf("%d ",dynamic_table[i][j]);
printf("\n");
}
}
//打印动态规划表
void print_array(){
for(int i=1; i<=num; i++)
printf("第%d个物品的重量和权重:%d %d\n",i,array[i].weight,array[i].value);
}
//打印输入的物品情况//插入排序，按rate=value/weight由小到大排//动态规划考虑了所有情况，所以可以不用排序
/*void sort_by_rate(){
for(int i=2; i<=num; i++) {
Object temp=array[i];
for(int j=i-1; j>=1; j--)
if(array[j].rate>temp.rate)
array[j+1]=array[j];
else break;
array[j+1]=temp;
}}*/
void print_used_object(){
printf("所使用的物品如下所示:\n");
for(int i=1; i<=num; i++)
if(used_table[i]==1)
printf("%d-%d\n", array[i].weight, array[i].value);
}
//打印物品的使用情况
/* 做测试时使用
void print_used_table(bool * used_table){
printf("used table as follows:\n");
for(int i=1; i<=num; i++)
printf("object %d is %d", i, used_table[i]);
}*/
void init_problem(){
printf("输入背包的容量:\n");
scanf("%d", &container);
printf("输入物品的个数:\n");
scanf("%d", &num);
array=new Object[num+1];
printf("输入物品的重量和价值, 格式如：4-15\n");
for(int i=1; i<=num; i++) {
char c;
scanf("%d%c%d", &array[i].weight, &c, &array[i].value);
// array[i].rate=array[i].value/array[i].weight;
}
print_array();
}
//对物体的使用情况进行回查
void trace_back(){
int weight=container;
used_table=new bool[num+1];
for(int i=1; i<=num; i++) used_table[i]=0;
//initalize the used_table to be non-used
for(int j=1; j<num; j++) {
//说明物品j被使用
if(dynamic_table[j][weight]!=dynamic_table[j+1][weight]) {
weight-=array[j].weight;
used_table[j]=1;
}
// print_used_table(used_table);
}
//检测第num个物品是否被使用
if(weight>=array[num].weight)
used_table[num]=1;
}
void dynamic_programming(){
dynamic_table=new int * [num+1];
for(int k=1; k<=num; k++)
dynamic_table[k]=new int[container+1];
//dynamic_programming table
//为二维动态规划表分配内存
for(int m=1; m<num; m++)
for(int n=0; n<=container; n++)
dynamic_table[m][n]=0;
int temp_weight=array[num].weight;
for(int i=0; i<=container; i++)
dynamic_table[num][i]=i<temp_weight?0:array[num].value;
//初始化动态规划表
for(int j=num-1; j>=1; j--) {
temp_weight=array[j].weight;
int temp_value=array[j].value;
for(int k=0; k<=container; k++)
if(k>=temp_weight && dynamic_table[j+1][k] < dynamic_table[j+1][k-temp_weight]+temp_value)
dynamic_table[j][k]=dynamic_table[j+1][k-temp_weight]+temp_value;
else dynamic_table[j][k]=dynamic_table[j+1][k];
}//构建动态规划表
print_dynamic_table();//打印动态规划表
}
void main(){
init_problem();
dynamic_programming();
trace_back();
print_used_object();
}
《Dynamic Programming》
ISBN：3540370137
【出版日期】 2005 年7月
1.构造函数的命名必须和类名完全相同。在java中普通函数可以和构造函数同名，但是必须带有返回值；
2.构造函数的功能主要用于在类的对象创建时定义初始化的状态。它没有返回值，也不能用void来修饰。这就保证了它不仅什么也不用自动返回，而且根本不能有任何选择。而其他方法都有返回值，即使是void返回值。尽管方法体本身不会自动返回什么，但仍然可以让它返回一些东西，而这些东西可能是不安全的；
3.构造函数不能被直接调用，必须通过new运算符在创建对象时才会自动调用；而一般的方法是在程序执行到它的时候被调用的；
4.当定义一个类的时候，通常情况下都会显示该类的构造函数，并在函数中指定初始化的工作也可省略，不过Java编译器会提供一个默认的构造函数.此默认构造函数是不带参数的。而一般的方法不存在这一特点；
5.构造函数有回滚的效果，构造函数抛出异常时，构造的是一个不完整对象，会回滚，将此不完整对象的成员释放(c++)
6.当一个类只定义了私有的构造函数，将无法通过new关键字来创建其对象，当一个类没有定义任何构造函数，C#编译器会为其自动生成一个默认的无参的构造函数。
7.在Python中构造函数必须通过重写__init__方法实现
C++构造函数
C++语言为类提供的构造函数可自动完成对象的初始化任务，全局对象和静态对象的构造函数在main()函数执行之前就被调用，局部静态对象的构造函数是当程序第一次执行到相应语句时才被调用。然而给出一个外部对象的引用性声明时，并不调用相应的构造函数，因为这个外部对象只是引用在其他地方声明的对象，并没有真正地创建一个对象。
C++的构造函数定义格式为：
class <类名>
{
public:
<类名>(参数表);
//...(还可以声明其它成员函数)
};
<类名>::<函数名>(参数表)
{
//函数体
}
如以下定义是合法的：
class T
{
public:
T(int a=0){ i=a; }//构造函数允许直接写在类定义内，也允许有参数表。
private:
int i;
};
如果一个类中没有定义任何的构造函数，那么编译器只有在以下三种情况，才会提供默认的构造函数：
1、如果类有虚拟成员函数或者虚拟继承父类（即有虚拟基类）时；
2、如果类的基类有构造函数（可以是用户定义的构造函数，或编译器提供的默认构造函数）；
3、在类中的所有非静态的对象数据成员，它们对应的类中有构造函数（可以是用户定义的构造函数，或编译器提供的默认构造函数）。
<类名>::<类名>(){}，即不执行任何操作。
例子
#include <iostream>
using namespace std;
class time
{
public:
    time()//constructor.构造函数
    {
        hour=0;
        minute=0;
        sec=0;
    }
    void set_time();
    void show_time();
private:
    int hour, minute, sec;
};
int main()
{
    class time t1;
    t1.show_time();
    t1.set_time();
    t1.show_time();
    return 0;
}
void time::set_time()
{
    cin>>hour>>minute>>sec;
}
void time::show_time()
{
    cout<<hour<<":"<<minute<<":"<<sec<<endl;
}
程序运行情况：
0：0：0
10 11 11 回车
10：11：11
任何时候，只要创建类或结构，就会调用它的构造函数。类或结构可能有多个接受不同参数的构造函数。构造函数使得程序员可设置默认值、限制实例化以及编写灵活且便于阅读的代码。
PHP的构造函数
void__construct( [mixed args [, ...]] )
php 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。
注:如果子类中定义了构造函数则不会暗中调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用parent::__construct()。
例子 使用新标准的构造函数
<?php
classBaseClass{
function__construct(){
print"InBaseClassconstructor/n";}}
classSubClassextendsBaseClass{
function__construct(){
parent::__construct();print"InSubClassconstructor/n";}}
$obj=newBaseClass();$obj=newSubClass();
?>
为了实现向后兼容性，如果 php 5 在类中找不到__construct()函数，它就会尝试寻找旧式的构造函数，也就是和类同名的函数。因此唯一会产生兼容性问题的情况是：类中已有一个名为__construct()的方法，但它却又不是构造函数。
Python的构造函数
定义格式为
class <类名>:
__init__(self [,参数表]):
#函数体
#其它的方法和属性
1.它的函数名与类名相同；
2.它可以重载；
3.不能指定返回类型，即使是void也不行；
4.虽然在一般情况下，构造函数不被显式调用，而是在创建对象时自动被调用。但是并不是不能被显式调用。有些时候是一定要显式调用的，只要是父类有带参的构造函数，在子类中就必须显式的调用父类的构造函数，因为子类的构造器在实例化时无法找到父类的构造函数（当父类有自己写的无参构造函数时，子类也不用显式调用）。
void__destruct( void )
php 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引。
Java, C++, C#, ActionScript和PHP 4中的命名规范会要求构造器函数的名称与它所在类的名称相同。
PHP 5 建议的构造器函数名称为__construct。为了保证向下兼容，__construct方法无法找到时会调用任何跟类名同名的方法作为构造器。从 PHP 5.3.3 起，这种途径只对非名字空间的类有效。
在Perl里，构造器被约定俗成地命名为"new"，并且会完成创建对象的大量工作。
在 Perl 的 Moose 对象系统中，构造函数（叫做 new）是自动生成的，程序员可以通过指定一个 BUILD 方法来对其进行扩充。
在 Visual Basic .NET里，构造器被命名为New，是个 Sub。
Python里构造器的被分为 __new__ 和 __init__ 两个方法。__new__方法负责为实例分配内储存空间，并接受自身的类作为参数（一般命名为 cls）。__init__方法接受被新建的实例作为参数（一般称为 self）。
Object Pascal 的构造函数用关键字 constructor 标识，并且可以起任意名字（但一般来说会被起名为 Create）。
Objective-C 的构造函数分成两个方法，alloc 和 init。alloc 方法分配内存，init 负责初始化。new 方法会调用 alloc 和 init 两者。
在 Java, C# 和 VB .NET 里，构造器会在一种叫做堆的特殊数据结构里创建作为引用类型的实例。值类型（例如 int, double 等等）则会创建在叫做栈的有序数据结构里。VB .NET and C# 会允许用new来创建值类型的实例。然而在这些语言里，即使使用这种方法创建的对象依然只会在栈里。
在 C++ 里，不用 new 创建的对象会保存在栈里，使用 new 创建时则会在堆里。它们必须分别使用析构函数或者delete操作才能被删除。
构造函数Java
在Java里，构造器和其他方法的主要差别在于：
构造器不具有任何显性返回类型。
构造器无法被直接“new” invokes them).
构造器无法被标示为synchronized, final, abstract, native, 或者static。
Java 里的构造器会按照以下顺序完成下列工作：
将类变量初始到缺省值。（byte, short, int, long, float, 和 double 变量会默认设为它们相应的0值，booleans 会被设为 false, chars 会被设为空字符('\u0000')，对象引用会被设为 null）
引用父类的构造器，如果没有定义任何构造器。
将实例变量初始化到指定值。
执行构造器内的代码。
在 Java 中可以通过关键词super访问父类的构造器。
public class Example{    // Definition of the constructor.    public Example()    {        this(1);    }    // Overloading a constructor    public Example(int input)    {        data = input; // This is an assignment    }    // Declaration of instance variable(s).    private int data;}
// Code somewhere else
// Instantiating an object with the above constructor
Example e = new Example(42);
不接收任何参数的构造器被称作“无参数构造器”。
构造函数Visual Basic .NET
在Visual Basic .NET中, 构造函数以"New"为定义方法，并且必须是个 Sub。
Class Foobar    Private strData As String    ' Constructor    Public Sub New(ByVal someParam As String)        strData = someParam    End SubEnd Class
' code somewhere else
' instantiating an object with the above constructor
Dim foo As New Foobar(".NET")
构造函数C#
public class MyClass{    private int a;    private string b;    // Constructor    public MyClass() : this(42, "string")    {    }    // Overloading a constructor    public MyClass(int a, string b)    {        this.a = a;        this.b = b;    }}
// Code somewhere
// Instantiating an object with the constructor above
MyClass c = new MyClass(42, "string");
C# 静态构造函数
在C#中,静态构造函数是用来初始化任何静态数据。静态构造函数也称为“类构造函数”，由于类构造函数在生成的 MSIL 里名为“.cctor”，因此也被称为“cctor”。
静态构造函数允许复杂的静态变量初始化。
静态构造函数在该类第一次被访问时调用，任何使用该类的操作（无论是调用静态函数、属性还是访问静态变量，还是构造类的实例）都会引发静态构造函数的执行。静态构造函数是线程安全的，并且是单例的。当用在泛型类中时，静态构造函数对于泛型的每个实例化都调用一次。静态变量也同样如此。
public class MyClass{    private static int _A;    // Normal constructor    static MyClass()    {        _A = 32;    }    // Standard default constructor    public MyClass()    {    }}// Code somewhere
// Instantiating an object with the constructor above
// right before the instantiation
// The variable static constructor is executed and _A is 32
MyClass c = new MyClass();
构造函数C++
C++ 的构造函数以该类的类名为标识，且不写返回值类型也无法返回值
[1] 
：
class C{public:  C(void){    ...  }};
构造函数的函数体执行是在各个成员构造完之后才开始，因此要想更改成员的构造方式需要使用成员初始化列表：
class D: public B{public:  D(void): B("Hello, world!"){    ...  }};
复制构造函数接受同类对象的左值引用（一般为 const T &）、移动构造函数接受右值引用（一般为 T&&）：
class E{public:  E(const E &e){...}//Copy constructor  E(E &&e){...}//Move constructor};
C++ 中，程序员若未对某类定义构造函数（以及赋值函数、析构函数），编译器在满足条件时会定义相应的函数。
构造函数Ruby
irb(main):001:0> class Example
Classirb(main):002:1>   def initialize
irb(main):003:2>     puts "Hello there"
irb(main):004:2>   end
irb(main):005:1> end=> nil
irb(main):006:0> ExampleClass.new
Hello there
=> #<ExampleClass:0x007fb3f4299118>
对一个图G= (V,E)中的两点x和y，若存在交替的顶点和边的序列



（在有向图中要求有向边



属于E），则两点 x和y是连通的。



是一条x到y的连通路径，x和y分别是起点和终点。当x=y时，



被称为回路。如果通路



中的边两两不同，则



是一条简单通路，否则为一条复杂通路。如果图G中每两点间皆连通，则G是连通图。
连通分量：无向图 G的一个极大连通子图称为 G的一个连通分量（或连通分支）。连通图只有一个连通分量，即其自身；非连通的无向图有多个连通分量。
强连通图：有向图 G=(V,E) 中，若对于V中任意两个不同的顶点 x和 y，都存在从x到 y以及从 y到 x的路径，则称 G是强连通图。相应地有强连通分量的概念。强连通图只有一个强连通分量，即是其自身；非强连通的有向图有多个强连分量。
单向连通图：设G=<V,E>是有向图，如果u->v意味着图G至多包含一条从u到v的简单路径，则图G为单连通图。
弱连通图：将有向图的所有的有向边替换为无向边，所得到的图称为原图的基图。如果一个有向图的基图是连通图，则有向图是弱连通图。
初级通路：通路中所有的顶点互不相同。初级通路必为简单通路，但反之不真。
一个无向图 G=(V,E) 是连通的，那么边的数目大于等于顶点的数目减一：|E|>=|V|-1，而反之不成立。
[2]
如果 G=(V,E) 是有向图，那么它是强连通图的必要条件是边的数目大于等于顶点的数目：|E|>=|V|，而反之不成立。
没有回路的无向图是连通的当且仅当它是树，即等价于：|E|=|V|-1。
1951年，霍夫曼和他在MIT信息论的同学得选择是完成学期报告还是期末考试。导师罗伯特·法诺出的学期报告题目是，查找最有效的二进制编码。由于无法证明哪个已有编码是最有效的，霍夫曼放弃对已有编码的研究，转向新的探索，最终发现了基于有序频率二叉树编码的想法，并很快证明了这个方法是最有效的。霍夫曼使用自底向上的方法构建二叉树，避免了次优算法香农-范诺编码的最大弊端──自顶向下构建树。
1952年，于论文《一种构建极小多余编码的方法》（A Method for the Construction of Minimum-Redundancy Codes）中发表了这个编码方法。
Huffman在1952年根据香农（Shannon）在1948年和范若（Fano）在1949年阐述的这种编码思想提出了一种不定长编码的方法，也称霍夫曼（Huffman）编码。霍夫曼编码的基本方法是先对图像数据扫描一遍，计算出各种像素出现的概率，按概率的大小指定不同长度的唯一码字，由此得到一张该图像的霍夫曼码表。编码后的图像数据记录的是每个像素的码字，而码字与实际像素值的对应关系记录在码表中。
霍夫曼编码是可变字长编码(VLC)的一种。 Huffman于1952年提出一种编码方法，该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码，一般就称Huffman编码。下面引证一个定理，该定理保证了按字符出现概率分配码长，可使平均码长最短。
? 定理：在变字长编码中，如果码字长度严格按照对应符号出现的概率大小逆序排列，则其平 均码字长度为最小。
? 通过一个实例来说明上述定理的实现过程。设将信源符号按出现的概率大小顺序排列为 ： ?
U： ( a1 a2 a3 a4 a5 a6 a7 )
0.20 0.19 0.18 0.17 0.15 0.10 0.01
? 给概率最小的两个符号a6与a7分别指定为“1”与“0”，然后将它们的概率相加再与原来的 a1~a5组合并重新排序成新的原为：
U′： ( a1 a2 a3 a4 a5 a6′ )
0.20 0.19 0.18 0.17 0.15 0.11
? 对a5与a′6分别指定“1”与“0”后，再作概率相加并重新按概率排序得
U″：（0.26 0.20 0.19 0.18 0.17）…
? 直到最后得 U″″：（0.61 0.39）
? 霍夫曼编码的具体方法：先按出现的概率大小排队，把两个最小的概率相加，作为新的概率 和剩余的概率重新排队，再把最小的两个概率相加，再重新排队，直到最后变成1。每次相 加时都将“0”和“1”赋与相加的两个概率，读出时由该符号开始一直走到最后的“1”， 将路线上所遇到的“0”和“1”按最低位到最高位的顺序排好，就是该符号的霍夫曼编码。
例如a7从左至右，由U至U″″，其码字为0000；
? a6按践线将所遇到的“0”和“1”按最低位到最高位的顺序排好，其码字为0001…
? 用霍夫曼编码所得的平均比特率为：Σ码长×出现概率
? 上例为：0.2×2+0.19×2+0.18×3+0.17×3+0.15×3+0.1×4+0.01×4=2.72 bit
? 可以算出本例的信源熵为2.61bit，二者已经是很接近了。
Huffman方法构造出来的码并不是唯一的。但对于同一信源而言，其平均码字长是相同的，编码效率是一样的。
Huffman编码对不同信源的编码的编码效率是不同的。只有当信源概率分布不均匀时，Huffman才会收到显著效果。
霍夫曼编码广义[编辑]
给定
一组符号（Symbol）和其对应的权重值（weight），其权重通常表示成概率（%）。
欲知
一组二元的前置码，其二元码的长度为最短。
霍夫曼编码狭义[编辑]
输入
符号集合{\displaystyle S=\left\{s_{1},s_{2},\cdots ,s_{n}\right\}}，其S集合的大小为{\displaystyle n}。
权重集合{\displaystyle W=\left\{w_{1},w_{2},\cdots ,w_{n}\right\}}，其W集合不为负数且{\displaystyle w_{i}=\mathrm {weight} \left(s_{i}\right),1\leq i\leq n}。
输出
一组编码{\displaystyle C\left(S,W\right)=\left\{c_{1},c_{2},\cdots ,c_{n}\right\}}，其C集合是一组二进制编码且{\displaystyle c_{i}}为{\displaystyle s_{i}}相对应的编码，{\displaystyle 1\leq i\leq n}。
目标
设{\displaystyle L\left(C\right)=\sum _{i=1}^{n}{w_{i}\times \mathrm {length} \left(c_{i}\right)}}为{\displaystyle C}的加权的路径长，对所有编码{\displaystyle T\left(S,W\right)}，则{\displaystyle L\left(C\right)\leq L\left(T\right)}
霍夫曼编码示例[编辑]
霍夫曼树常处理符号编写工作。根据整组数据中符号出现的频率高低，决定如何给符号编码。如果符号出现的频率越高，则给符号的码越短，相反符号的号码越长。假设我们要给一个英文单字"F O R G E T"进行霍夫曼编码，而每个英文字母出现的频率分别列在Fig.1。
演算过程[编辑]
（一）进行霍夫曼编码前，我们先创建一个霍夫曼树。
⒈将每个英文字母依照出现频率由小排到大，最小在左，如Fig.1。
⒉每个字母都代表一个终端节点（叶节点），比较F.O.R.G.E.T六个字母中每个字母的出现频率，将最小的两个字母频率相加合成一个新的节点。如Fig.2所示，发现F与O的频率最小，故相加2+3=5。
⒊比较5.R.G.E.T，发现R与G的频率最小，故相加4+4=8。
⒋比较5.8.E.T，发现5与E的频率最小，故相加5+5=10。
⒌比较8.10.T，发现8与T的频率最小，故相加8+7=15。
⒍最后剩10.15，没有可以比较的对象，相加10+15=25。
最后产生的树状图就是霍夫曼树，参考Fig.2。　　（二）进行编码
1.给霍夫曼树的所有左链接'0'与右链接'1'。
2.从树根至树叶依序记录所有字母的编码，如Fig.3。
霍夫曼编码数据压缩[编辑]
实现霍夫曼编码的方式主要是创建一个二叉树和其节点。这些树的节点可以存储在数组里，数组的大小为符号（symbols）数的大小n，而节点分别是终端节点（叶节点）与非终端节点（内部节点）。
一开始，所有的节点都是终端节点，节点内有三个字段：
1.符号（Symbol）
2.权重（Weight、Probabilities、Frequency）
3.指向父节点的链接（Link to its parent node）
而非终端节点内有四个字段：
1.权重（Weight、Probabilities、Frequency）
2.指向两个子节点的链接（Links to two child node）
3.指向父节点的链接（Link to its parent node）
基本上，我们用'0'与'1'分别代表指向左子节点与右子节点，最后为完成的二叉树共有n个终端节点与n-1个非终端节点，去除了不必要的符号并产生最佳的编码长度。
过程中，每个终端节点都包含着一个权重（Weight、Probabilities、Frequency），两两终端节点结合会产生一个新节点，新节点的权重是由两个权重最小的终端节点权重之总和，并持续进行此过程直到只剩下一个节点为止。
实现霍夫曼树的方式有很多种，可以使用优先队列（Priority Queue）简单达成这个过程，给与权重较低的符号较高的优先级（Priority），算法如下：
⒈把n个终端节点加入优先队列，则n个节点都有一个优先权Pi，1 ≤ i ≤ n
⒉如果队列内的节点数>1，则：
⑴从队列中移除两个最小的Pi节点，即连续做两次remove（min（Pi）, Priority_Queue)
⑵产生一个新节点，此节点为（1）之移除节点之父节点，而此节点的权重值为（1）两节点之权重和
⑶把（2）产生之节点加入优先队列中
⒊最后在优先队列里的点为树的根节点（root）
而此算法的时间复杂度（Time Complexity）为O（nlogn）；因为有n个终端节点，所以树总共有2n-1个节点，使用优先队列每个循环须O（logn）。
此外，有一个更快的方式使时间复杂度降至线性时间（Linear Time）O（n），就是使用两个队列（Queue）创件霍夫曼树。第一个队列用来存储n个符号（即n个终端节点）的权重，第二个队列用来存储两两权重的合（即非终端节点）。此法可保证第二个队列的前端（Front）权重永远都是最小值，且方法如下：
⒈把n个终端节点加入第一个队列（依照权重大小排列，最小在前端）
⒉如果队列内的节点数>1，则：
⑴从队列前端移除两个最低权重的节点
⑵将（1）中移除的两个节点权重相加合成一个新节点
⑶加入第二个队列
⒊最后在第一个队列的节点为根节点
虽然使用此方法比使用优先队列的时间复杂度还低，但是注意此法的第1项，节点必须依照权重大小加入队列中，如果节点加入顺序不按大小，则需要经过排序，则至少花了O（nlogn）的时间复杂度计算。
但是在不同的状况考量下，时间复杂度并非是最重要的，如果我们今天考虑英文字母的出现频率，变量n就是英文字母的26个字母，则使用哪一种算法时间复杂度都不会影响很大，因为n不是一笔庞大的数字。
[1]
霍夫曼编码数据解压缩[编辑]
简单来说，霍夫曼码树的解压缩就是将得到的前置码（Prefix Huffman code）转换回符号，通常借由树的追踪（Traversal），将接收到的比特串（Bits stream）一步一步还原。但是要追踪树之前，必须要先重建霍夫曼树 ；某些情况下，如果每个符号的权重可以被事先预测，那么霍夫曼树就可以预先重建，并且存储并重复使用，否则，发送端必须预先发送霍夫曼树的相关信息给接收端。
最简单的方式，就是预先统计各符号的权重并加入至压缩之比特串，但是此法的运算量花费相当大，并不适合实际的应用。若是使用Canonical encoding，则可精准得知树重建的数据量只占B2^B比特（其中B为每个符号的比特数（bits））。如果简单将接收到的比特串一个比特一个比特的重建，例如：'0'表示父节点，'1'表示终端节点，若每次读取到1时，下8个比特则会被解读是终端节点（假设数据为8-bit字母），则霍夫曼树则可被重建，以此方法，数据量的大小可能为2~320字节不等。虽然还有很多方法可以重建霍夫曼树，但因为压缩的数据串包含"traling bits"，所以还原时一定要考虑何时停止，不要还原到错误的值，如在数据压缩时时加上每笔数据的长度等。
由于从内存中提取数值经常要比复杂的计算速度快很多，所以这样得到的速度提升是很显著的。
一个经典的例子就是三角表。每次计算所需的正弦值在一些应用中可能会慢得无法忍受，为了避免这种情况，应用程序可以在刚开始的一段时间计算一定数量的角度的正弦值，譬如计算每个整数角度的正弦值，在后面的程序需要正弦值的时候，使用查找表从内存中提取临近角度的正弦值而不是使用数学公式进行计算。
在计算机出现之前，人们使用类似的表格来加快手工计算的速度。非常流行的表格有三角、对数、统计 density 函数。另外一种用来加快手工计算的工具是滑动计算尺。
一些折衷的方法是同时使用查找表和插值这样需要少许计算量的方法，这种方法对于两个预计算的值之间的部分能够提供更高的精度，这样稍微地增加了计算量但是大幅度地提高了应用程序所需的精度。根据预先计算的数值，这种方法在保持同样精度的前提下也减小了查找表的尺寸。
在图像处理中，查找表经常称为LUT，它们将索引号与输出值建立联系。颜色表作为一种普通的 LUT 是用来确定特定图像所要显示的颜色和强度。
另外需要注意的一个问题是，尽管查找表经常效率很高，但是如果所替换的计算相当简单的话就会得不偿失，这不仅仅因为从内存中提取结果需要更多的时间，而且因为它增大了所需的内存并且破坏了高速缓存。如果查找表太大，那么几乎每次访问查找表都会导致高速缓存缺失，这在处理器速度超过内存速度的时候愈发成为一个问题。在编译器优化的 rematerialization 过程中也会出现类似的问题。在一些环境如Java 编程语言中，由于强制性的边界检查带来的每次查找的附加比较和分支过程，所以查找表可能开销更大。
何时构建查找表有两个基本的约束条件，一个是可用内存的数量；不能构建一个超过能用内存空间的表格，尽管可以构建一个以查找速度为代价的基于磁盘的查找表。另外一个约束条件是初始计算查找表的时间——尽管这项工作不需要经常做，但是如果耗费的时间不可接受，那么也不适合使用查找表。
许多计算机只能执行基本的算术运算，而不能直接计算给定值的正弦值，它们使用如下面泰勒级数（en:Taylor series）这样的复杂公式计算相当高精度的正弦值：
(x 接近 0)
然而，这样的计算费用可能是非常大的，尤其是在低速的处理器上。有许多的应用程序，尤其是传统的计算机图形每秒需要几千次的正弦值计算。一个常用的解决方案就是在刚开始计算许多均匀分布数值的正弦值，然后在表中查找最接近所需 x 的正弦值，这个值非常接近于正确的数值，这是因为正弦函数是一个有限变化率的连续函数。例如：
real array sine_table[-1000..1000]
for x from -1000 to 1000
sine_table[x] := sine(x/1000/pi)
function lookup_sine(x)
return sine_table[round(x/1000/pi)]
Image:Interpolation example linear.png
部分正弦函数的线性插值不幸的是，查找表需要一定的空间：如果使用 IEEE 双精度浮点数的话，将会需要 16,000 字节。如果使用较少的采样点，那么精度将会大幅度地下降。一个较好的解决方案是线性插值，在表中待计算点左右两侧两个点的值之间连直线，这个点对应的直线上的值就是所计算点的正弦值。这种方法计算速度也很快，对于如正弦函数这样的平滑函数来说也有更高的精度。这里是使用线性插值的一个例子：
function lookup_sine(x)
x1 := floor(x/1000/pi)
y1 := sine_table[x1]
y2 := sine_table[x1+1]
return y1 + (y2-y1)*(x/1000/pi-x1)
当使用插值的时候，可以得益于不均匀采样，也就是说在接近直线的地方，使用较少的采样点，在变化较快的地方使用较多的采样点以最大限度地接近实际的曲线。更多的信息请参考插值。
population function。例如，数字 37 的二进制形式是 100101，所以它包含有三个设置成 1 的位。一个计算 32 位整数中 1 的位数的简单c语言程序是：
int count_ones(unsigned int x) {
int i, result = 0;
for(i=0; i<32; i++) {
result += x & 1;
x = x >> 1;
}
return result;
}
不幸的是，这个简单的算法在现代的架构上将需要数以百计的时钟周期才能完成，这是因为它造成了许多分支和循环，而分支的速度是很慢的。这可以使用 loop unrolling 和其它一些聪明的技巧进行改进，但是最简单快捷的解决方案是查找表：简单地构建一个 包含每个字节可能值包含的 1 的个数的256 个条目的表。然后使用这个表查找整数中每个字节包含的 1 的个数，并且将结果相加。没有分支、四次内存访问、几乎没有算术运算，这样与上面的算法相比就可以大幅度地提升速度。
int count_ones(unsigned int x) {
return bits_set[x & 255] + bits_set[(x >> 8) & 255]
+ bits_set[(x >> 16) & 255] + bits_set[(x >> 24) & 255];
}
----------------------------------------------------------------------
#include
#define BYTE unsigned char
/* 定义查找表 */
BYTE numTable[256] =
{
0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3,
3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3,
4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4,
3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3,
4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6,
6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4,
5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3,
4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4,
4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6,
7, 6, 7, 7, 8
};
int main(int argc, char *argv[])
{
int i, num = 0;
BYTE a = 0;
/* 接收用户输入 */
printf("\nPlease Input a BYTE(0~255):");
scanf("%d", &a);
/* 计算1 的个数 */
/* 用BYTE 直接作为数组的下标取出1 的个数，妙哉！ */
printf("\nthe num of 1 in the BYTE is %d", checknum[a]);
return 0;
}
在数字逻辑中，n位查找表可以使用多路复用器来实现，它的选择线是 LUT 的输入，它的输入是常数。n 位 LUT 通过将布尔逻辑函数建模为真值表从而可以编码任意 n 位输入，这是编码布尔逻辑函数的一个有效途径，4 位 LUT 实际上是现代 FPGAs 的主要元件。
采用这种结构的PLD芯片我们就可以称之为FPGA：如altera的ACEX,APEX系列,xilinx的Spartan,Virtex系列等。
查找表（Look-Up-Table)简称为LUT，LUT本质上就是一个RAM。 目前FPGA中多使用4输入的LUT，所以每一个LUT可以看成一个有4位地址线的16x1的RAM。 当用户通过原理图或HDL语言描述了一个逻辑电路以后，PLD/FPGA开发软件会自动计算逻辑电路的所有可能的结果，并把结果事先写入RAM,这样，每输入一个信号进行逻辑运算就等于输入一个地址进行查表，找出地址对应的内容，然后输出即可。
平原上的三个城镇间要兴建一个公用的煤气供应站，在选址问题上，要考虑的主要问题是使由供应站到三个城镇的输送管道的总长最短。如何去寻找合适地点？
[1-2]
假若要建的是一个垃圾处理站，要修建三条公路将垃圾站与三个城镇连起来。这时，因为三个城镇的居民的数目或工业性质等的不同，每天运送垃圾使用的车辆数目 各不相同，运输的费用也就各异。因此，选取地点时，如果仍考虑使三条公路的总长最小，就不合理了。这时应该考虑：先计算出三个城镇单位时间内生产的垃圾数 量的百分比（或每日运输费用的百分比），如何选取地点，使得每个城镇垃圾运输数量与公路里程的乘积之和为最小。
1638年，法国数学家费马在他所写的一本关于求极值的书中就有了第一个问题，称为费马问题；第二个问题则到了18世纪中叶才由辛普森（A.R.Simpson）提出来。
斯坦纳树问题的定义随着历史的发展在不断的扩展和推广。
瑞士数学家斯坦纳（J.Steiner，1796—1863）将问题推广成：在平面上求一点，使得这一点到平面 上给定的若干个点（称为所与点）的距离之和最小。这可以看作斯坦纳树问题的雏形。
考虑到点的其他相关因素，加入了权重的表示。形成的推广定义，德国的两位数学家韦伯(H.Weber，1842—1913)和维斯菲尔德（E.Wieszfeld）分别在1909年和1937年将该问题作为工 厂选址问题提出来：某地有给定的若干个仓库，每个仓库的其他相关因素可以换算成一个权重表示，求一建造工厂的合适地点，使工厂到每个仓库的距离与权重乘积 的总和最小，则这个工厂的地址是最经济、便利的。
库朗（R.Courant）和罗宾斯（H.Robbins）提出第一个定义中，斯坦纳对此问题的推广是一种平庸的推广。要得到一个有意义的推广，需要考虑的不是引进一个点，而应是引进若干个点，使引进的点与原来给定的点 连成的网络最小。他们将此新问题称为斯坦纳树问题。给出的定义为：
假设原来已经给定了n个点，库朗等指出需要引进的点数至多为n-2，此种点称为斯坦纳点。过每一斯坦纳点，至多有三条边通过。若为三条边，则它们两两交成 120°角；若为两条边，则此斯坦纳点必为某一已给定的点，且此两条边交成的角必大于或等于120°。其中最小的网络称为已给定点的集合的最小斯坦纳树， 记作SMT。若此SMT的斯坦纳点中有等于给定点的点，则称此SMT为退化的，此给定点称为退化点。
Pollak-Gilbert猜想：
平面上任意n点集，斯坦纳最小树长与最小生成树之长的比值的最小值是
问题的起源：1967年前，贝尔公司按照链接各分部的最小生成树的长度来收费。同年，一家航空公司戳了贝尔公司一个大洞。当时这家企业申请要求贝尔公司增加一些服务点，而这些服务点恰恰位于构造该公司各分部的Steiner最小树需增加的Steiner顶点上。这使得贝尔公司不仅要拉新线，增加服务网点，而且还要减少收费。这一意外事件迫使贝尔公司自此以后便采用了Steiner最小树原则。

此问题可以抽象为设ΔABC为等边三角形，链接三顶点的路线（称为网络）。这种网络有许多个，其中最短的路线显然是二边之和（如AB∪AC）。如何用最短的线路将三部电话连接起来？
[3]
解决方案：
但若增加一个周转站（新点P），连接4点的新网络的最短路线为PA+PB+PC。最短路径之长比原来只连三点的最短路径要短。
这样得到的网络不仅比原来节省材料，而且稳定性也更好。
设计一种堆结构像二叉堆那样高效的支持合并操作而且只使用一个数组似乎很困难。原因在于，合并似乎需要把一个数组拷贝到另一个数组中去，对于相同大小的堆，这将花费O(N)。正因为如此，所有支持高效合并的高级数据结构都需要使用指针。
[1]
左式堆的结点相比于一般的堆来说，增加了Npl属性，Npl是 null path length 的缩写，指的是从该结点到达一个没有两个孩子的结点的最短距离（一个孩子的结点或者叶子）。一般定义NULL的Npl为-1以使计算简便。容易得到，任意结点的Npl是它的孩子的Npl中较小的那个结点的Npl+1.
左式堆除了保留堆的二叉树属性和最小堆属性外，有一个特征属性：任意结点的左孩子的Npl大于等于右孩子的Npl。这个特性决定了左式堆的不平衡性，并且明显左边会比较深，这就是左式堆的得来。由这个性质和上面提到的性质可以得到：左式堆任意结点的Npl为右孩子的Npl+1.
沿右路共有r个结点的左式堆至少有2^r-1个结点。这个定理的证明比较容易，利用迭代即可，这里就不赘述了。
左式堆的最基本的操作就是合并（Merge），之所以把它构造成这样一个不平衡的堆，就是为了使它相对于一般的二叉堆来说，合并变得非常地容易。左式堆的合并共有四步：
1.如果有一棵树是空树，则返回另一棵树；否则递归地合并根结点较小的堆的右子树和根结点较大的堆。
2.使形成的新堆作为较小堆的右子树。
3.如果违反了左式堆的特性，交换两个子树的位置。
4.更新Npl。
左式堆的插入（Insert）很简单，其实也就是一个单结点和原堆的合并。
左式堆的DleteMin也很简单，就是把根结点删除，把两棵子树合并。左式堆的删除可以考虑懒惰删除（Lazy Delete）。
由于上述的操作均基于合并，而合并仅对右路做合并，而右路结点的数量为总数量的对数关系，所以左式堆的三个操作所花的时间为O(logN).
左式堆的变形最常见的就是斜堆（Skew Heaps），实际上，斜堆并不是一个非常好用的数据结构，所以这里就不讲述了。.
加速比以如下公式定义：

其中：
指CPU数量
指顺序执行算法的执行时间
指当有p个处理器时，并行算法的执行时间
当



 时，



 便可称为“线性加速比”（英语：linear speedup，又名“理想加速比”）。当某一并行算法的加速比为理想加速比时，若将处理器数量加倍，执行速度也会加倍，即如“理想”之意，有“优秀的可扩展性”。
“效率”
由加速比派生出的效率（英语：efficiency）则是量度性能的指标，并如下定义：

效率



 的值一般介于0～1之间，用于表示在解决问题时，相较于在通信与同步上的花费，参与计算的处理器得到了什么程度的充分利用。由定义易见，拥有线性加速比的算法与在单处理器上执行的算法的效率为1。
[1]
在并行计算过程中，有时会遇到加速比



 比处理器数



 更大的情况，此时求得的加速比即称超线性加速比（英语：superlinear speedup）。超线性加速比很少出现，且由于初学者常以为理论上加速比的最大值应与参与计算的处理器的总数



 相等，这一情况常使初学者迷惑不已。
阿姆达尔定律（英语：Amdahl's law，Amdahl's argument），一个计算机科学界的经验法则，因吉恩·阿姆达尔而得名。它代表了处理器并行运算之后效率提升的能力。
特点：要求实时性，因此时间是关键因素，而计算负载是确定的。适用于固定计算负载。对于固定的问题规模，通过增加处理器，减少平均的计算负载，来提升运算速度。
并行计算中的加速比是用并行前的执行速度和并行后的执行速度之比来表示的，它表示了在并行化之后的效率提升情况。
阿姆达尔定律是固定负载（计算总量不变时）时的量化标准。可用公式：



 来表示。式中



 分别表示问题规模的串行分量（问题中不能并行化的那一部分）和并行分量，p表示处理器数量。
只要注意到当



 时，上式的极限是



 ，其中，



 。这意味着无论如何增大处理器数目，加速比是无法高于这个数的。
评价多核CPU加速比已知模型的基础上，基于第一性计算原理融合理解阿姆达尔定律和兰特法则，提出描述多核CPU加速比的一个新模型．研究方法是从传统的阿姆达尔定律切入，论述的逻辑顺序分别基于约束固定任务，固定时间，存储器和互连复杂性；兼顾了举例论述同构多核的NoC带宽性质和最大温度特性．计算表明：基于固定时间模型与存储器模型预测多核的加速能力，容易得到估计结果的乐观上限；本文
[2] 
提出的基于兰特法则的模型计算结果，在并行比例较大时稍小于但接近前述模型估计值，而比固定任务模型的保守结果要好；NoC带宽和最大温度的结果提示，多(同构)核CPU期盼相对高的并行度架构。
加速比是衡量并行处理性能的重要指标之一; 较高加速比的获得除与任务的划分、并行算法的选择等有关外 ,还与各节点间的通信有关; 在大多数并行系统中 ,在数据规模确定的情况下 ,程序的加速比随节点数的增加而增加 ,但是大多数机群系统的节点间是共享物理传输介质的 ,这就使得许多并行程序的加速比在节点数目超过某一个值之后会随着节点数的增加而减少;文章
[3] 
通过数值实验研究 ,分析了节点间通信对加速比的影响 ,进一步论证了节点间通信对加速比的重要影响。
关键路径通常（但并非总是）是决定项目工期的进度活动序列。它是项目中最长的路径，即使很小浮动也可能直接影响整个项目的最早完成时间。关键路径的工期决定了整个项目的工期，任何关键路径上的终端元素的延迟在浮动时间为零或负数时将直接影响项目的预期完成时间（例如在关键路径上没有浮动时间）。
[2] 
但特殊情况下，如果总浮动时间大于零，则有可能不会影响项目整体进度。
一个项目可以有多个、并行的关键路径。另一个总工期比关键路径的总工期略少的一条并行路径被称为次关键路径。最初，关键路径方法只考虑终端元素之间的逻辑依赖关系。关键链方法中增加了资源约束。关键路径方法是由杜邦公司发明的。
A、从开始顶点 v1 出发，令 ve(1)=0，按拓扑有序序列求其余各顶点的可能最早发生时间。
[3]
Ve(k)=max{ve(j)+dut(<j,k>)} , j ∈ T 。其中T是以顶点vk为尾的所有弧的头顶点的集合（2 ≤ k ≤ n）。
如果得到的拓朴有序序列中顶点的个数小于网中顶点个数n，则说明网中有环，不能求出关键路径，算法结束。
B、从完成顶点



出发，令



，按逆拓扑有序求其余各顶点的允许的最晚发生时间：
vl(j)=min{vl(k)-dut(<j,k>)} ,k ∈ S 。其中 S 是以顶点vj是头的所有弧的尾顶点集合（1 ≤ j ≤ n-1）。
C、求每一项活动ai（1 ≤ i ≤ m）的最早开始时间e(i)=ve(j)，最晚开始时间l(i)=vl(k)-dut(<j,k>) 。
若某条弧满足 e(i)=l(i) ，则它是关键活动。
（1）AOE网
用顶点表示事件，弧表示活动，弧上的权值表示活动持续的时间的有向图叫AOE（Activity On Edge Network）网。在建筑学中也称为关键路线。AOE网常用于估算工程完成时间。例如：




图1.有向网络

图1 是一个网。其中有9个事件v1,v2,…,v9；11项活动a1,a2,…,a11。每个事件表示在它之前的活动已经完成，在它之后的活动可以开始。如 v1表示整个工程开始，v9 表示整个工程结束。V5表示活动a2和a3已经完成，活动a7和a8可以开始。与每个活动相联系的权表示完成该活动所需的时间。如活动a1需要6个时间单位可以完成。
一个AOE网的关键路径可以不止一条。
只有在某顶点所代表的事件发生后，从该顶点出发的各有向边所代表的活动才能开始。只有在进入某一顶点的各有向边所代表的活动都已经结束，该顶点所代表的事件才能发生。表示实际工程计划的AOE网应该是无环的，并且存在唯一的入度为0的开始顶点和唯一的出度为0的完成顶点。
（2） 活动开始的最早时间e(i)；
（3） 活动开始的最晚时间l(i) 定义e(i)=l(i）的活动叫关键活动；
（4） 事件开始的最早时间ve(i)；
（5） 事件开始的最晚时间vl(i)。
（1） 完成整个工程至少需要多少时间；
（2） 哪些活动是影响工程的关键。
1956年，美国杜邦公司提出关键路径法，并于1957年首先用于1000万美元化工厂建设，工期比原计划缩短了4个月。杜邦公司在采用关键路径法的一年中，节省了100万美元。
（1） 输入e条弧<j,k>，建立AOE网的存储结构；
（2） 从源点v1出发，令ve(1)=0，求 ve(j) ,2<=j<=n；
（3） 从汇点vn出发，令vl(n)=ve(n)，求 vl(i), 1<=i<=n-1；
（4） 根据各顶点的ve和vl值，求每条弧s（活动）的最早开始时间e(s)和最晚开始时间l(s)，其中e(s)=l(s)的为关键活动。
求关键路径是在拓扑排序的前提下进行的，不能进行拓扑排序，自然也不能求关键路径。
算法分析
（1） 求关键路径必须在拓扑排序的前提下进行，有环图不能求关键路径；
（2） 只有缩短关键活动的工期才有可能缩短工期；
（3） 若一个关键活动不在所有的关键路径上，减少它并不能减少工期；
（4） 只有在不改变关键路径的前提下，缩短关键活动才能缩短整个工期。
Status ToplogicalSort(ALGraph G,stack &T){
FindInDegree(G,indegree);
InitStack(S);count=0; ve[0..G.vexnum-1]=0;
while(!StackEmpty(S))
{ Pop(S,j);Push(T,j); ++count;
for(p=G.vertices[j].firstarc;p;p=p->nextarc)
{k=p>adjvex;
if(--indegree[k]==0) Push(S,k);
if(ve[j]+*(p->info)>ve[k]) ve[k]=ve[j]+*(p->info);
}
}
if(count<G.vexnum) return ERROR;
else return OK;
}
status CriticalPath(ALGraph G){
if(!ToplogicalOrder(G,T)) return ERROR;
vl[0..G.vexnum-1]=ve[G.vexnum-1];
while(!StackEmpty(T))
for(Pop(T,j),p=G.vertices[j].firstarc;p;p=p->nextarc)
{k=p->adjvex; dut=*(p->info);
if(vl[k]-dut<vl[j]) vl[j]=vl[k]-dut;
}
for(j=0;j<G.vexnum;++j)
for(p=G.vertices[j].firstarc;p;p=p->nextarc)
{k=p>adjvex; dut=*(p->info);
ee=ve[j]; el=vl[k];
tag=(ee==el)?’*’：’’；
printf(j,kdut,ee,el,tag);
}
}
[4]
C++完整代码
#include <iostream>
#include <cstdio>
#include<string.h>
using namespace std;
int n,m,w[1001][1001],prev[1001],queue[1001],Time[1001],l=0,r=0,Pos[1001],path[1001];
void init()
{
int i,a,b,c;
scanf("%d%d",&n,&m);
for (i=1;i<=m;i++)
{
scanf("%d%d%d",&a,&b,&c);
w[a][b]=c;
prev[b]++;
}
}
inline void Newq(int v)
{
r++;
queue[r]=v;
}
inline void Del(int v)
{
int i;
for (i=1;i<=n;i++)
if (w[v][i])
{
prev[i]--;
if (!prev[i])
Newq(i);
}
}
void topo()
{
for (int i=1;i<=n;i++)
if (!prev[i])
Newq(i);
while (r<n)
{
l++;
Del(queue[l]);
}
}
void crucialpath()
{
int i,j;
memset(Time,0,sizeof(Time));
for (i=1;i<=n;i++)
for (j=1;j<=n;j++)
if ((w[j][queue[i]]) && (Time[j]+w[j][queue[i]]>Time[queue[i]]))
{
Time[queue[i]]=Time[j]+w[j][queue[i]];
Pos[queue[i]]=j;
}
}
void print()
{
printf("%d\n",Time[n]);
int i=n,k=0;
while (i!=1)
{
k++;
path[k]=i;
}
for (i=k;i>1;i--)
printf("%d ",path[i]);
printf("%d\n",path[1]);
}
int main()
{
init();
topo();
crucialpath();
print();
return 0;
}
甘特图
计划评审技术（PERT）
项目
项目管理
项目计划
工作分解结构
关键链
逻辑结构元素决定输入、存储、发送、处理和信息传递的基本操作功能，常将逻辑结构元素称为逻辑模块。逻辑结构元素可以是计算机操作系统、终端模块、通信程序模块等。逻辑结构元素还可以是相关的几个逻辑模块联合起来的更复杂的实体。分析逻辑结构元素的相互作用，应考虑整个系统的操作，研究处理与信息流有关的进程（操作系统中的一个概念，表示程序的一次执行），并决定系统的逻辑资源
[1] 
。
逻辑结构有四种基本类型：集合结构、线性结构、树状结构和网络结构。表和树是最常用的两种高效数据结构，许多高效的算法能够用这两种数据结构来设计实现。表是线性结构的（全序关系），树(偏序或层次关系)和图（局部有序(weak/local order)）是非线性结构。
数据结构的物理结构是指逻辑结构的存储映像(image)。数据结构DS的物理结构P对应于从DS的数据元素到存储区M（维护着逻辑结构S）的一个映射：P:(D,S)M
集合结构：集合结构的集合中任何两个数据元素之间都没有逻辑关系，组织形式松散。
线性结构：数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。
树状结构：树状结构是一个或多个节点的有限集合
网络结构：网络结构是指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。它广泛采用的是国际标准化组织（ISO）在1979年提出的开放系统互连（OSI-Open System Interconnection)的参考模型
[2] 
。
逻辑结构设计是将概念结构设计阶段完成的概念模型，转换成能被选定的数据库管理系统(DBMS)支持的数据模型。这里主要将E-R模型转换为关系模型。需要具体说明把原始数据进行分解、合并后重新组织起来的数据库全局逻辑结构，包括所确定的关键字和属性、重新确定的记录结构和文件结构、所建立的各个文件之间的相互关系，形成本数据库的数据库管理员视图
[3] 
。
乡村青年树希望自己能够挣到钱，过上城里人的生活，最后他成了预言家。
导演兼编剧韩杰创作阐述： 我非常喜欢剧本中这个主人公，我给他取的名字叫“树”。因我觉得他渐渐的失去与人在世俗中的往来后，就像一棵树一样变得沉默或者失语，我试着进入这个人的精神世界。描述这个世界是充满挑战的，因为离开了文字叙述，我只能通过影像和音乐。我坚信，不断游走在社会现实和精神现实（或心理现实）中的影像，更加刺激也更有张力，更容易让观众理解这个人的精神世界。这部电影将是一次精神现实主义的新尝试！
韩杰：2002年独立完成毕业作品短片《过年》，参展2003年釜山国际电影节短片单元。获得首届国际DV论坛专业组最佳故事片奖，曾获第9届北京大学生电影节学生组最佳故事片奖。毕业后任贾樟柯电影《世界》、《三峡好人》》、《二十四城记》副导演。2006年编导首部长片电影《赖小子》，获第35届鹿特丹国际电影节最佳影片金虎奖，第30届香港国际电影节数码竞赛片最佳影片银奖 。2008年应西班牙巴塞罗那当代文化中心之邀拍摄关于上海的短片《床》。
西河星汇致力结合海外电影资源，发展中国青年电影。成立以来，除制作贾樟柯导演作品《世界》、《三峡好人》、《二十四城记》，还投资出品余力为导演的《荡寇》，韩杰导演的《赖小子》，唐小白导演的《完美生活》等，在国际电影界引起广泛影响。
王宝强，中国内地男演员，1984年出生于河北省邢台市南和县，6岁时开始练习武术，8岁在嵩山少林寺做俗家弟子，20岁时主演独立电影《盲井》获金马奖最佳新人奖及法国、泰国电影节最佳男主角奖
[1] 
。
2004年因参演冯小刚的贺岁剧《天下无贼》其朴实的个性和独特的形象赢得关注。2008年凭借《士兵突击》里的许三多获得第24届中国电视金鹰奖最具人气男演员奖以及观众喜爱的电视剧男演员奖
[2] 
。2011年王宝强携电影《Hello!树先生》获得俄罗斯、美国纽约、意大利电影节最佳男主角奖及亚太电影大奖，与徐峥继《人在囧途》再度合作的《人再囧途之泰囧》创华语电影票房纪录。
2014其主演的科幻动作爱情电影“冰封侠”系列将上映，其中第一部《冰封：重生之门》已于4月25日全上映。第二部《冰封：永恒之门》将于2014年10月19日上映。同年出演陈凯歌电影《道士下山》。
《树先生》前日在汉试映后，王宝强的预言兑现了：尽管有观众表示难以接受该片的荒诞魔幻范儿，却能一致认可王宝强确实脱胎换骨了。看过此片的观众几乎都在说，很难用短短两三字去定义它的气质血脉，魔幻，神经质，黑色，幽默，乡村异人志，这些真的能概括树先生么？还不如用文艺片里的"重口味"这样霸道的说法，盖住它特立独行的站姿、坐相。
[3-4]
子图子图的定义
设



 为两个图（同为无向图或同为有向图），若



 且



 ，则称G'是G的子图，G是G‘的母图，记作



 ，又若



 且



 ，则G'称是G的真子图，若



 ，则称G'是G的生成子图。
设



 为一图，



 且



 ,称以



 为顶点集，以G中两个端点都在



 中的边组成边集



 的图为G的



 导出子图，记作



 ，又设



 且



 ，称以



 为边集，以



 中边关联的顶点为顶点集



 的图为G的



 导出的子图，记作



。
在图1中，设G如图1(a)所示，取



 ，则



 的导出子图



 如图1(b)所示，取



 ，则



 的导出子图



 如图1(c)所示。
[2]
图1（a）
图1（b）
图1（c）
子图补图
设



 为n阶无向简单图，以V为顶点集，以所有使G成为完全图的



 的添加边组成的集合为边集的图，称为G的补图，记作



。
若图



 ，则称G是自补图。
图2中，（b）和（c）互为补图，（a）是自补图。
[2]
图2（a）
图2（b）
图2（c）
若n阶图G是自补图，则



或



，k为非负整数，且图G有



条边。
[3]
证明：因为n阶图G是自补图，所以G与



同构。于是完全图



的



条边将各有一半为G与



的边，即G与



均有



条边。而图G的边数是非负整数，故4一定能整除



，而连续的两个整数n-1与n总是一个为奇数，一个为偶数，故



或



（k为非负整数）。证毕。
图3（a）
图3(b)
设



为无向图。
(1)设



，用



表示从G中去掉边e，称为删除边e。又设



，用



表示从G中删除E'中的所有边，称为删除E'。
(2)设



，用



表示从G中去掉v及所关联的一切边，称为删除顶点v，又设



，用



表示从G中删除



中的所有边，称为删除V'。
(3)设边



，用



表示从G中删除e后，将e的两个端点u，v用一个新的顶点w（或用u或用v充当w）代替，使w关联e以外u，v关联的所有边，称为边e的收缩。
(4)设



（u，v可能相邻，也可能不相邻），用



（或



）表示在u，v之间加一条边



，称为加新边。
在收缩边和加新边过程中可能产生环和平行边。
在图4中，设(a)图为G，则(b)图为



，(c)图为



，(d)图为



，(e)图为



，而



图为



。
[2]
图4（a）
图4（b）
图4（c）
图4（d）
图4（e）
图4（f）
设T是有根树，a是T中的一个顶点，由a以及a的所有后裔（后代）导出的子图称为有向树T的子树，a是子树的根。
[1] 
具体来说，子树就是树的其中一个节点以及其下面的所有的节点所构成的树。比如在下图中把A和E中间的那根线删除，节点E 、I、 J、 P、 Q就构成了一颗以E为根节点的子树。

具有代表性的是中的二叉树左子树、右子树，左子树就是以当前节点看，它的左子节点那一分支的子树，该子树以当前节点左子节点为根。右子树就是以当前节点看，它的右子节点那一分支的子树，该子树以当前节点右子节点为根。左右子树只在二叉树中有意义，因为二叉树非左即右。
1、树节点定义
struct TreeNode
{
    int val;
    TreeNode *next;
    TreeNode(int v) : val(v), next(NULL) {}
};
2、判断一棵树是否是另一棵树的子树
bool IsPart(TreeNode *root1, TreeNode *root2)
{
    if (root2 == NULL)
        return true;
    if (root1 == NULL)
        return false;
    if (root1->val != root2->val)
        return false;
    return IsPart(root1->left, root2->left) &&
        IsPart(root1->right, root2->right);
}
bool IsPartTree(TreeNode *root1, TreeNode *root2)
{
    bool result = false;
    if (root1 != NULL && root2 != NULL)
    {
        if (root1->val == root2->val)
            result = IsPart(root1, root2);
        if (!result)
            result = IsPartTree(root1->left, root2);
        if (!result)
            result = IsPartTree(root1->right, root2);
    }
    return result;
}
3、删除子树
Status deleted[MAX_TREE_SIZE+1]; /* 删除标志数组(全局量) */
void DeleteChild(PTree *T,TElemType p,int i)
{
     /* 初始条件：树T存在，p是T中某个节点，1≤i≤p所指节点的度 */  /* 操作结果：删除T中节点p的第i棵子树 */  
     int j,k,n=0;  LinkQueue q;  QElemType pq,qq;  
     for(j=0;j<=T->n;j++)    
     deleted[j]=0; /* 置初值为0(不删除标记) */  
     pq.name='a'; /* 此成员不用 */  
     InitQueue(&q); /* 初始化队列 */  
     for(j=0;j<T->n;j++)    
     if(T->nodes[j].data==p)      
     break; /* j为节点p的序号 */  
     for(k=j+1;k<T->n;k++)  
     {    
         if(T->nodes[k].parent==j)      
         n++;    
         if(n==i)      
         break; /* k为p的第i棵子树节点的序号 */  
     }  
     if(k<T->n) /* p的第i棵子树节点存在 */  
     {    
         n=0;    
         pq.num=k;    
         deleted[k]=1; /* 置删除标记 */    
         n++;    
         EnQueue(&q,pq);    
         while(!QueueEmpty(q))    
         {      
             DeQueue(&q,&qq);      
             for(j=qq.num+1;j<T->n;j++)        
             if(T->nodes[j].parent==qq.num)        
             {          
             pq.num=j;          
             deleted[j]=1; /* 置删除标记 */          
             n++;          
             EnQueue(&q,pq);        
             }    
     }    
     for(j=0;j<T->n;j++)      
     if(deleted[j]==1)      
     {        
     for(k=j+1;k<=T->n;k++)        
     {          
     deleted[k-1]=deleted[k];          
     T->nodes[k-1]=T->nodes[k];          
     if(T->nodes[k].parent>j)            
     T->nodes[k-1].parent--;        
     }        
     j--;      
     }    
     T->n-=n; /* n为待删除节点数 */  
     }
 }
数据结构课程中数据的逻辑结构分为线性结构和非线性结构。
对于数据结构课程而言，简单地说，线性结构是n个数据元素的有序（次序）集合。
1．集合中必存在唯一的一个"第一个元素"；
2．集合中必存在唯一的一个"最后的元素"；
3．除最后元素之外，其它数据元素均有唯一的"后继"；
4．除第一元素之外，其它数据元素均有唯一的"前驱"。
数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构。
如（a0,a1,a2,.....,an）,a0为第一个元素，an为最后一个元素，此集合即为一个线性结构的集合。
相对应于线性结构，非线性结构的逻辑特征是一个结点元素可能对应多个直接前驱和多个后继。
1976年雷兵提出了概率算法，这种算法的新颖之处是把随机性注入到算法中，使得算法设计与分析的灵活性及解决问题的能力大为改观，这种算法曾一度运用在密码学，数字信号，数字简化信号和大系统的安全及故障容差中得到应用。
很多算法的每一个计算步骤都是固定的，而概率算法允许算法在执行的过程中随机选择下一个计算步骤。许多情况下，当算法在执行过程中面临一个选择时，随机性选择常比最优选择省时。因此概率算法可在很大程度上降低算法的复杂度。
（1）随机决策。
（2）在同一实例上执行两次其结果可能不同。
（3）在同一实例上执行两次的时间亦可能不太相同。
对概率算法可以讨论如下两种期望时间：
（1）平均的期望时间：所有输入实例上平均的期望执行时间。
（2）最坏的期望时间：最坏的输入实例上的期望执行时间。
（1）不可再现性：在同一个输入实例上，每次执行结果不尽相同，例如N-皇后问题，概率算法运行不同次将会找到不同的正确解；找一给定合数的非平凡因子， 每次运行的结果不尽相同，但确定算法每次运行结果必定相同
(2) 分析困难：要求有概率论，统计学和数论的知识。
概率算法的一个基本特征是对所求解问题的同一实例用同一概率算法求解两次可能得到完全不同的效果。这两次求解问题所需的时间甚至所得到的结果可能会有相当大的差别。一般情况下，可将概率算法大致分为四类：数值概率算法，蒙特卡罗（Monte Carlo）算法，拉斯维加斯（Las Vegas）算法和舍伍德（Sherwood）算法。
数值概率算法常用于数值问题的求解。这类算法所得到的往往是近似解。而且近似解的精度随计算时间的增加不断提高。在许多情况下，要计算出问题的精确解是不可能或没有必要的，因此用数值概率算法可得到相当满意的解。
蒙特卡罗算法用于求问题的准确解。蒙特卡洛算法1945年由冯诺依曼行核武模拟提出的。它是以概率和统计的理论与方法为基础的一种数值计算方法，它是双重近似：一是用概率模型模拟近似的数值计算，二是用伪随机数模拟真正的随机变量的样本。
对于许多问题来说，近似解毫无意义。例如，一个判定问题其解为“是”或“否”，二者必居其一，不存在任何近似解答。又如，我们要求一个整数的因子时所给出的解答必须是准确的，一个整数的近似因子没有任何意义。用蒙特卡罗算法能求得问题的一个解，但这个解未必是正确的。求得正确解的概率依赖于算法所用的时间。算法所用的时间越多，得到正确解的概率就越高。蒙特卡罗算法的主要缺点就在于此。一般情况下，无法有效判断得到的解是否肯定正确。
拉斯维加斯算法不会得到不正确的解，一旦用拉斯维加斯算法找到一个解，那么这个解肯定是正确的。但是有时候用拉斯维加斯算法可能找不到解。与蒙特卡罗算法类似。拉斯维加斯算法得到正确解的概率随着它用的计算时间的增加而提高。对于所求解问题的任一实例，用同一拉斯维加斯算法反复对该实例求解足够多次，可使求解失效的概率任意小。
舍伍德算法总能求得问题的一个解，且所求得的解总是正确的。当一个确定性算法在最坏情况下的计算复杂性与其在平均情况下的计算复杂性有较大差别时，可以在这个确定算法中引入随机性将它改造成一个舍伍德算法，消除或减少问题的好坏实例间的这种差别。舍伍德算法精髓不是避免算法的最坏情况行为，而是设法消除这种最坏行为与特定实例之间的关联性
[2] 
。
在电信网络中，一个节点(英语：node，拉丁语：nodus）是一个连接点，表示一个再分发点（redistribution point）或一个通信端点（一些终端设备）。节点的定义依赖于所提及的网络和协议层。一个物理网络节点是一个连接到网络的有源电子设备，能够通过通信通道发送、接收或转发信息。因此，无源分发点（如配线架或接插板）不是节点。在网络理论或图论中，术语节点表示网络拓扑中，线相交或分支的点。
选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。
[1]
无向图G的极大连通子图称为G的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。
前序遍历（DLR），是二叉树遍历的一种，也叫做先根遍历、先序遍历、前序周游，可记做根左右。前序遍历首先访问根结点然后遍历左子树，最后遍历右子树。
一般的线性表，树中，记录在结构中的相对位置是随机的，即和记录的关键字之间不存在确定的关系，因此，在结构中查找记录时需进行一系列和关键字的比较。这一类查找方法建立在“比较“的基础上，查找的效率依赖于查找过程中所进行的比较次数。 理想的情况是能直接找到需要的记录，因此必须在记录的存储位置和它的关键字之间建立一个确定的对应关系f，使每个关键字和结构中一个唯一的存储位置相对应。
在B-树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取指针Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。
递归调用是一种特殊的嵌套调用，是某个函数调用自己或者是调用其他函数后再次调用自己的，只要函数之间互相调用能产生循环的则一定是递归调用，递归调用一种解决方案，一种是逻辑思想，将一个大工作分为逐渐减小的小工作，比如说一个和尚要搬50块石头，他想，只要先搬走49块，那剩下的一块就能搬完了，然后考虑那49块，只要先搬走48块，那剩下的一块就能搬完了，递归是一种思想，只不过在程序中，就是依靠函数嵌套这个特性来实现了。
大约公元前13世纪，腓尼基人创造了人类历史上第一批字母文字，共22个字母（无元音）。这是腓尼基人对人类文化的伟大贡献。腓尼基字母是世界字母文字的开端。在西方，它派生出古希腊字母，后者又发展为拉丁字母和斯拉夫字母。而希腊字母和拉丁字母是所有西方国家字母的基础。在东方，它派生出阿拉美亚字母，由此又演化出印度、阿拉伯、希伯莱、波斯等民族字母。中国的维吾尔、蒙古、满文字母也是由此演化而来。腓尼基字母是腓尼基人用以书写他们的腓尼基语。腓尼基语（Phoenician）是一种闪米特人语言。腓尼基铭文曾在考古遗址中发现，包括一些腓尼基城市及地中海周边的殖民地，例如比布鲁斯(在现今的黎巴嫩) 和迦太亚(在现今的突尼斯)。原本的原始西奈字母是象形文字，然而到腓尼基字母时代，有些字的意思已改变了。由于字母本来是刻在石上，所以多数字母都是直线和方形的，就像古日耳曼字母一样。虽然之后有多一些较曲线的版本，成了罗马时代的北非新迦太基字母。 腓尼基语通常由右到左写，而有些文字使用了左右往复书写法(boustrophedon, 又称耕地写法)。 部分字母有另一种书写表达方法， 例如 taw 可以写成似一个 '+' 号而不用 'x' 号， heth 可以有两条横线穿过。拉丁字母 X 来自希腊字母 Χ 的发音，而不是直接由 Ξ (samekh-inspired 字
顺序存储是所有的结点元素存放在一块连续的存储区域中，用存储结点的物理位置来体现结点之间的逻辑关系的存储方法。在高级语言中，一块连续的存储空间通常可用一个数组来表示。因此，顺序存储通常用一个数据元素类型的数组来存储。最经典的顺序存储结构是顺序表，将线性结构的元素按序存放在一个数组中
[1] 
。
给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。
在计算机科学中定义为：在一些（有序的/无序的）数据元素中，通过一定的方法找出与给定关键字相同的数据元素的过程叫做查找。也就是根据给定的某个值，在查找表中确定一个关键字等于给定值的记录或数据元素。
关节点是指在某图中，如果删除顶点V以及V相关的边后，图的一个连通分量分割为两个或两个以上的连通分量，则称顶点V为该图的一个关节点。
施特拉森算法（英语：Strassen algorithm）是一个计算矩阵乘法的算法。
并行算法就是用多台处理机 联合求解问题的方法和步骤，其执行过程是将给定的问题首先分解成若干个尽量相互独立的子问 题，然后使用多台计算机同时求解它，从而最终求得原问题的解。

边没有方向的图称为无向图。
整数规划是指规划中的变量（全部或部分）限制为整数，若在线性模型中，变量限制为整数，则称为整数线性规划。所流行的求解整数规划的方法往往只适用于整数线性规划。一类要求问题的解中的全部或一部分变量为整数的数学规划。从约束条件的构成又可细分为线性，二次和非线性的整数规划。
[1]
最大团问题（Maximum Clique Problem, MCP）是图论中一个经典的组合优化问题，也是一类NP完全问题，在国际上已有广泛的研究，而国内对MCP问题的研究则还处于起步阶段，因此，研究最大团问题具有较高的理论价值和现实意义。
在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在有向图中若以顶点表示活动，有向边表示活动之间的先后关系，这样的图简称为AOV网。
二叉链表是树的二叉链表实现方式。
串：会意字。物品连贯在一起（种子连贯）是其范式。本义：将物品连贯在一起。或亦指连贯而成的物品。衍义：互相贯通。如：串讲、贯串。衍义：互相勾结。如：串气、串供。衍义：互相穿越走动。如：串乡、串门。古代表示制钱的单位，也称为“贯”。一串折合铜元一千文，即一百枚十文铜元或五十枚二十文铜元，但因地区差异，上下略有浮动。
地址空间（address space）表示任何一个计算机实体所占用的内存大小。比如外设、文件、服务器或者一个网络计算机。地址空间包括物理空间以及虚拟空间。
双亲，指父亲和母亲。
单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链表中的数据是以结点来表示的，每个结点的构成：元素(数据元素的映象) + 指针(指示后继元素存储位置)，元素就是存储数据的存储单元，指针就是连接每个结点的地址数据。
双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。一般我们都构造双向循环链表。
数据项是指数据元素可由若干个数据项（data item）组成，数据项是数据的不可分割的最小单位。数据项的名称有编号、别名、简述、数据项的长度、类型、数据项的取值范围。数据项是数据记录中最基本的、不可分的有名数据单位，是具有独立含义的最小标识单位。
树是一种重要的非线性数据结构，直观地看，它是数据元素（在树中称为结点）按分支关系组织起来的结构，很象自然界中的树那样。
用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。Dijkstra算法能得出最短路径的最优解，但由于它遍历计算的节点很多，所以效率低。
数据结构在计算机中的表示（映像）称为数据的物理（存储）结构。它包括数据元素的表示和关系的表示。 物理结构，即oracle数据库使用的操作系统文件结构。对于数据库物理结构文件，不同的oracle版本，不同的操作系统平台上有不同的存储目录结构。
外排序（External sorting）是指能够处理极大量数据的排序算法。通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。尔后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。
一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。
[1]
一般来说，图可分为有向图和无向图。有向图的所有边都有方向，即确定了顶点到顶点的一个指向；而无向图的所有边都是双向的，即无向边所连接的两个顶点可以互相到达。在一些问题中，可以把无向图当作所有边都是正向和负向的两条有向边组成。顶点的度是指和该顶点相连的边的条数。特别是对于有向图来说，顶点的出边条数称为该顶点的出度，顶点的入边条数称为该顶点的入度
[1] 
。
八皇后问题，一个古老而著名的问题，是回溯算法的典型案例。该问题由国际西洋棋棋手马克斯·贝瑟尔于 1848 年提出：在 8×8 格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。高斯认为有 76 种方案。1854 年在柏林的象棋杂志上不同的作者发表了 40 种不同的解，后来有人用图论的方法解出 92 种结果。计算机发明后，有多种计算机语言可以编程解决此问题。
强连通图（Strongly Connected Graph）是指在有向图G中，如果对于每一对vi、vj，vi≠vj，从vi到vj和从vj到vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称做有向图的强连通分量。
顺序队列是队列的顺序存储结构，顺序队列实际上是运算受限的顺序表。和顺序表一样，顺序队列用一个向量空间来存放当前队列中的元素。由于队列的队头和队尾的位置是变化的，设置两个指针front和rear分别指示队头元素和队尾元素在向量空间中的位置，它们的初值在队列初始化时均应设置为0。
[1]
进程代数是关于通信并发系统的代数理论的统称。 20世纪70年代后期，英国学者RMnner和C. A.R，分别提出了通信系统演算和通信顺序进程，开创了用代数方法研究通信并发系统的先河。 此后这一研究方向兴盛不衰，出现了众多类似而又 相互区别的演算系统，如ACP(提出者J.A.Ber郎tra 和J.W.K10p)，ATp(提出者M.H即n樱y)，Meije(提出者G.Eudol，R.desi~)，LOTC6等，统称为进程代数。
重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象。又称仿函数。
通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“*Not?pad”可以对应Notepad\MyNotepad【*可以代表任何字符串；?仅代表单个字符串，但此单字必须存在】;Notep[ao]d可以对应Notepad\Notepod【ao代表a与o里二选一】，其余以此类推。通配符是竞价排名广告的一项高级功能，当我们在广告创意中使用了这项功能之后，使用不同搜索字词的用户将看到不同的广告创意(虽然我们只制作了一个广告)。这将大大提高我们广告的相关性和实用性，从而提高广告的点击率，同时也大大提高了我们的工作效率。
在图论的数学领域，完全图是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。完整的有向图又是一个有向图，其中每对不同的顶点通过一对唯一的边缘（每个方向一个）连接。n个端点的完全图有n个端点以及n(n − 1) / 2条边，以Kn表示。它是(k − 1)-正则图。所有完全图都是它本身的团（clique）。图形理论本身以莱昂哈德欧拉于1736年在Königsberg七桥的工作开始。 然而，完全图的绘图，其顶点放置在正多边形的点上，已经在13世纪中出现。这样的绘画有时被称为神秘玫瑰。
线性规划（Linear programming,简称LP），是运筹学中研究较早、发展较快、应用广泛、方法较成熟的一个重要分支，它是辅助人们进行科学管理的一种数学方法。研究线性约束条件下线性目标函数的极值问题的数学理论和方法。英文缩写LP。线性规划是运筹学的一个重要分支，广泛应用于军事作战、经济分析、经营管理和工程技术等方面。为合理地利用有限的人力、物力、财力等资源作出的最优决策，提供科学的依据。
除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个子结点，这样的树就是满二叉树。(一棵满二叉树的每一个结点要么是叶子结点，要么它有两个子结点，但是反过来不成立，因为完全二叉树也满足这个要求，但不是满二叉树)
拓扑序列是顶点活动网中将活动按发生的先后次序进行的一种排列。  拓扑排序，是对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边(u,v)∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。
散列码的转换符是%h
以市中心区为中心，没有精确的中心点。绕中心区成圈的道路就是环路。城市随着经济的发展，会逐渐有多条环路，越靠近中心区的环路数字越小，从内往外依次是二环、三环、四环（部分城市仅有两条环路，即分为内、外环）。
归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。
《算法设计》是2007年清华大学出版社出版发行的图书，作者是Jon Kleinberg / Éva Tardos。
[1]
深度优先搜索是一种在开发爬虫早期使用较多的方法。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。在一个HTML文件中，当一个超链被选择后，被链接的HTML文件将执行深度优先搜索，即在搜索其余的超链结果之前必须先完整地搜索单独的一条链。深度优先搜索沿着HTML文件上的超链走到不能再深入为止，然后返回到某一个HTML文件，再继续选择该HTML文件中的其他超链。当不再有其他超链可选择时，说明搜索已经结束。
[1]
快速傅里叶变换 (fast Fourier transform), 即利用计算机计算离散傅里叶变换（DFT)的高效、快速计算方法的统称，简称FFT。快速傅里叶变换是1965年由J.W.库利和T.W.图基提出的。采用这种算法能使计算机计算离散傅里叶变换所需要的乘法次数大为减少，特别是被变换的抽样点数N越多，FFT算法计算量的节省就越显著。
散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
有向图强连通分量：在有向图G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点强连通(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个强连通图。有向图的极大强连通子图，称为强连通分量(strongly connected components)。
一个有 n 个结点的连通图的生成树是原图的极小连通子图，且包含原图中的所有 n 个结点，并且有保持图连通的最少的边。
[1] 
最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。
随机游走（random walk）也称随机漫步，随机行走等是指基于过去的表现，无法预测将来的发展步骤和方向。核心概念是指任何无规则行走者所带的守恒量都各自对应着一个扩散运输定律 ，接近于布朗运动，是布朗运动理想的数学状态，现阶段主要应用于互联网链接分析及金融股票市场中。
在存在道德风险的情况下，如何保证拥有信息优势的一方（称为代理人）按照契约的另一方（委托人）的意愿行动，从而使双方都能趋向于效用最大化。 说白了就是，没有人可以通过损害集体利益去实现自己利益的最大化。个人的利益和集体的利益是一致的，每个人努力为实现自己利益的目标工作，得到的结果也是集体利益的最大化。具体示例 会展行业的激励相容理论：就是要实现主办机构、参展商、采购商的多赢，个人与企业“价值的”双赢。
串中任意个连续的字符组成的子序列称为该串的子串
串中任意个连续的字符组成的子序列称为该串的子串
所谓数组，是有序的元素序列。
[1] 
若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按有序的形式组织起来的一种形式。
[1] 
这些有序排列的同类数据元素的集合称为数组。数组是用于储存多个相同类型数据的集合。
非线性结构，数学用语，其逻辑特征是一个结点元素可能有多个直接前驱和多个直接后继。
高性能计算(High performance computing， 缩写HPC) 指通常使用很多处理器（作为单个机器的一部分）或者某一集群中组织的几台计算机（作为单个计 算资源操作）的计算系统和环境。有许多类型的HPC 系统，其范围从标准计算机的大型集群，到高度专用的硬件。大多数基于集群的HPC系统使用高性能网络互连，比如那些来自 InfiniBand 或 Myrinet 的网络互连。基本的网络拓扑和组织可以使用一个简单的总线拓扑，在性能很高的环境中，网状网络系统在主机之间提供较短的潜伏期，所以可改善总体网络性能和传输速率。

在计算机科学中，二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆。
[1] 
一棵深度为k，且有2^k-1个结点的二叉树，称为满二叉树。这种树的特点是每一层上的结点数都是最大结点数。而在一棵二叉树中，除最后一层外，若其余层都是满的，并且或者最后一层是满的，或者是在右边缺少连续若干结点，则此二叉树为完全二叉树。具有n个结点的完全二叉树的深度为floor(log2n)+1。深度为k的完全二叉树，至少有2k-1个叶子结点，至多有2k-1个结点。
[1]
在现代化管理中，人们常用有向图来描述和分析一项工程的计划和实施过程，一个工程常被分为多个小的子工程，这些子工程被称为活动（Activity)，在带权有向图中若以顶点表示事件，有向边表示活动，边上的权值表示该活动持续的时间，这样的图简称为AOE网。
查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。
权图，四川成都人，中国白酒行业资深观察家、贵州省白酒产业顾问
[1-2] 
、中国酱酒在线总编辑，国家一级品酒师。并兼任中国酿酒工业协会、河南酿酒工业协会、贵州省人民政府、仁怀市人民政府等多家行业协会特聘专家，现担任左右脑策略咨询机构总经理。权图主要侧重于中国酱香型白酒的研究、咨询和推广工作，近年来尤其对中国酱酒的产业解读、战略定位、策略指导等方面有独到的理解和实践，被业内称为“中国酱酒研究和咨询第一人”。
函数指针是指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。函数指针有两个用途：调用函数和做函数的参数。
数据元素(data element)是计算机科学术语。它是数据的基本单位，数据元素也叫做结点或记录。在计算机程序中通常作为一个整体进行考虑和处理。有时，一个数据元素可由若干个数据项组成，例如，一本书的书目信息为一个数据元素，而书目信息的每一项（如书名、作者名等）为一个数据项。数据项是数据的不可分割的最小单位。
在二叉树的结点上加上线索的二叉树称为线索二叉树，对二叉树以某种遍历方式（如先序、中序、后序或层次等）进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。
[1]
所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减的排列起来的操作。排序算法，就是如何使得记录按照要求排列的方法。排序算法在很多领域得到相当地重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域中考虑到数据的各种限制和规范，要得到一个符合实际的优秀算法，得经过大量的推理和分析。
从消费者模型出发明确市场机会
插入排序，一般也被称为直接插入排序。对于少量元素的排序，它是一个有效的算法
[1] 
。插入排序是一种最简单的排序方法，它的基本思想是将一个记录插入到已经排好序的有序表中，从而一个新的、记录数增1的有序表。在其实现过程使用双层循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动
[2] 
。
红黑树（Red Black Tree） 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
[1] 
红黑树是在1972年由Rudolf Bayer发明的，当时被称为平衡二叉B树（symmetric binary B-trees）。后来，在1978年被 Leo J. Guibas 和 Robert Sedgewick 修改为如今的“红黑树”。
[2] 
红黑树是一种特化的AVL树（平衡二叉树），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。
[2] 
它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。
[2]
链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而线性表和顺序表相应的时间复杂度分别是O(logn)和O(1)。使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的存取往往要在不同的排列顺序中转换。链表允许插入和移除表上任意位置上的节点，但是不允许随机存取。链表有很多种不同的类型：单向链表，双向链表以及循环链表。链表可以在多种编程语言中实现。像Lisp和Scheme这样的语言的内建数据类型中就包含了链表的存取和操作。程序语言或面向对象语言，如C,C++和Java依靠易变工具来生成链表。
顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元依次存储线性表中的各个元素、使得线性表中在逻辑结构上相邻的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系，采用顺序存储结构的线性表通常称为顺序表。顺序表是将表中的结点依次存放在计算机内存中一组地址连续的存储单元中。
[1]
算法（Algorithm）是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。算法中的指令描述的是一个计算，当其运行时能从一个初始状态和（可能为空的）初始输入开始，经过一系列有限而清晰定义的状态，最终产生输出并停止于一个终态。一个状态到另一个状态的转移不一定是确定的。随机化算法在内的一些算法，包含了一些随机输入。形式化算法的概念部分源自尝试解决希尔伯特提出的判定问题，并在其后尝试定义有效计算性或者有效方法中成形。这些尝试包括库尔特·哥德尔、Jacques Herbrand和斯蒂芬·科尔·克莱尼分别于1930年、1934年和1935年提出的递归函数，阿隆佐·邱奇于1936年提出的λ演算，1936年Emil Leon Post的Formulation 1和艾伦·图灵1937年提出的图灵机。即使在当前，依然常有直觉想法难以定义为形式化算法的情况。
字符串主要用于编程，概念说明、函数解释、用法详述见正文，这里补充一点：字符串在存储上类似字符数组，所以它每一位的单个元素都是可以提取的，如s=“abcdefghij”，则s[1]=“b”，s[9]="j"，而字符串的零位正是它的长度，如s[0]=10（※上述功能Ansistring没有。），这可以给我们提供很多方便，如高精度运算时每一位都可以转化为数字存入数组。
粒子群优化算法又翻译为粒子群算法、微粒群算法、或微粒群优化算法。
指令系统的每一条指令都有一个操作符，它表示该指令应进行什么性质的操作。
分治，字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。在计算机科学中，分治法就是运用分治思想的一种很重要的算法。分治法是很多高效算法的基础，如排序算法（快速排序，归并排序），傅立叶变换（快速傅立叶变换）等等。
B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。
线性表是最基本、最简单、也是最常用的一种数据结构。线性表（linear list）是数据结构的一种，一个线性表是n个具有相同特性的数据元素的有限序列。线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的（注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表（存储层次上属于链式存储，但是把最后一个数据元素的尾指针指向了首位结点）。
有向无环图指的是一个无回路的有向图。如果有一个非有向无环图，且A点出发向B经C可回到A，形成一个环。将从C到A的边方向改为从A到C，则变成有向无环图。有向无环图的生成树个数等于入度非零的节点的入度积。
顺序查找是按照序列原有顺序对数组进行遍历比较查询的基本查找算法。
满足某线性规划所有的约束条件（指全部前约束条件和后约束条件）的任意一组决策变量的取值，都称为该线性规划的一个可行解，所有可行解构成的集合称为该线性规划的可行域（类似函数的定义域），记为 K 。
《蚁群优化算法》是2008年科学出版社出版的图书，作者是马良、朱刚、宁爱兵。
[1]
复杂度(Complexity, CPX)，指的是在给定样本中不同DNA 序列的总长度，是一件事物的复杂性可以用描写这事物所需的计算机语言的长度来衡量。
冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
Kruskal算法是一种用来查找最小生成树的算法，由Joseph Kruskal在1956年发表。用来解决同样问题的还有Prim算法和Boruvka算法等。三种算法都是贪心算法的应用。和Boruvka算法不同的地方是，Kruskal算法在图中存在相同权值的边时也有效。
[1]
在计算机科学与运筹学，近似算法是指用来发现近似方法来解决优化问题的算法。近似算法通常与NP-hard问题相关; 由于不可能有效的多项式时间精确算来解决NP-hard问题，所以一个求解多项式时间次优解。与启发式算法不同，通常只能找到合理的解决方案相当快速，需要可证明的解决方案质量和可证明的运行时间范围，既近似算法通常可得到一个有质量保证的解。理想情况下，近似值最优可达到一个小的常数因子（例如在最优解的5%以内）。近似算法越来越多地用于已知精确多项式时间算法但由于输入大小而过于昂贵的问题。
[1]
连通性是‘点集拓扑学’中的基本概念，把‘连通性’定义如下：对于拓扑空间X，（1）若X中除了空集和X本身外，没有别的既开又闭的子集，则称此‘拓扑空间X是连通的’。（2）若E作为X的子空间，E在诱导拓扑下是可连通的，则称拓扑空间X的子集E，是连通的。由此，能够等价描述E的内涵有下面3点：1） 若X不能表示为两个非空不交的开集的并，则，拓扑空间X是连通的。2）若当X分成两个非空子集A、B时，并且满足A∪B时，有A交B的闭包非空，或B交A的闭包非空，则称拓扑空间X是连通的。3）若X中既开又闭的子集只有X与空集，则称，拓扑空间X是连通的。
中序遍历（LDR）是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。
[tabulate;arrange in columns or tables] 把…制成表，以表显示英文解释：list 、list files of type以表格为容器，装载着文字或图表的一种形式，叫列表。在互联网发展的同时，还衍生了一种在以网上形式发表的列表。简称“网表”。<数据结构术语>数据结构中的列表一般指线性列表的简称·列表是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合，在这种数据结构上进行的基本操作包括对元素的的查找，插入，和删除列表的两种主要表现是数组和链表，栈和队列是两种特殊类型的列表
优先队列(priority queue)普通的队列是一种先进先出的数据结构，元素在队列尾追加，而从队列头删除。在优先队列中，元素被赋予优先级。当访问元素时，具有最高优先级的元素最先删除。优先队列具有最高级先出 （first in, largest out）的行为特征。通常采用堆数据结构来实现。
树状图，亦称树枝状图。树形图是数据树的图形表示形式，以父子层次结构来组织对象。是枚举法的一种表达方式。树状图也是初中学生学习概率问题所需要画的一种图形。
桶排序 (Bucket sort)或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。
一个有向图D是指一个有序三元组(V(D)，A(D)，ψD)，其中ψD)为关联函数，它使A(D)中的每一个元素(称为有向边或弧)对应于V(D)中的一个有序元素(称为顶点或点)对．
[1]
后序遍历（LRD）是二叉树遍历的一种，也叫做后根遍历、后序周游，可记做左右根。后序遍历有递归算法和非递归算法两种。在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。
画家算法也叫作优先填充，它是三维计算机图形学中处理可见性问题的一种解决方法。当将三维场景投影到二维平面的时候，需要确定哪些多边形是可见的，哪些是不可见的。
正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在Perl中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由Unix中的工具软件（例如sed和grep）普及开的。正则表达式通常缩写成“regex”，单数有regexp、regex，复数有regexps、regexes、regexen。
效率（efficiency）是指有用功率对驱动功率的比值，同时也引申出了多种含义。效率也分为很多种，比如机械效率（mechanical efficiency）、热效率（thermal efficiency ）等。效率与做功的快慢没有直接关系。效率是指在给定投入和技术等条件下、最有效地使用资源以满足设定的愿望和需要的评价方式。
模拟退火算法来源于固体退火原理，是一种基于概率的算法，将固体加温至充分高，再让其徐徐冷却，加温时，固体内部粒子随温升变为无序状，内能增大，而徐徐冷却时粒子渐趋有序，在每个温度都达到平衡态，最后在常温时达到基态，内能减为最小。
后缀是一种重要的构词法，通过后缀常常可以判断出一个词的词性。一个英语单词可以分为三个部分：前缀（prefix），词根（stem）及后缀（suffix）。单词中位于词根前面的部分就是前缀。前缀，可以改变单词的意思。在语言学里，后缀，又称词尾，是一种后置于其他词素后的词缀。
所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是：将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。
子孙(zǐ sūn)：(1) [children and grandchildren]∶儿子和孙子(2) [descendants;offspring;posterity]∶泛指后代(3)仅指儿子
[1]
旅行推销员问题（英语：Travelling salesman problem, TSP）是这样一个问题：给定一系列城市和每对城市之间的距离，求解访问每一座城市一次并回到起始城市的最短回路。它是组合优化中的一个NP难问题，在运筹学和理论计算机科学中非常重要。最早的旅行商问题的数学规划是由Dantzig（1959）等人提出，并且是在最优化领域中进行了深入研究。许多优化方法都用它作为一个测试基准。尽管问题在计算上很困难，但已经有了大量的启发式算法和精确方法来求解数量上万的实例，并且能将误差控制在1%内。
[1]
背包问题(Knapsack problem)是一种组合优化的NP完全问题。问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。问题的名称来源于如何选择最合适的物品放置于给定背包中。相似问题经常出现在商业、组合数学，计算复杂性理论、密码学和应用数学等领域中。也可以将背包问题描述为决定性问题，即在总重量不超过W的前提下，总价值是否能达到V？它是在1978年由Merkle和Hellman提出的。背包问题已经研究了一个多世纪，早期的作品可追溯到1897年
[1] 
数学家托比亚斯·丹齐格（Tobias Dantzig，1884-1956）的早期作品
[2] 
，并指的是包装你最有价值或有用的物品而不会超载你的行李的常见问题。
舍伍德算法是概率算法的一种，该文在比较线性表的顺序存储与链式存储的特点之后，提出了一种较优的数据结构——用数组模拟链表。理论上证明了采用舍伍德算法进行查找运算的时间复杂度为0(n^1/2)，并在计算机上给出相应数据的模拟。
平面图是地图的一种。 可以用水平面代替水准面。在这个前提下，可以把测区内的地面景物沿铅垂线方向投影到平面上，按规定的符号和比例缩小而构成的相似图形，称为平面图。
贝尔曼-福特算法（Bellman-Ford）是由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的，求解单源最短路径问题的一种算法。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行V-1次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达O(VE)。但算法可以进行若干种优化，提高了效率。
算法分析是对一个算法需要多少计算时间和存储空间作定量的分析。 算法（Algorithm）是解题的步骤，可以把算法定义成解一确定类问题的任意一种特殊的方法。在计算机科学中，算法要用计算机算法语言描述，算法代表用计算机解一类问题的精确、有效的方法。
装箱问题是复杂的离散组合最优化问题。所谓组合优化,是指在离散的、有限的数学结构上,寻找一个满足给定条件,并使其目标函数值达到最大或最小的解。一般来说,组合优化问题通常带有大量的局部极值点,往往是不可微的、不连续的、多维的、有约束条件的、高度非线性的NP完全问题。装箱问题也不例外,同许多组合最优化问题,如旅行商问题、图的划分问题等一样属于NP一HARD问题。经典的装箱问题要求把一定数量的物品放入容量相同的一些箱子中,使得每个箱子中的物品大小之和不超过箱子容量并使所用的箱子数目最少。
[1]
堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
通常定义为不牺牲任何总目标和各分目标的条件下，技术上能够达到的最好的解。它表示所有的总目标和分目标都可以达到的理想的解。而实际上这样的解是很少存在的。工程问题固有的内在因素总是包含各种矛盾的，由于科学水平的限制，很多设计因素和系统的约束还不是很了解;许多判别准则。例如： 社会上的相互关系、生活的质量、生态学，以及兴趣、爱好等等，是不容易确定的，更不容易定量化。而工程系统的设计问题或规划问题中劳动力、设备、财力以及时间总是有限的。所以，最优化过程只是产生一个在设计和工艺约束条件下所能达到的“最令人满意解”。
分布式算法，就是指在完成乘加功能时通过将各输入数据每一对应位产生的运算结果预先进行相加形成相应的部分积，然后再对各部分进行累加形成最终结果。分布式算法（Distributed Algorithm）和集中式算法（Centralized Algorithm）在设计的方法和技巧上，有着非常大的不同，原因在于分布式系统和集中式系统在系统模型和结构上有着本质的区别，集中式算法所具备的一些基本特征，在分布式算法中，已经不复存在。
数据对象是必须由软件理解的复合信息表示。数据对象可能是外部实体、事物、偶发事件或事件、角色、组织单位、地点或结构等。例如，一个人或一部车可以被认为是数据对象，在某种意义上它们可以用一组属性来定义。数据对象描述包括了数据对象及其所有属性。数据对象只封装数据(没有对数据的操作)。
[1]
确定性算法是利用问题的解析性质，产生一确定的有限或无限点序列使其收敛于全局最优解。这类方法依据某一确定性策略搜索局部极小，并试图跳跃已获得的局部极小而达到某个全局最优点，能充分利用问题的解析性质，从而计算效率高。如填充函数法、打洞函数法、D.C.规划算法、区间法、单调规划、分支定界方法和积分水平集方法等，这些算法的构造都涉及到已知目标函数的某些局部性质或者全局性质。其中，函数的连续性、可微性认为是局部性质，而凸性、单调性、稠密性、等度连续性、李普希兹连续、水平集等通常称为全局性的解析性质。
拉斯维加斯算法不会得到不正确的解。一旦用拉斯维加斯算法找到一个解，这个解就一定是正确解。但有时用拉斯维加斯算法找不到解。与蒙特卡罗算法类似，拉斯维加斯算法找到正确解的概率随着它所用的计算时间的增加而提高。对于所求解问题的任一实例，用同一拉斯维加斯算法反复对该实例求解足够多次，可使求解失败的概率任意小。
邻接表，存储方法跟树的孩子链表示法相类似，是一种顺序分配和链式分配相结合的存储结构。如这个表头结点所对应的顶点存在相邻顶点，则把相邻顶点依次存放于表头结点所指向的单向链表中。对于无向图来说，使用邻接表进行存储也会出现数据冗余，表头结点A所指链表中存在一个指向C的表结点的同时，表头结点C所指链表也会存在一个指向A的表结点。
[1]
递归算法（英语：recursion algorithm）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题，因此它是计算机科学中十分重要的一个概念。绝大多数编程语言支持函数的自调用，在这些语言中函数可以通过调用自身来进行递归。计算理论可以证明递归的作用可以完全取代循环，因此在很多函数编程语言（如Scheme）中习惯用递归来实现循环。
设R是集合A上的一个关系，如果R是自反的、反对称的和可传递的，则称R是集合A的偏序关系，简称偏序，记作“≤”。对于（a，b）∈R，就把它表示成a≤b。若在集合A上给定一个偏序关系≤，则称集合A按偏序关系≤构成一个偏序集合，集合A和偏序R一起称为偏序集，记作（A，≤）。
[1]
独立集是指图 G 中两两互不相邻的顶点构成的集合。任意有关图中团的性质都能很自然的转述成独立集的性质。一般而言，寻找图的最大团是 NP 困难的，从而寻找图的最大独立集也是 NP 困难的。但是，对于二部图的情形，有多项式时间算法找出图的最大独立集。
逻辑结构分为两部分：V和E集合，其中，V是顶点，E是边。因此，用一个一维数组存放图中所有顶点数据；用一个二维数组存放顶点间关系（边或弧）的数据，这个二维数组称为邻接矩阵。邻接矩阵又分为有向图邻接矩阵和无向图邻接矩阵
入度是图论算法中重要的概念之一。它通常指有向图中某点作为图中边的终点的次数之和。
动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。
[1] 
20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。
[2]
构造函数 ，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。特别的一个类可以有多个构造函数 ，可根据其参数个数的不同或参数类型的不同来区分它们 即构造函数的重载。
在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点i到顶点j有路径相连（当然从j到i也一定有路径），则称i和j是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的连通性是图的基本性质。
[1]
霍夫曼编码（Huffman Coding）是一种编码方式，是一种用于无损数据压缩的熵编码（权编码）算法。霍夫曼编码（英语：Huffman Coding），又译为哈夫曼编码、赫夫曼编码，是一种用于无损数据压缩的熵编码（权编码）算法。由大卫·霍夫曼在1952年发明。在计算机数据处理中，霍夫曼编码使用变长编码表对源符号（如文件中的一个字母）进行编码，其中变长编码表是通过一种评估来源符号出现机率的方法得到的，出现机率高的字母使用较短的编码，反之出现机率低的则使用较长的编码，这便使编码之后的字符串的平均长度、期望值降低，从而达到无损压缩数据的目的。例如，在英文中，e的出现机率最高，而z的出现概率则最低。当利用霍夫曼编码对一篇英文进行压缩时，e极有可能用一个比特来表示，而z则可能花去25个比特（不是26）。用普通的表示方法时，每个英文字母均占用一个字节，即8个比特。二者相比，e使用了一般编码的1/8的长度，z则使用了3倍多。倘若我们能实现对于英文中各个字母出现概率的较准确的估算，就可以大幅度提高无损压缩的比例。霍夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。树的路径长度是从树根到每一结点的路径长度之和。
在计算机科学中，查找表是用简单的查询操作替换运行时计算的数组或者 associative array 这样的数据结构。
斯坦纳树问题是组合优化问题，与最小生成树相似，是最短网络的一种。最小生成树是在给定的点集和边中寻求最短网络使所有点连通。而最小斯坦纳树允许在给定点外增加额外的点，使生成的最短网络开销最小。
左式堆（Leftist Heaps)又称作最左堆、左倾堆，是计算机语言中较为常用的一个数据结构。左式堆作为堆的一种，保留了堆的一些属性。第1，左式堆仍然以二叉树的形式构建；第2，左式堆的任意结点的值比其子树任意结点值均小（最小堆的特性）。但和一般的二叉堆不同，左式堆不再是一棵完全二叉树（Complete tree)，而且是一棵极不平衡的树。
加速比（speedup），是同一个任务在单处理器系统和并行处理器系统中运行消耗的时间的比率，用来衡量并行系统或程序并行化的性能和效果。另有“超线性加速比”（superlinear speedup），即加速比比处理器数更大的情况。超线性加速比很少出现。超线性加速比有几种可能的成因，如现代计算机的存储层次不同所带来的“高速缓存效概念，具体来说，较之顺序计算，在并行计算中，不仅参与计算的处理器数量更多，不同处理器的高速缓存也集合使用。而有鉴于此，集合的缓存便足以提供计算所需的存储量，算法执行时便不必使用速度较慢的内存，因而存储器读些时间便能大幅降低，这便对实际计算产生了额外的加速效果。
关键路径是指设计中从输入到输出经过的延时最长的逻辑路径。优化关键路径是一种提高设计工作速度的有效方法。一般地，从输入到输出的延时取决于信号所经过的延时最大路径，而与其他延时小的路径无关。在优化设计过程中关键路径法可以反复使用，直到不可能减少关键路径延时为止。EDA工具中综合器及设计分析器通常都提供关键路径的信息以便设计者改进设计，提高速度。
[1]

系统的逻辑结构是对整个系统从思想的分类，把系统分成若干个逻辑单元，分别实现自己的功能。一般在系统开发时，逻辑结构往往都由架构师完成。系统的逻辑结构对系统的开发起到重要性的决定。数据的逻辑结构是对数据之间关系的描述，有时就把逻辑结构简称为数据结构。逻辑结构形式地定义为（K，R）（或（D，S）），其中，K是数据元素的有限集，R是K上的关系的有限集。
该片讲述一个叫“树”的人，他的村庄异常寒冷，积雪难化。“树”还是单身，在村里的汽修铺工作。他常去村口的酒馆和朋友喝酒，一起长大的伙伴，有人开着好车成了煤老板，有人远在省城办私立学校，有人还在种地。聚会的时候，如果没有被人取笑，“树”就沉默着，象旷野里被人忘记的一棵树。
子图是图论的基本概念之一，指节点集和边集分别是某一图的节点集的子集和边集的子集的图。若这个节点子集或边子集是真子集，则称这个子图为真子图；若图G的每一个节点也是它的子图H的节点，则称H是G的支撑子图。设S是V(G)的子集，以S为节点集，以G的所有那些两端点都在S内的边组成边集，所得到的G的子图称为S在G中的导出子图，或更确切地，节点导出子图。设B是E(G)的子集，由G的所有与B内至少有一条边关联的节点组成节点集，以B为边集，所得到的G的子图称为B在G中的边导出子图；对于某种性质P，若一个图的具有P的子图不是任何具有P的子图的真子图，则称它为具有P的极大子图，在所有极大子图中，边数最多的那个称为最大子图。
[1]
设T是有根树，a是T中的一个顶点，由a以及a的所有后裔（后代）导出的子图称为有向树T的子树。
线性结构是一个有序数据元素的集合。
[1] 
常用的线性结构有：线性表，栈，队列，双队列，串(一维数组)。关于广义表、数组(高维)，是一种非线性的数据结构。常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图
概率算法也叫随机化算法。概率算法允许算法在执行过程中随机地选择下一个计算步骤。在很多情况下，算法在执行过程中面临选择时，随机性选择比最优选择省时，因此概率算法可以在很大程度上降低算法的复杂度。概率算法的一个基本特征是对所求解问题的同一实例用同一概率算法求解两次可能得到完全不同的效果。这两次求解问题所需的时间甚至所得到的结果可能会有相当大的差别
[1] 
。
计算机网络节点
电信网络节点
网络拓扑
参见
排序问题
选择排序思路
具体实现方法
算法性能
树形选择排序
参考代码
定义
相关概念
求无向图的连通分量
简介
数学表达式形式
复杂性
程序实现
哈希表的概念及作用
哈希表的构造方法
冲突
定义
性能分析
示例
基本信息
递归举例
递归详解
字母由来
字母列表
声韵母读法
相关列表
其他释义
最长的字母表
简介
链接存储
顺序表
简介
历史
应用
基本术语
构造
多叉哈夫曼树
实现方法
示例
汉语词语
信息技术名词
计算机算法
英文对照
定义及应用
求解算法
简介
算法
评论
定义
简介
体系结构
访存模型
计算模型
研究内容
未来应用
定义
解释
定义
发展历程
分类
常用算法
应用举例
概述
问题描述
应用背景
常用算法
简介
结构描述
二叉链表的功能定义
基本信息
字义
汉字演变
基本词义
古籍解释
谜语
汉英互译
词性变化
常用词组
串的书法
IT术语
水冶小吃
粉丝名称
导读
概念
物理地址与虚拟地址
和地址空间
IPv6地址空间
Linux进程的虚拟地址空间
基本解释
引证解释
单链表简介
单链表定义
单链表的建立
动态存储
链表的操作
元素的操作
双向链表模板
循环链表
概念
区别联系
数据元素
内容简介
定义
概念介绍
树的表示
树的遍历
树的应用
二叉树
最短路径介绍
解决方法
最短路径算法
释义
分类
重做日志文件
控制文件
数据文件
定义
性质
特点
完全二叉树判定
基本介绍
相关概念
回溯算法思路
程实现
定理及其证明
强连通图的边问题
强连通图的判断
应用背景
表示方法
基本操作
存在问题
简介
历史
定义
方法
中国的研究者
简介
C++ STL中的函数对象
类型
使用模式
应用举例
简介
属性
几何和拓扑
举例
无向完全图
有向完全图
线性规划简介
标准型
模型建立
解法
发展
应用
定义
基于满二叉树的原地快速排序
基于满二叉树二分K-means聚类并行推荐算法
基于满二叉树的RA码交织器设计
简介
相关简介
过程
解释
应用
数学定义
网络定义
归并操作
算法描述
比较
用途
示例代码
复杂度
归并算法
应用实例
图书简介
内容简介
本书特点
目录
详细解释
基本思路
穷举
系统算法
基本框架
C++的实现
举例
简要介绍
基本思想
算法类型
计算方法
应用
参考书目
基本概念
常用方法
处理冲突
查找性能
实际应用
字符串
算法思路
算法总结
概述
应用
性质
算法描述
释义
定律介绍
其他类型
模型
定义
设计激励手段
管理意义
示例
启示意义
程语言
计算方法
程语言
计算方法
产生来源
数组中的元素
结构形式
相关操作
数组类型
表示方法
赋值方法
使用规则
常用函数
概述
比较
提升性能
优化
应用发展
工作站
走向普及
摩尔定律
气象事业
中国冠军
定义
基本概念
相关术语
二叉树性质
存储结构
二叉树遍历
线索二叉树
示例
概念
性质
概念
顺序查找
二分查找
分块查找
哈希表查找
职业履历
专长领域
酱酒行业发展评论
方法
对比区别
指针数组
基本理论
组成
属性
信息代码化
应用领域
参考文献
概念
本质
优势与不足
存储结构
构建
概述
分类
评价标准
常见排序算法
C 语言代码实现
基本思想
伪代码
示例
实现
稳定性分析
应用分析
简介
特征
树的旋转
操作
用途
数据结构简述
特点
基本操作
链表函数
简介
基本操作
特征
要素
评定
方法
描述方式
分类
历史
相关
简介
函数应用
病毒
形式理论
串接子串
词典排序
运算
数据类型
长度
字符编码
实现
表示法
实用程序
操作
算法
PHP中介绍
简介
算法介绍
与遗传算法的比较
PSO
参数设置
基本特性
操作符分类
重载操作符
SQL操作符
分治法
适用条件
设计步骤
大整数乘法
简介
定义
节点结构
特征
算法
B+树与B-树
简介
特征
基本操作
存储结构
结构特点
线性表的推广
描述
应用
基本原理：
代码实现
简介
基本可行解
基本解
最优解
联系
内容简介
目录
一般定义
算法
算法原理
算法分析
算法描述
优化
算法比较
基本思想
步骤
证明
时间复杂度
C++语言程序
算法设计技术
策略
实例
性质
其他相关概念
连通性问题
定义
数学表达式形式
复杂性
程序实现
解释
列表控件
定义
实例
操作
与队列相似
定义
画法
例题
定义
算法
代价
源码
应用
相关概念
邻接矩阵
最短路的求解
可达性
定义
递归算法
非递归算法
简介
逆向画家算法
深度缓冲技术
概念
简介
起源
目的
特点
引擎
符号
速记理解技巧
替换技巧
零宽断言
负向零宽
管理学名词
科技名词
算法简介
原理
应用
名词解释
后缀类型
读音
引证解释
近义词
英文翻译
简介
研究历史
分类
问题解法
解法思路
研究进展
问题分析
应用
应用
定义
基础背包
完全背包
多重问题
三种背包
二维费用
分组背包
依赖问题
泛化物品
问法变化
基本思想
2线性表的组织
3数组实现链表
4用类模板实现算法
5程序测试
总结
定义
测绘学
房屋建筑学
图论
简介
算法
原理
优化
简介
时间复杂度
空间复杂度
应用
简介
定义
分类
解决办法
简介
堆的操作
实现示例
简介
定理
判定方法
概述
经典算法
数据对象简介
数据属性
数据对象联系
辅助数据对象
全局优化问题
填充函数法
打洞函数法
D.C.规划算法
区间方法
分支定界方法
简介
算法
随机化算法
快速排序
简介
表示法
邻接表的形式说明
pascal程序
递归程序
能够解决的问题
递归数据
偏序集与偏序关系的概念
偏序集的哈塞图
定义
团
举例
定义
特点
描述
表示法
简介
入度的常见情况
相关定理
有向图
分类
概念意义
实现问题
应用
推荐书籍
主要特点
应用
其他特点
语法
内存机制
语言细节
严格定义
相关概念
性质
历史
问题定义与解法
实现方法
原理
计算正弦值
计算 1 的位数
硬件查找表
问题的提出
定义
性质
应用
简介
Npl
左式堆
定理
操作方法
时间复杂度
变形
定义
超线性加速比
并行计算加速比-阿姆达尔定律
基于阿姆达尔定律和兰特法则计算的加速比
并行处理中节点间通信对加速比的影响
介绍
步骤
相关术语
应用
算法
代码
参见
系统的逻辑结构
逻辑结构类型
逻辑结构设计
影片梗概
创作阐述
导演简介
制作公司简介
主演简介
影片评价
基础知识
相关定理
图的操作
介绍
代码
分类
特征
提出
基本特征
期望时间
特点
分类